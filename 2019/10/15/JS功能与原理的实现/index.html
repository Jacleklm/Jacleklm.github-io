<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JS功能与原理的实现 | Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JS 原理的实现实现一个 Promise()Promise 的特点：  new Promise 时需要传递一个函数 fn 作为执行器（执行器会立刻执行） 执行器中传递了两个参数：resolve 成功的函数、reject 失败的函数（他们调用时可以接受任何值的参数 value） promise 状态只能从 pending 态转到 resolved 或者 rejected，如果状态发生改变执行相应缓存">
<meta property="og:type" content="article">
<meta property="og:title" content="JS功能与原理的实现">
<meta property="og:url" content="http://example.com/2019/10/15/JS%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="JS 原理的实现实现一个 Promise()Promise 的特点：  new Promise 时需要传递一个函数 fn 作为执行器（执行器会立刻执行） 执行器中传递了两个参数：resolve 成功的函数、reject 失败的函数（他们调用时可以接受任何值的参数 value） promise 状态只能从 pending 态转到 resolved 或者 rejected，如果状态发生改变执行相应缓存">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/JS%E5%92%8CES6/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.png">
<meta property="article:published_time" content="2019-10-15T08:50:21.000Z">
<meta property="article:modified_time" content="2023-09-17T14:00:22.865Z">
<meta property="article:author" content="Jacleklm">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/JS%E5%92%8CES6/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.png">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JS功能与原理的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/15/JS%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2019-10-15T08:50:21.000Z" itemprop="datePublished">2019-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JS功能与原理的实现
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="JS-原理的实现"><a href="#JS-原理的实现" class="headerlink" title="JS 原理的实现"></a>JS 原理的实现</h2><h3 id="实现一个-Promise"><a href="#实现一个-Promise" class="headerlink" title="实现一个 Promise()"></a>实现一个 Promise()</h3><p>Promise 的特点：</p>
<ul>
<li>new Promise 时需要传递一个函数 fn 作为执行器（执行器会立刻执行）</li>
<li>执行器中传递了两个参数：resolve 成功的函数、reject 失败的函数（他们调用时可以接受任何值的参数 value）</li>
<li>promise 状态只能从 pending 态转到 resolved 或者 rejected，<strong>如果状态发生改变执行相应缓存队列中的任务</strong></li>
<li>promise 实例,每个实例都有一个 then 方法，这个方法传递两个参数，一个是成功回调 onfulfilled,另一个是失败回调 onrejected</li>
<li>promise 实例调用 then 时，会判断当前状态，如果 pending，就…；如果 resolved，就让 onfulfilled 执行；如果 rejectd，就 onrejected 执行</li>
<li>promise 中可以同一个实例 then 多次,如果状态是 pengding 需要将函数存放起来 等待状态确定后 在依次将对应的函数执行 (发布订阅)</li>
</ul>
<p>基于上述特点，实现的 Promise 如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// value 变量用于保存 resolve 或者 reject 中传入的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  <span class="comment">// 用于保存 then 中的回调（可能有多个所以是数组），因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">resolvedAry</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rejectedAry</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先两个函数都得判断当前状态是否为等待中</span></span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      that.<span class="property">status</span> === <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">      that.<span class="property">value</span> = value;</span><br><span class="line">      <span class="comment">// 遍历回调数组并执行</span></span><br><span class="line">      that.<span class="property">resolvedAry</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      that.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      that.<span class="property">value</span> = value;</span><br><span class="line">      that.<span class="property">rejectedAry</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后我们来实现较为复杂的 then 函数。接收两个回调函数为参数</span></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onfulfilled, onrejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断两个参数是否为函数类型</span></span><br><span class="line">  onfulfilled = <span class="keyword">typeof</span> onfulfilled === <span class="string">&quot;function&quot;</span> ? onfulfilled : <span class="function"><span class="params">f</span> =&gt;</span> f;</span><br><span class="line">  onrejected =</span><br><span class="line">    <span class="keyword">typeof</span> onrejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onrejected</span><br><span class="line">      : <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolvedAry</span>.<span class="title function_">push</span>(onfulfilled);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectedAry</span>.<span class="title function_">push</span>(onrejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">onfulfilled</span>(that.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">onrejected</span>(that.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all()"></a>实现Promise.all()</h3><p>Promise.all 接收一个 promise 对象的数组作为参数，当这个数组里的所有 promise 对象全部变为resolve或 有 reject 状态出现的时候，它才会去调用 .then 方法,它们是并发执行的。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p1 = Promise.resolve(1),</span><br><span class="line">    p2 = Promise.resolve(2),</span><br><span class="line">    p3 = Promise.resolve(3); // 若任一 Promise 状态是reject，则无法执行 .then</span><br><span class="line">Promise.all([p1, p2, p3]).then(function (results) &#123;</span><br><span class="line">    console.log(results);  // [1, 2, 3]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>总结 promise.all 的特点</p>
<ul>
<li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象</li>
<li>如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</li>
<li>如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</li>
<li>只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象</li>
</ul>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function promiseAll(promises) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    if (!isArray(promises)) &#123;</span><br><span class="line">      return reject(new TypeError(&#x27;arguments must be an array&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">    var resolvedCounter = 0;</span><br><span class="line">    var promiseNum = promises.length;</span><br><span class="line">    var resolvedValues = new Array(promiseNum);</span><br><span class="line">    for (var i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      (function(i) &#123;</span><br><span class="line">        Promise.resolve(promises[i]).then(function(value) &#123;</span><br><span class="line">          resolvedCounter++</span><br><span class="line">          resolvedValues[i] = value</span><br><span class="line">          if (resolvedCounter == promiseNum) &#123;</span><br><span class="line">            return resolve(resolvedValues)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, function(reason) &#123;</span><br><span class="line">          return reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手写实现-call-apply-bind"><a href="#手写实现-call-apply-bind" class="headerlink" title="手写实现 call(), apply(), bind()"></a>手写实现 call(), apply(), bind()</h3><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><ul>
<li>首先 context 为可选参数，如果不传的话默认上下文为 window</li>
<li>接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数</li>
<li>因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li>
<li>然后调用函数并将对象上的函数删除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>类似，区别在于对参数的处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 处理参数和 call 有区别</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式</p>
<ul>
<li>对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code></li>
<li>通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this。（似乎这种 new 的用法很少见）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">_this</span>(...args, ...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接调用的情况</span></span><br><span class="line">    <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 可以正确的判断对象的类型，其内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。实现原理如下：</p>
<ul>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">muInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  left = left.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (prototype === left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    left = left.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手写实现-new"><a href="#手写实现-new" class="headerlink" title="手写实现 new"></a>手写实现 new</h3><p>在调用 new 的过程中会发生四件事情:</p>
<ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this(使用构造函数的 this)</li>
<li>返回新对象（原始类型的话忽略，如果是引用类型的话就返回这个对象）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">myNew</span>() = <span class="keyword">function</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// func是new后面的那个构造函数</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  obj.<span class="property">_proto_</span> = func.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">let</span> result = func.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="手写实现-Object-create"><a href="#手写实现-Object-create" class="headerlink" title="手写实现 Object.create()"></a>手写实现 Object.create()</h3><p>Object.create()方法创建一个新对象，使用参数对象（而不是参数对象.prtototype）来提供新创建的对象的<code>__proto__</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycreate</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 +0.2 !&#x3D;&#x3D; 0.3"></a>0.1 +0.2 !&#x3D;&#x3D; 0.3</h3><p>对于纯小数来说，十进制的 0.375 会被存储为： 0.011 其代表 (1&#x2F;2)^2 + (1&#x2F;2)^3 &#x3D; 1&#x2F;4 + 1&#x2F;8 &#x3D; 0.375<br>但是对 0.1 这种数值来说，算下来是 0.000110011… 由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。JS 采用 IEEE 754 双精度版本（64 位）浮点数标准，也是只能取得一个近似值。除了那些能表示成 (x&#x2F;2)^n 的数可以被精确表示以外，其余小数都是以近似值得方式存在的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1000000000000001</span>);</span><br><span class="line"><span class="comment">// 0.1000000000000001 (中间14个0，会打印出它本身)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.10000000000000001</span>);</span><br><span class="line"><span class="comment">// 0.1 (中间15个0，js会认为这两个值足够接近，所以会显示0.1)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.100000000000000002</span> === <span class="number">0.1</span>; <span class="comment">// true （16个0）</span></span><br><span class="line"><span class="number">0.200000000000000002</span> === <span class="number">0.2</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.30000000000000004</span>; <span class="comment">// true。此时对于JS来说，其不够近似于0.3，于是就出现了0.1 + 0.2 != 0.3 这个现象</span></span><br></pre></td></tr></table></figure>

<p><strong>解决：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).<span class="title function_">toFixed</span>(<span class="number">10</span>)) === <span class="number">0.3</span>; <span class="comment">// true  toFixed()将数值格式化为字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="双向数据绑定实现原理"><a href="#双向数据绑定实现原理" class="headerlink" title="双向数据绑定实现原理"></a>双向数据绑定实现原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向数据绑定</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;span&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据劫持</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;text&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取数据&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据更新&quot;</span>);</span><br><span class="line">    input.<span class="property">value</span> = newVal; <span class="comment">// 要双向绑定所以有这句</span></span><br><span class="line">    span.<span class="property">innerHTML</span> = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  obj.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="JS-功能的实现"><a href="#JS-功能的实现" class="headerlink" title="JS 功能的实现"></a>JS 功能的实现</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">100</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>sort() + reduce</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">sort</span>().<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (acc.<span class="property">length</span> === <span class="number">0</span> || curr !== acc[acc.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">    acc.<span class="title function_">push</span>(curr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<ul>
<li>Array.from(new Set(arr))</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br></pre></td></tr></table></figure>

<ul>
<li>for…of + Object (性能最优）。利用对象的属性不会重复这一特性，校验数组元素是否重复</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line">obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj[i]) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(i);</span><br><span class="line">    obj[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = (arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, , <span class="string">&quot;tset&quot;</span>]]], <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>Array.prototype.flat()。参数是要提取的嵌套数组的深度（数字），默认值是 1；也可以直接写 Infinity 作为参数。但是会移除数组中的空项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>); <span class="comment">// [1, 2, 3, 4, 5, &quot;tset&quot;, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>reduce 写一个递归函数。似乎也会移除空项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFlat</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(curr) ? <span class="title function_">myFlat</span>(curr) : curr),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, &quot;tset&quot;, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>扩展运算符 + Array.prototype.some() 这里的 isArray 用法稍微有点特殊。并且空项不会被移除，会保留为<code>undefined</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="title class_">Array</span>.<span class="property">isArray</span>)) &#123;</span><br><span class="line">  arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数的-arguement-怎么转数组"><a href="#函数的-arguement-怎么转数组" class="headerlink" title="函数的 arguement 怎么转数组"></a>函数的 arguement 怎么转数组</h3><p>Array.from(), 扩展运算符</p>
<h3 id="for…in-for…of-forEach"><a href="#for…in-for…of-forEach" class="headerlink" title="for…in, for…of, forEach()"></a>for…in, for…of, forEach()</h3><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p>一般用来遍历对象。有几个缺点：</p>
<ul>
<li>for…in 会遍历手动添加的原型链上的键。比如你自己写个<code>Object.prototype.test = function &#123; xxx &#125;</code>，是能遍历到这个<code>test</code>属性的</li>
<li>用来遍历数组的时候是遍历数组的键名（index），并且这个 index 是字符串</li>
<li>某些情况下，for…in 循环会以任意顺序遍历键名</li>
</ul>
<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><ul>
<li>遍历数组得到数组的 value</li>
<li><code>for (let [k, v] of Object.entries(obj)) &#123; &#125;</code> 用来遍历对象，能获取对象的键和键值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jacle&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;student&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;jacle&quot;</span>, <span class="number">22</span>, <span class="string">&quot;student&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&quot;:&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>遍历数组，问题是无法用 break，return 跳出循环<br>如何中断 forEach 循环：</p>
<ul>
<li>使用 try 监视代码块，在需要中断的地方抛出异常</li>
<li>官方推荐方法（替换方法）：用 every 和 some 替代 forEach 函数。every 在碰到 return false 的时候，中止循环。some 在碰到 return ture 的时候，中止循环</li>
</ul>
<h3 id="数组中是否包含某个值"><a href="#数组中是否包含某个值" class="headerlink" title="数组中是否包含某个值"></a>数组中是否包含某个值</h3><ul>
<li><code>Array.prototype.indexOf(值)</code>。返回 index 或 -1 。该方法也可用于 String</li>
<li><code>Array.prototype.includes(值)</code>。返回布尔值。该方法也可用于 String</li>
<li><code>Array.prototype.find(callback[,thisVal])</code>。返回数组中满足条件的<strong>第一个元素的值</strong>，如果没有，返回 undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">100</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.findeIndex(callback[,thisArg])</code>。返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1]</li>
</ul>
<h3 id="对象按规则排序"><a href="#对象按规则排序" class="headerlink" title="对象按规则排序"></a>对象按规则排序</h3><p>有一个数组，里面都是对象，现在要针对对象中的某一个 key 进行排序，顺序是已给定的数组。<br>比如原数组为<code>[&#123;a:&#39;ww&#39;&#125;,&#123;a:&#39;ff&#39;&#125;,&#123;a:&#39;pe&#39;&#125;]</code>，<br>顺序是<code>[&#123;ww:1&#125;,&#123;pe:3&#125;,&#123;hf:2&#125;,&#123;oo:4&#125;,&#123;ff:5&#125;]</code><br>那么输出是 <code>[&#123;a:&#39;ww&#39;&#125;,&#123;a:&#39;pe&#39;&#125;,&#123;a:&#39;ff&#39;&#125;]</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objarr = [&#123; <span class="attr">a</span>: <span class="string">&quot;ww&quot;</span> &#125;, &#123; <span class="attr">a</span>: <span class="string">&quot;ff&quot;</span> &#125;, &#123; <span class="attr">a</span>: <span class="string">&quot;pe&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> rulearr = [&#123; <span class="attr">ww</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">pe</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">hf</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">oo</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">ff</span>: <span class="number">5</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力解决</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortByRule</span>(<span class="params">objarr, key, rulearr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">ResultArr</span> = [];</span><br><span class="line">  rulearr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前的value和规则的位次</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(item)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> order = item[value];</span><br><span class="line">    <span class="comment">//找到对应的obj放入对应位次的位置</span></span><br><span class="line">    <span class="title class_">ResultArr</span>[order] = objarr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item[key] === value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//去掉那些为空的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ResultArr</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="n-到-m-范围的随机整数数"><a href="#n-到-m-范围的随机整数数" class="headerlink" title="n 到 m 范围的随机整数数"></a>n 到 m 范围的随机整数数</h3><ul>
<li>Math.random()生成[0, 1)的数，所以</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>() * m; <span class="comment">// 生成&#123;0,m)的数；</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要整数有向下取整 Math.floor()，向上 Math.ceil()。所以[1, m]的数是</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m); <span class="comment">// [1, m]的数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m) + <span class="number">1</span>; <span class="comment">// [1, m]的数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m); <span class="comment">// [0, m-1]的数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所以希望生成[n, m]的随机数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>) + min);</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝与浅拷贝的实现"><a href="#深拷贝与浅拷贝的实现" class="headerlink" title="深拷贝与浅拷贝的实现"></a>深拷贝与浅拷贝的实现</h3><h4 id="赋值（-），浅拷贝与深拷贝的区别"><a href="#赋值（-），浅拷贝与深拷贝的区别" class="headerlink" title="赋值（&#x3D;），浅拷贝与深拷贝的区别"></a>赋值（&#x3D;），浅拷贝与深拷贝的区别</h4><p><img src="/img/JS%E5%92%8CES6/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.png">  </p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据</p>
<ul>
<li>Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，是浅拷贝</li>
</ul>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。Object.assign(target, source)。直接用 Object.assign(target, source) 这种用法就能更新target对象。当然也能用来赋值新对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a);</span><br><span class="line">a.<span class="property">age</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>展开运算符 …</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;;</span><br><span class="line">a.<span class="property">age</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数据的浅拷贝还有 <code>let arr2 = [].concat(arr1)</code> 和 <code>let arr2 = arr1.slice()</code></li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>对对象以及对象的所有子对象进行拷贝<br>通过 JSON.parse(JSON.stringify(object))来实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">jobs</span>: &#123;</span><br><span class="line">    <span class="attr">first</span>: <span class="string">&quot;FE&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a));</span><br><span class="line">a.<span class="property">jobs</span>.<span class="property">first</span> = <span class="string">&quot;native&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">jobs</span>.<span class="property">first</span>); <span class="comment">// FE</span></span><br></pre></td></tr></table></figure>

<p>局限性 ：会忽略 undefined；会忽略 symbol；不能序列化函数；不能解决循环引用的对象<br>自己实现一个深拷贝的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断传进来的obj是否是引用类型</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isObj</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> o === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> o === <span class="string">&quot;function&quot;</span>) &amp; (o !== <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断传进来的obj这个引用类型是对象还是数组，按正确的方式浅拷贝一次</span></span><br><span class="line">  <span class="keyword">let</span> newobj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [...obj] : &#123; ...obj &#125;;</span><br><span class="line">  <span class="comment">//  对新对象的key遍历，原来obj的key是基本类型还是引用类型，基本类型就直接复制，引用类型就深拷贝一次</span></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(newobj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newobj[key] = <span class="title function_">isObj</span>(obj[key]) ? <span class="title function_">deepClone</span>(obj[key]) : obj[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间戳的获取"><a href="#时间戳的获取" class="headerlink" title="时间戳的获取"></a>时间戳的获取</h4><p>时间戳是指格林威治时间1970年01月01日00时00分00秒起至当下的总秒数。JS中拿到时间戳：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一种方法：</span><br><span class="line">var timestamp = Date.parse(new Date());</span><br><span class="line"></span><br><span class="line">第二种方法：</span><br><span class="line">var timestamp = (new Date()).valueOf();</span><br><span class="line"></span><br><span class="line">第三种方法：</span><br><span class="line">var timestamp = new Date().getTime()；</span><br><span class="line"> </span><br><span class="line">第四种方法：</span><br><span class="line">var timestamp = Date.now();</span><br></pre></td></tr></table></figure>

<p>参考资料<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010765655">实现 JavaScript 异步方法 Promise.all</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/15/JS%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="clmniym6w000xbb8762b2157l" data-title="JS功能与原理的实现" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          正则表达式
        
      </div>
    </a>
  
  
    <a href="/2019/10/15/%E5%9C%BA%E6%99%AF%E5%AE%9E%E7%8E%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">场景实现</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>