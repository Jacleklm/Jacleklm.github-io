<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>数据结构与算法 | Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前言吹爆这个博客：awesome-coding-js，强烈建议刷完这个博客 字符串常用API：操作方法。拼接concat(), 裁剪slice(), substr(), substring()，拆分变数组split()，repeat()（接收一个大于等于0的整数为参数，返回复制这个整数倍次数的字符串）位置方法。indexof(), lastIndexof()模式匹配方法。match()（接受一个正">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="前言吹爆这个博客：awesome-coding-js，强烈建议刷完这个博客 字符串常用API：操作方法。拼接concat(), 裁剪slice(), substr(), substring()，拆分变数组split()，repeat()（接收一个大于等于0的整数为参数，返回复制这个整数倍次数的字符串）位置方法。indexof(), lastIndexof()模式匹配方法。match()（接受一个正">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F2.png">
<meta property="og:image" content="http://example.com/img/%E7%AE%97%E6%B3%95/%E5%A0%86.png">
<meta property="article:published_time" content="2019-10-19T15:50:21.000Z">
<meta property="article:modified_time" content="2023-09-17T14:00:22.881Z">
<meta property="article:author" content="Jacleklm">
<meta property="article:tag" content="Data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F2.png">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数据结构与算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2019-10-19T15:50:21.000Z" itemprop="datePublished">2019-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      数据结构与算法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>吹爆这个博客：<a target="_blank" rel="noopener" href="http://www.conardli.top/docs/">awesome-coding-js</a>，强烈建议刷完这个博客</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>常用API：<br>操作方法。拼接concat(), 裁剪slice(), substr(), substring()，拆分变数组split()，repeat()（接收一个大于等于0的整数为参数，返回复制这个整数倍次数的字符串）<br>位置方法。indexof(), lastIndexof()<br>模式匹配方法。match()（接受一个正则做参数，返回匹配结果数组有）, search()(少用), replace()（第一个参数是正则或字符串，第二个是用来替换的字符串。要实现多次替换必须是用带g的正则）, startsWith()（用来检测字符串是否已制定的前缀开头，返回布尔值。接收一个或者两个参数，第一个是前缀，第二是开始查找的位置）</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>常用API：<br>includes()。判断一个数组是否包含一个指定的值（接收这个值为参数，返回布尔值）<br><strong>栈方法（先进后出）</strong>：push()，pop()（会删除最后一项并作为返回值）<br><strong>队列方法（先进先出）</strong>：shift()（会删除第一项并作为返回值），unshift()（在数组前端添加任意个项并返回新数组的长度）<br><strong>排序方法</strong>：reverse(), sort()（可以接收一个比较函数为参数，比较函数返回的值小于0，a会被排到b前面；没有传入比较函数，就只是单纯把数组toString()，然后用字符串的方法比较排序）<br><strong>操作方法</strong>：concat()（拼接。返回新数组。不影响原来数组），slice()（裁剪。返回新数组。不影响原来数组。一个参数时返回该位置到末尾的所有项；两个参数时返回两个位置之间的项，但不包含结束位置的项），splice()（可删除，替换，插入。会影响原始数组。始终会返回一个数组，该数组包含从原始数组中删除的项）<br><strong>位置方法</strong>：indexOf()，lastIndexOf()。找到的话将返回位置，没找到的话会返回-1</p>
<h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p><strong>不生成数组的迭代</strong><br>every()：测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。它的参数是一个返回值为布尔值的函数，所以用箭头函数表示很方便。<br>eg. <code>[12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false</code><br>some()：同理，不过只要一个元素能通过就会返回true。<br>**reduce()**：累加器（骚操作神器），一定要return。对数值数组可以求和，对字符串数组相当于join()。更强大的功能见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">MDN</a>的例子（累加对象里的键值；将二维数组转为一维；计算数组中每个元素出现的次数；按属性对Object分类；数组去重；绑定包含在对象数组中的数组）<br>eg. <code>[1, 2, 3, 4].reduce((accumulator, currentValue) =&gt; accumulator + currentValue;)  //将会得到10</code><br>reduceRight()：同理，不过是从右往左开始累加<br>forEach()。很好用不解释<br><strong>生成数组的迭代</strong><br>map()：和forEach类似。不过会返回新生成的数组（本来就是一个数组）保存操作结果<br>filter()：和every()类似，不过会生成新数组来包含这些通过测试的item</p>
<h5 id="借用apply"><a href="#借用apply" class="headerlink" title="借用apply"></a>借用apply</h5><p>获取数组中最小值的方法： Math.min.apply(null, arr)</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h5><p>Array.from() 将类似数组的对象转为数组（arguement，Nodelist），也能将普通对象的key值取出来生成一个数组</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/10/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">正则</a></h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>说实话递归用的不溜</p>
<ul>
<li>一般是一个数组保存结果，写一个递归函数，让这个函数执行一下，返回保存的结果<br>递归函数都喜欢设置第一个参数为暂时的处理结果（可以是数组），第二个参数是要处理的东西。递归函数内部，喜欢用if来判断终点，else来处理正常情况。这个正常情况最后都会递归一下。</li>
<li>递归函数内进行一些操作之后，最后再是边界判断决定是要return递归还是return结果。最终return也可以是递归函数的执行结果</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>sort()虽然好用，但底层是一次完整的遍历排序，耗性能，做排序算法题能不用就不用。如果题目中要用数组的最大值&#x2F;最小值，先想想能不能用冒泡&#x2F;选择 排序。</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><strong>对于评述算法优劣术语的说明</strong><br><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；<br><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。对于一个算法来说，可能会计算出如下操作次数 aN +1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。空间复杂度表示算法的存储空间与数据规模之间的增长关系。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fun(n) &#123;</span><br><span class="line">  let a = [];</span><br><span class="line">  for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    a.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码我们可以清晰的看出代码执行的空间为 O(1+n) &#x3D; O(n)，即为 i 及数组 a 占用的储存空间<br><img src="/img/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F2.png"></p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><strong>一个排好序的数组，在其找item &#x3D;&#x3D;&#x3D; flag的item的index。要start，end，middle</strong><br>首先先找到长度中间位置，通过与中间位置的数比较，比中间值大在右边找，比中间值小在左边找。然后再在两边各自寻找中间值，持续进行，直到找到全部位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设arr已经排好序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, flag, start, end</span>) &#123;</span><br><span class="line">  start = start || <span class="number">0</span></span><br><span class="line">  end = end || arr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>((realStart + realEnd) / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> (arr[m] === flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag &lt; arr[m]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(arr, flag, start, m - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag &gt; arr[m]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(arr, flag, m + <span class="number">1</span>, end)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归的方法也写一个吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> end = arr.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>((start + end) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag === arr[m]) &#123;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; arr[m]) &#123;</span><br><span class="line">      start = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; arr[m]) &#123;</span><br><span class="line">      end = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序-两两比较，大者排后"><a href="#冒泡排序-两两比较，大者排后" class="headerlink" title="冒泡排序(两两比较，大者排后)"></a>冒泡排序(两两比较，大者排后)</h4><blockquote>
<p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置。实现代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (arr) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 冒泡排序</span></span><br><span class="line">  <span class="comment">// i是每一轮操作的终点，j是每一次操作的具体位置，tmp为被操作元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>, tmp; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      tmp = arr[j]</span><br><span class="line">      <span class="keyword">if</span> (tmp &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>怎么实现降序? 将内层循环的if条件语句改为小于号即可</p>
</blockquote>
<blockquote>
<p>该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + … + 1 ，去掉常数项以后得出时间复杂度是O(n * n)</p>
</blockquote>
<h4 id="选择排序（设置最小值索引）"><a href="#选择排序（设置最小值索引）" class="headerlink" title="选择排序（设置最小值索引）"></a>选择排序（设置最小值索引）</h4><blockquote>
<p>选择排序的原理如下。遍历数组，设置最小值的索引为遍历的起始位置，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作<br>口语化说法：遍历数组，找到最小值的元素放到数组的第一位；第二轮遍历，找到剩下的元素的最小值元素放到数组第二位；…（每次都能知道最小值）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (arr) &#123;</span><br><span class="line">  <span class="comment">//  两个for（第一个for是总遍历确定位置，第二个for是确定位置之后再遍历剩下的项），还需要一个变量储存最小，一个变量方便互换位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = arr[i]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = min</span><br><span class="line">        min = arr[j]</span><br><span class="line">        arr[j] = c</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>是利用二分查找对冒泡排序的改进，原理如下：随机选取一个数组中的值作为基准值，遍历数组把每项与基准值对比大小。比基准值小的放数组左边，大的放右边。然后将数组以基准值的位置分为两部分，继续递归以上操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//中间位置</span></span><br><span class="line">  <span class="keyword">let</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> flag = arr.<span class="title function_">splice</span>(middle, <span class="number">1</span>)[<span class="number">0</span>];<span class="comment">//取出中间元素</span></span><br><span class="line">  <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;<span class="comment">// 注意这里是arr.length</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; flag) &#123; <span class="comment">// 这个if也是导致快排不稳定的原因：两个相同的数，如果有一个被用来做flag，另一个很可能会被换位置</span></span><br><span class="line">      left.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>(flag, <span class="title function_">quickSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="插入排序（类似于摸扑克牌）"><a href="#插入排序（类似于摸扑克牌）" class="headerlink" title="插入排序（类似于摸扑克牌）"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_32290679/article/details/78619848">插入排序（类似于摸扑克牌）</a></h4><p>从第一个元素开始，该元素认为已经被排序了，取出下一个元素。在已经排序的元素序列中从后向前扫描，如果大于新元素，那么就把这个元素移动到下一个位置。直到找到已排序的元素小于或者等于新元素的位置，将新元素插入下一个位置。依次进行。（其实就是最开头的元素当作是有序数列，后面的元素是无序的，然后从第一个开始往前面插入）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">//插入排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[j];</span><br><span class="line">    i = j - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; arr[i] &gt; key) &#123;</span><br><span class="line">      arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>一种稳定排序方法，将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使序列段间有序。<br>其实也是二分的思想，只不过是在<strong>二分的基础上，先分段，段内再排，然后把每一段拼接起来</strong>。<br>这篇<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/33cffa1ce613">博客</a>里有非常仔细的图片分析。这个需要新申请一个数组来做，所以自然是O(n)的空间复杂度啦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 从上到下递归</span></span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, middle)</span><br><span class="line">  <span class="keyword">let</span> right = arr.<span class="title function_">slice</span>(middle)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span> &amp;&amp; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span>) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (right.<span class="property">length</span>) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>见后面堆数据结构</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一个线性结构，特点是只能在某一端添加或删除数据，遵循先进后出的原则。</p>
<blockquote>
<p>实现：可以把栈看成是数组的一个子集，所以这里使用数组来实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="title function_">getCount</span>() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getCount</span>() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则</p>
<blockquote>
<p>单链队列的实现：用数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enQueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">deQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getHeader</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getLength</span>() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了<strong>循环队列</strong>（也是LeetCode-622题目）。循环队列的出队操作平均是 O(1) 的时间复杂度。循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。<br>可以看视频加深理解，实现代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">k</span>) &#123;</span><br><span class="line">	<span class="comment">//  创建一个长度为k的数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = <span class="title class_">Array</span>(k)</span><br><span class="line">    <span class="comment">//  队头指针</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  队尾指针</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rear</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  队列长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = k</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enQueue</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isFull</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">rear</span>] = num <span class="comment">//  【在尾指针处入队，记得入队之后尾指针要后移一位】</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rear</span> = (<span class="variable language_">this</span>.<span class="property">rear</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">max</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">deQueue</span>(<span class="params"></span>) &#123; <span class="comment">//  【在头指针处入队，然后同样后移头指针】</span></span><br><span class="line">    <span class="keyword">let</span> v = <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> = (<span class="variable language_">this</span>.<span class="property">front</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">max</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123; <span class="comment">// Empty是头指针跟尾指针在同个位置，且这个位置是空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> === <span class="variable language_">this</span>.<span class="property">front</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isFull</span>(<span class="params"></span>) &#123; <span class="comment">// Full是头指针跟尾指针在同个位置，且这个位置不是空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> === <span class="variable language_">this</span>.<span class="property">front</span> &amp;&amp; !!<span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Front</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Rear</span>() &#123; <span class="comment">//  有可能上次入队操作使得尾指针移到了循环的开始位置</span></span><br><span class="line">    <span class="keyword">let</span> rear = <span class="variable language_">this</span>.<span class="property">rear</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[rear &lt; <span class="number">0</span> ? <span class="variable language_">this</span>.<span class="property">max</span> - <span class="number">1</span> : rear]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h4><ul>
<li>链表是链式的存储结构；数组是顺序的存储结构（ 链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储）</li>
<li>链表的插入删除元素相对数组较为简单，不需要移动元素，但是寻找某个元素较为困难；数组寻找某个元素较为简单，但插入与删除比较复杂， 都需要把其他元素向前或者向后</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>链表是一组由节点组成的集合，链表节点（也称数据元素的节点）又包含数据域（存数据）和指针域（指向下一个节点）。链表的尾元素指向一个null节点（为空）。eg. 可以简写为 Head-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</li>
<li>通常在在第一个节点前设置一个节点，称为头节点（不一定是必要元素，当是空表时可以是空）。其数据域可以无意义也可以存放链表长度等信息</li>
<li>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大</li>
</ul>
<h4 id="单向链表的实现"><a href="#单向链表的实现" class="headerlink" title="单向链表的实现"></a>单向链表的实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="comment">// Node类表示节点</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">v, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = v</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NodeList</span> &#123; <span class="comment">// LinkList类表示链表</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dummyNode</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">checkIndex</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Index error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">find</span>(<span class="params">header, index, currentIndex</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(header.<span class="property">next</span>, index, currentIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addNode</span>(<span class="params">v, index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index)</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>)</span><br><span class="line">    pre.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(v, pre.<span class="property">next</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>++</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="property">next</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">v, index</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addNode</span>(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addToFirst</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addNode</span>(v, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addToLast</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(v, <span class="variable language_">this</span>.<span class="property">size</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeNode</span>(<span class="params">index, isLast</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index)</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="variable language_">this</span>.<span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> node = prev.<span class="property">next</span></span><br><span class="line">    prev.<span class="property">next</span> = node.<span class="property">next</span></span><br><span class="line">    node.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>--</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeFirstNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeLastNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="variable language_">this</span>.<span class="property">size</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getNode</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>).<span class="property">next</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断是否是环形链表（LeetCode-141）"><a href="#判断是否是环形链表（LeetCode-141）" class="headerlink" title="判断是否是环形链表（LeetCode-141）"></a>判断是否是环形链表（LeetCode-141）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (head) =&gt; &#123;</span><br><span class="line">  <span class="comment">//  双指针法(快慢)</span></span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">    fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    slow = slow.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (fast === slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）"><a href="#反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）" class="headerlink" title="反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）"></a>反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）</h4><p>注意不要弄混 反转 和 遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">head</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">  <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head</span><br><span class="line">  <span class="comment">// 设置初始为空（因为反转后这里就是尾巴的null）</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> curr = head</span><br><span class="line">  <span class="keyword">let</span> next</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    next = curr.<span class="property">next</span></span><br><span class="line">    curr.<span class="property">next</span> = pre</span><br><span class="line">    pre = curr</span><br><span class="line">    curr = next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre <span class="comment">//  因为反转完成后curr在尾部的null，所以是返回pre</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>在leetCode中一般是用二维数组表示，螺旋矩阵是<strong>面试常考题</strong></p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树的定义：树由一组以边连接的节点组成。一些<strong>概念</strong>：根节点，左子树&#x2F;右子树，子节点&#x2F;父节点，叶子节点（最底部的节点），键值，从xx（节点）到xx的路径，树的层次（根节点是第0层），任何一层的节点都可以看做是子树的根<br>树的高度（从下往上）和深度（从上往下）。根节点的深度为1，叶子节点的高度为1<br>层数：根节点为第一层，往下一次递增</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>一种特殊的树，子节点不超过两个。新增概念：左节点和右节点。</p>
<h4 id="二叉搜索树（查找效率高）"><a href="#二叉搜索树（查找效率高）" class="headerlink" title="二叉搜索树（查找效率高）"></a>二叉搜索树（查找效率高）</h4><p>特殊的二叉树。 每个节点的值都比他的左子树的值大，比右子树的值小。<br>其实已经是一种排序了。 因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小（因为二叉搜索树就是由一堆数字经过函数之后构造的，所以一定满足这个定义）</p>
<h4 id="给定一个数组，创建对应的二叉树和二叉搜索树，见-常见算法题及剑指offer"><a href="#给定一个数组，创建对应的二叉树和二叉搜索树，见-常见算法题及剑指offer" class="headerlink" title="给定一个数组，创建对应的二叉树和二叉搜索树，见 常见算法题及剑指offer"></a>给定一个数组，创建对应的二叉树和二叉搜索树，见 <a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/10/21/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E5%8F%8A%E5%89%91%E6%8C%87offer/">常见算法题及剑指offer</a></h4><h4 id="二叉搜索树的实现及其他操作"><a href="#二叉搜索树的实现及其他操作" class="headerlink" title="二叉搜索树的实现及其他操作"></a>二叉搜索树的实现及其他操作</h4><ul>
<li>二叉搜索树的实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addNode</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  <span class="title function_">_addChild</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">      node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">left</span>, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">      node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">right</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">树的遍历</a><blockquote>
<p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">breadthTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> q = []</span><br><span class="line">    <span class="comment">// 将根节点入队</span></span><br><span class="line">    q.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">    <span class="comment">// 循环判断队列是否为空，为空代表树遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">      <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">      <span class="keyword">let</span> n = q.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">value</span>)</span><br><span class="line">      <span class="keyword">if</span> (n.<span class="property">left</span>) q.<span class="title function_">push</span>(n.<span class="property">left</span>)</span><br><span class="line">      <span class="keyword">if</span> (n.<span class="property">right</span>) q.<span class="title function_">push</span>(n.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getMin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(<span class="variable language_">this</span>.<span class="property">root</span>).<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_getMin</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.<span class="property">left</span>) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">left</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getMax</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMax</span>(<span class="variable language_">this</span>.<span class="property">root</span>).<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_getMax</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.<span class="property">right</span>) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最复杂的部分：删除节点。因为有三种情况：要删除的节点没有子树；有一条子树；两条子树<ul>
<li>简单的情况：删除最小&#x2F;最大的节点，下面以删除最小节点为例。对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">deleteMin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_deleteMin</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_deleteMin</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="comment">//  一直递归找到最小节点</span></span><br><span class="line">  <span class="comment">//  找到的时候判断时候有右节点，有的话就return右节点把原来的节点给重写了</span></span><br><span class="line">  <span class="comment">//  没有右节点，也return右节点（null）重写原来节点，相当于删除了</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp;&amp; !node.<span class="property">left</span>) <span class="keyword">return</span> node.<span class="property">right</span></span><br><span class="line">  node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_deleteMin</span>(<span class="variable language_">this</span>.<span class="property">left</span>)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.<span class="property">size</span> = <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">left</span>) + <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">right</span>) + <span class="number">1</span></span><br><span class="line">  <span class="comment">//  返回根节点</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除任意节点。思路：取出被删除节点右子树中最小的节点来替换被传出的节点。<br>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">delect</span>(<span class="params">v</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_delect</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(node.<span class="property">right</span>, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(node.<span class="property">left</span>, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">left</span>) <span class="keyword">return</span> node.<span class="property">right</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">right</span>) <span class="keyword">return</span> node.<span class="property">left</span></span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_delectMin</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.<span class="property">left</span> = node.<span class="property">left</span></span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.<span class="property">size</span> = <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">left</span>) + <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">right</span>) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>堆通常是一个可以被看做一棵树的数组对象（有索引），堆可以理解为有特殊特征的二叉树：必须是完全二叉树（n-1层必须是满二叉树），即除了最底层，其他层的节点都被元素填满；任一节点的值是其子树所有节点的最大值或最小值（称为最大堆&#x2F;最小堆）<br><img src="/img/%E7%AE%97%E6%B3%95/%E5%A0%86.png"></li>
<li>对任一索引为i的节点，其左子节点索引为 <code>2*i + 1</code>，右子节点为<code>2*i + 2</code>，父节点为<code>(i-1) / 2</code></li>
<li>构建最大堆。即把一个普通的二叉树排序好变成一个最大堆。将节点与父节点对比大小，如果比父节点大，就和父节点交换位置（maxHeapify）；遍历所有节点进行该操作之后就能构建一个最大堆。<strong>构建一次最大堆能选出一个最大值</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123; <span class="comment">//  data应该是一个数组（保存未排序的二叉树）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sort</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> iArr = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    <span class="keyword">let</span> n = iArr.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> iArr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 构建最大堆从最后一个父节点开始循环</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(iArr, i, n)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//  不断构建最大堆的过程</span></span><br><span class="line">        <span class="comment">//  因为每次构建都会扔掉一个，所以是n-1-j</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">swap</span>(iArr, <span class="number">0</span>, n - <span class="number">1</span> - j) </span><br><span class="line">        <span class="comment">//  每次交换位置扔完之后应该是从顶点开始，所以第二个参数是0</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(iArr, <span class="number">0</span>, n - <span class="number">1</span> - j - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> iArr</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交换两个元素</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">swap</span>(<span class="params">arr, a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> c = arr[a]</span><br><span class="line">    arr[a] = arr[b]</span><br><span class="line">    arr[b] = c</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建最大堆的过程</span></span><br><span class="line">  <span class="comment">// 堆排序的时候需要把原来的根节点与最右的叶子节点互换位置后扔出数组，这里不是真的扔出去，而是引入了size，对索引大于size的item忽略不操作。</span></span><br><span class="line">  <span class="comment">//  所以整个构建最大堆的过程数组的长度不会变</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">maxHeapify</span>(<span class="params">Arr, i, size</span>) &#123;</span><br><span class="line">    <span class="comment">// i的左节点（索引），这是堆的固有规律</span></span><br><span class="line">    <span class="keyword">let</span> l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="comment">// i的右节点</span></span><br><span class="line">    <span class="keyword">let</span> r = i * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> largest = i</span><br><span class="line">    <span class="comment">// 父节点i和左节点l做比较取最大（此时只是比较并用largest变量保存最大的，并没有真正在数组中交换）</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= size &amp;&amp; <span class="title class_">Arr</span>[l] &gt; <span class="title class_">Arr</span>[largest]) &#123;</span><br><span class="line">      largest = l</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父节点i和右节点r做比较取最大（此时只是比较并用largest变量保存最大的，并没有真正在数组中交换）</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt;= size &amp;&amp; <span class="title class_">Arr</span>[r] &gt; <span class="title class_">Arr</span>[largest]) &#123;</span><br><span class="line">      largest = r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在数组中交换</span></span><br><span class="line">    <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">      <span class="title class_">Heap</span>.<span class="title function_">swap</span>(<span class="title class_">Arr</span>, i, largest)</span><br><span class="line">      <span class="comment">// 交换完之后确保子树也是满足最大堆的条件</span></span><br><span class="line">      <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(<span class="title class_">Arr</span>, largest, size)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆排序。在一次构建最大堆结束之后，把根节点与最右的叶子节<strong>互换位置</strong>（swap），然后移除现在这个叶子节点（原来的根节点）。再构建一次最大堆，<strong>即找到了第二大的值</strong> … 直到最后只剩下一个节点，就完成了堆排序。</li>
<li><em>堆查找</em>。见例题超级丑数。题意有点绕</li>
</ul>
<p>堆和堆栈的概念区别</p>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>贪心算法（又称贪婪算法，其实是一种思想）是指，在对问题求解时，总是做出在当<strong>前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>借助10级台阶有多少种走法（每次只能走一步或两步）的例子来理解。下面是重要概念：</p>
<ul>
<li>状态转移方程。F(10) &#x3D; F(9) + F(8)</li>
<li>最优子结构。F(10) &#x3D; F(9) + F(8)。称F(9)和F(8)是F(10)的最优子结构</li>
<li>边界。往前推导的时候，会发现到F(1)和F(2)的之后就无法继续推导了，称这两者是问题的边界</li>
</ul>
<p>总结：动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决<br><strong>解法</strong>：先观察题目写出状态转移方程，再判断问题的边界。特别<strong>善于解决不同路径和最短路径的问题</strong><br><strong>具体写法</strong>：构建数组(n+1) &#x2F; 矩阵，填满已知部分（边界）（填满的过程也可以用for循环 (n+1) ），然后for循环设定好状态转移方程，最后return结构。用这种做法更好，<strong>递归容易超时？</strong><br>见leetcode-62<br>自己的感想：<strong>见两道例题</strong></p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a><br>《数据结构与算法JS描述》<br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/315.html">慕课网</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" data-id="clmniym82004jbb87hvo76ohd" data-title="数据结构与算法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/21/%E9%83%A8%E5%88%86%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          部分刷题记录
        
      </div>
    </a>
  
  
    <a href="/2019/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">操作系统</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>