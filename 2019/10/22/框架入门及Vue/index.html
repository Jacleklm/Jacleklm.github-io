<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>框架入门及Vue | Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="框架入门及 VueMVC、MVP 与 MVVMMVCM（Model）：数据保存V（View）：用户页面C（Controller）：业务逻辑所有通信都是单向的。  View 传指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈  MVP传统前端开发过程使用的 MVP 设计模式（eg.jQuery）。Mo">
<meta property="og:type" content="article">
<meta property="og:title" content="框架入门及Vue">
<meta property="og:url" content="http://example.com/2019/10/22/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%8F%8AVue/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="框架入门及 VueMVC、MVP 与 MVVMMVCM（Model）：数据保存V（View）：用户页面C（Controller）：业务逻辑所有通信都是单向的。  View 传指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈  MVP传统前端开发过程使用的 MVP 设计模式（eg.jQuery）。Mo">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/MVP.png">
<meta property="og:image" content="http://example.com/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/MVVM.png">
<meta property="og:image" content="http://example.com/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/Vuex.png">
<meta property="article:published_time" content="2019-10-22T15:50:21.000Z">
<meta property="article:modified_time" content="2023-09-17T14:00:22.882Z">
<meta property="article:author" content="Jacleklm">
<meta property="article:tag" content="框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/MVP.png">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-框架入门及Vue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/22/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%8F%8AVue/" class="article-date">
  <time class="dt-published" datetime="2019-10-22T15:50:21.000Z" itemprop="datePublished">2019-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      框架入门及Vue
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="框架入门及-Vue"><a href="#框架入门及-Vue" class="headerlink" title="框架入门及 Vue"></a>框架入门及 Vue</h1><h2 id="MVC、MVP-与-MVVM"><a href="#MVC、MVP-与-MVVM" class="headerlink" title="MVC、MVP 与 MVVM"></a>MVC、MVP 与 MVVM</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>M（Model）：数据保存<br>V（View）：用户页面<br>C（Controller）：业务逻辑<br>所有通信都是单向的。</p>
<ol>
<li>View 传指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><img src="/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/MVP.png"><br>传统前端开发过程使用的 MVP 设计模式（eg.jQuery）。Model 数据层，View 视图层（DOM 式，负责绘制 UI 元素、与用户进行交互），Presenter 呈现层（处理与用户交互的逻辑）。</p>
<ol>
<li>各部分之间的通信是双向的，View 与 Model 不发生联系，都通过 Presenter 传递，所以 P 是 MVP 模式的核心，P 里的业务逻辑是 M 和 V 之间的中转站。</li>
<li>在 MVP 设计模式中，M 层很远；在编写代码的时候其实都在写 P，而 P 中的代码大部分都是在操作 DOM。写大型项目的时候，其实 P 层中百分之七八十的代码都是在操作 DOM</li>
</ol>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><img src="/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/MVVM.png"><br>P 层变成了 VM 层，并且 VM 层不需要我们去编写（是 Vue 自带的）</p>
<ol>
<li>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上（VM 层一方面会监听数据的变化来改变视图，另一方面会监听 V 层的事件触发，然后帮我们调用我们写的逻辑代码来改变 M 层的数据）。用 MVVM 开发的时候，最重的一层其实是 M 层。所以可以这么理解，用 jQuery 开发的时候我们是面向 DOM 进行编程，而用 Vue 是面对数据进行开发，这样在编写大型项目的时候能节省很多代码。</li>
<li>ViewModel 通过<strong>双向数据绑定</strong>把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</li>
<li>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，<strong>而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</strong></li>
</ol>
<h2 id="多页面应用-and-单页面应用"><a href="#多页面应用-and-单页面应用" class="headerlink" title="多页面应用 and 单页面应用"></a>多页面应用 and 单页面应用</h2><ul>
<li>多页面应用：每一次页面跳转的时候，后台的服务器（后端）都会返回一个新的 html 文档。只经过一个 http 请求，速度快；搜索引擎排名效果好。但是每次切换页面都需要一次 http 请求，所以切换速度慢。</li>
<li>单页面应用：在 Vue 项目中， 实现页面跳转不用<code>&lt;a&gt;</code>，而是<code>&lt;router-link to=xxx&gt;</code>，页面跳转是通过 JS 感知 url 的变化，来先清除页面的组件，再渲染新组件实现的。SEO 只识别 html 的内容，所以 SEO 效果会比较差。但是仍有其他方法解决些缺点</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li>Vue 实例、模板（在项目中的 App.vue 是一个 Vue 实例，其他的页面和组件其实是模板。Vue 实例的属性可用 $+属性名 加以区分）</li>
<li>Vue 实例的数据用 data 属性保存，在 template 中可用插值表达式插入；时间用 v-on；方法用 method 属性保存</li>
<li>template 内不要放逻辑，可用计算属性 computed 代替；侦听某一个数据的变化并对此作出反应用侦听器 watch</li>
<li>v-if，v-show 用于数据的显示；v-for 用于数据做循环展示</li>
<li>样式绑定 v-bind（有多种语法，eg. 数组语法，对象语法）</li>
</ol>
<h3 id="watch-的用法"><a href="#watch-的用法" class="headerlink" title="watch 的用法"></a>watch 的用法</h3><h4 id="监听多个变量"><a href="#监听多个变量" class="headerlink" title="监听多个变量"></a>监听多个变量</h4><p>监听单个字符串或数字变量的话就直接写就可以了，如果是监听多个，要结合计算属性，把要监听的多个变量封装成一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// realName 和 idCard 是data中的两个变量</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">submitElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;realName, idCard&#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      realName,</span><br><span class="line">      idCard</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">submitElement</span>: &#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val.<span class="property">realName</span>.<span class="title function_">trim</span>().<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">idCard</span>.<span class="title function_">trim</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isSubmit</span> = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isSubmit</span> = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="监听对象"><a href="#监听对象" class="headerlink" title="监听对象"></a>监听对象</h4><p>监听变量是字符串或数字的话就直接写就可以了，如果监听的是对象，要 计算属性 + 用 deep: true 实现对对象内部属性的监听，也见深度监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">  <span class="attr">childrens</span>:&#123;</span><br><span class="line">    <span class="attr">handler</span>:<span class="keyword">function</span>(<span class="params">val,oldval</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deep</span>:<span class="literal">true</span><span class="comment">//对象内部的属性监听，也叫深度监听</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;childrens.name&#x27;</span>:<span class="keyword">function</span>(<span class="params">val,oldval</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val+<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  &#125;,<span class="comment">//键路径必须加上引号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="watch-和-updated-的区别"><a href="#watch-和-updated-的区别" class="headerlink" title="watch 和 updated 的区别"></a>watch 和 updated 的区别</h4><ul>
<li>updated 是数据发生变化且界面更新完毕执行；不能监听路由数据；<strong>所有数据</strong>发生变化都会调用（耗费性能）</li>
<li>【网易雷火】所以想实现监听一个变量的变化并在这个变量变化导致的页面更新后做一些事情，只用 updated 是不够的。所以怎么实现到现在我仍旧不知道</li>
</ul>
<h3 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h3><p>Vue 实例从创建到销毁的过程，就是生命周期（有创建、初始化数据、挂载 Dom、渲染、更新销毁等一系列过程）。分为 8 个阶段：创建前&#x2F;后、载入前&#x2F;后、更新前&#x2F;后、销毁前&#x2F;销毁后。</p>
<ul>
<li>在 beforeCreate 阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。在 created 阶段，vue 实例的数据对象 data 有了，el 还没有</li>
<li>在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功<strong>渲染</strong>。</li>
<li>beforeUpdate：数据发生改变页面还没被重新渲染之前</li>
<li>销毁前&#x2F;后：执行 destory()</li>
</ul>
<p>它的生命周期有多个生命周期钩子，即是某一个时间点会自动执行的函数，借用这些钩子我们能在 Vue 实例的生命周期中写一些逻辑完善我们的需求</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p>子组件 export default 中写 name 属性；父组件用 import 并写 components 属性即可引用</p>
<h4 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h4><ul>
<li>父子组件间的传值<ul>
<li>父传给子：父绑定属性的方式传给子，子用 props 方法接收</li>
<li>子传给父：$emit 来传递自定义事件和参数，父通过监听这个自定义的事件接收</li>
</ul>
</li>
<li>非父子组件间的传值(兄弟组件传值)<ul>
<li>小型项目用 enentBus（发布订阅模式），就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。在 Vue.prototype.bus&#x3D;new Vue()。 在 Vue 的原型加一个 bus 属性，指向一个 Vue 实例。这样 Vue 实例都会有这个 bus 属性，而且指向的都是同一个实例。然后在一个组件的 bus 去$emit(), 另一个组件的 bus 的去 on 监听事件</li>
<li>大型项目用 Vuex</li>
</ul>
</li>
</ul>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p><strong>使用场景</strong>：<strong>父组件向子组件传递 DOM</strong>，可用插槽。即是在<strong>父组件中</strong>用某个子组件标签，标签之间就可以写插槽，可以写<strong>任何</strong>模板代码（可以是一点 html 代码，甚至可以引用另外一个组件）。然后在<strong>子组件中</strong>这部分内容就用<code>&lt;slot&gt;</code>代替</p>
<p><strong>具名插槽</strong>：父组件中写一个 slot 属性。子组件写成<code>&lt;slot name = &#39;该属性&#39;&gt;</code> 即可。就能实现传递多个插槽<br><strong>作用域插槽</strong>：子组件 v-for 一个<code>&lt;slot&gt;</code>，则这个插槽必须是作用域插槽。在父组件写法会有不同</p>
<h3 id="Vue-中操作-DOM"><a href="#Vue-中操作-DOM" class="headerlink" title="Vue 中操作 DOM"></a>Vue 中操作 DOM</h3><p>先在 DOM 元素节点&#x2F;组件上加 ref 属性和属性值，然后 Vue 实例中用 vm.$refs.属性值 就能引用这个 DOM 节点。</p>
<h3 id="Vue-中的动画"><a href="#Vue-中的动画" class="headerlink" title="Vue 中的动画"></a>Vue 中的动画</h3><p><strong>不太熟练</strong></p>
<h4 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h4><ul>
<li>transition</li>
<li>animation<ul>
<li>自定义</li>
<li>用 Animate.css 库。ink src 引入 css 库，在<tiansition>中写 enter-active-class&#x3D;类名，类名开头必须是 animated，然后再写具体哪个动画</li>
</ul>
</li>
</ul>
<h4 id="JS-动画：用-Velocity-js"><a href="#JS-动画：用-Velocity-js" class="headerlink" title="JS 动画：用 Velocity.js"></a>JS 动画：用 Velocity.js</h4><h2 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h2><p>在真实的 Vue 项目开发过程中，我们会借助 webpack 构建大型项目的开发目录，然后在开发完成之后进行打包，把代码打包生成一个线上可运行的最终代码。每个开发人员自己去配置 webpack 的开发环境是挺难的，所以有 Vue-cli 脚手架工具，用来快速构建 Vue 项目，这个脚手架自带了 webpack 的配置</p>
<h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><p>路由就是根据网址的不同，返回不同组件给用户。组件中的<code>&lt;router-view&gt;</code>显示的是当前路由地址所对应的内容。在 router&#x2F;index.js 中定义当用户访问某个路径 path 时候，给用户展示某个组件</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在 router&#x2F;index.js 中定义当用户访问某个路径 path 时候，给用户展示某个组件<br>在组件中用标签<code>&lt;router-link to=&quot;/&quot; tag=&quot;div&quot;&gt;</code></p>
<h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">动态路由匹配</a></h3><p>例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果。 把配置文件中的 path 写成<code>path: &#39;/user/:id&#39; // 动态路径参数 以冒号开头</code></p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/essentials/navigation.html">编程式导航</a></h3><p>页面跳转还可以用编程式导航。在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push(location, onComplete?, onAbort?)</p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>通过 name 来标识一个路由，而不是路径。在 index.js 配置中加 name 属性后，可用传对象访问<code>&lt;router-link ：to=&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot; tag=&quot;div&quot;&gt;</code></p>
<h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p>“重定向”的意思是，当用户访问 &#x2F;a 时，URL 将会被替换成 &#x2F;b，然后匹配路由为 &#x2F;b，在配置中加 redirect 属性即可<br>“别名”的意思是， &#x2F;a 的别名是 &#x2F;b，意味着，当用户访问 &#x2F;b 时，URL 会保持为 &#x2F;b，但是路由匹配则为 &#x2F;a，就像用户访问 &#x2F;a 一样。加 alias 属性即可</p>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">路由懒加载</a></h3><p>在组件中引用组件的时候，如果子组件很多，我们可以用懒加载实现按需加载。<br>在引用组件的时候写成<code>const Foo = () =&gt; import(&#39;./Foo.vue&#39;)</code>，router 的配置文件不用改</p>
<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">导航守卫</a></h3><p>导航守卫主要用来通过跳转或取消的方式守卫导航，其实是<strong>vue 路由的钩子函数</strong>，是写在 router 的配置文件中<br>首页可以控制导航跳转，beforeEach，afterEach 等，一般用于页面 title 的修改。一些需要登录才能调整页面的重定向功能。</p>
<ul>
<li>beforeEach 主要有 3 个参数 to，from，next。</li>
<li>to：route 即将进入的目标路由对象。</li>
<li>from：route 当前导航正要离开的路由。</li>
<li>next：function 一定要调用该方法 resolve 这个钩子。执行效果依赖 next 方法的调用参数。可以控制网页的跳转</li>
</ul>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>在<code>&lt;router-view&gt;</code>外包裹<code>&lt;keep-alive&gt;</code>，能实现路由的内容（几个组件）被加载过一次之后，就把路由中的内容放在内存之中，下次再进路由的时候不需要重新渲染组件，在内存中并显示就可以。<br>此外该标签可以加个 exclude&#x3D;”Detail”，就是进入 Detail 组件的时候 kepp-alive 不会生效</p>
<h2 id="Vuex（看到官方文档项目结构结束就差不多了）"><a href="#Vuex（看到官方文档项目结构结束就差不多了）" class="headerlink" title="Vuex（看到官方文档项目结构结束就差不多了）"></a><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/">Vuex</a>（看到官方文档项目结构结束就差不多了）</h2><p>Vuex 是 Vue 官方推荐的数据框架，能用于不同组件间的数据共享（一般用来非父子组件的数据共享）<br>可以理解为储存公用数据的仓库（store），各个组件都能一起共享数据。<br><img src="/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/Vuex.png"></p>
<ul>
<li>actioin 是放异步操作</li>
<li>mutations 是放同步的对数据的改变</li>
<li>state 是驱动应用的数据源</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在&#x2F;src 目录下新建 store&#x2F;index.js（可以继续新建 mutations.js, state.js 导入 index.js 中），在 src&#x2F;main.js import 这个文件<br>此时在组件中可以不用绑定属性不用 props 了，直接用 Vuex 的 mapState，mapMutations 等简化写法<br>可以结合 localStorage 保存一些数据</p>
<ul>
<li>store.Vuex 使用单一状态树,即每个应用将仅仅包含一个 store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</li>
<li>mutations 定义的方法动态修改 Vuex 的 store 中的状态或数据</li>
<li>actions 可以理解为通过将 mutations 里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</li>
<li>getter.类似 vue 的计算属性，主要用来过滤一些数据</li>
<li>module.项目特别复杂的时候，可以让每一个模块拥有自己的 state、mutation、action、getters，使得结构非常清晰，方便管理</li>
</ul>
<h2 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h2><ul>
<li>static 目录建立 mock 文件夹（因为在整个工程里，只有 static 目录能被外部访问）</li>
<li>proxy 转发。让对 api&#x2F;xx.json 的请求转到 mock&#x2F;xx.json</li>
<li>Vue 是推荐用<strong>axios</strong>第三方模块来获取 Ajax 数据，安装之后就可以用 axios.get()方法（其实类似于 fetch）。写好方法后让方法在 mounted 的时候执行</li>
</ul>
<h1 id="一些功能的原理"><a href="#一些功能的原理" class="headerlink" title="一些功能的原理"></a>一些功能的原理</h1><h2 id="Vue-实现数据双向绑定的原理：Object-defineProperty"><a href="#Vue-实现数据双向绑定的原理：Object-defineProperty" class="headerlink" title="Vue 实现数据双向绑定的原理：Object.defineProperty()"></a>Vue 实现数据双向绑定的原理：Object.defineProperty()</h2><ul>
<li>vue 实现数据双向绑定主要是：采用数据劫持结合观察者模式的方式。Vue 会遍历数据对象的属性，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调</li>
<li>vue 的数据双向绑定 将 MVVM 作为数据绑定的入口，整合 Observer，Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，通过 Compile 来解析编译模板指令（vue 中是用来解析 插值表达式），最终利用 watcher 搭起 observer 和 Compile 之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据 model 变更双向绑定效果</li>
</ul>
<h3 id="手写实现双向数据绑定"><a href="#手写实现双向数据绑定" class="headerlink" title="手写实现双向数据绑定"></a>手写实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向数据绑定</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据劫持</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新&#x27;</span>)</span><br><span class="line">    input.<span class="property">value</span> = newVal <span class="comment">// 要双向绑定所以有这句</span></span><br><span class="line">    span.<span class="property">innerHTML</span> = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  obj.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>监听不到对象属性的增删、数组元素和长度的变化</li>
<li>同时会在 vue 初始化的时候把所有的观察者都建立好，才能观察到数据对象属性的变化</li>
</ul>
<h3 id="Vue3-0-的改进"><a href="#Vue3-0-的改进" class="headerlink" title="Vue3.0 的改进"></a>Vue3.0 的改进</h3><ul>
<li>采用了 ES2015 的 Proxy 来代替 Object.defineProperty，</li>
<li>可以做到监听对象属性的增删和数组元素和长度的修改，还可以监听 Map、Set、WeakSet、WeakMap，</li>
<li>同时还实现了惰性的监听，不会在初始化的时候创建所有的 Observer，而是会在用到的时候才去监听。</li>
<li>但是，虽然主流的浏览器都支持 Proxy，ie 系列却还是不兼容，所以对 ie 还是 Object.defineProperty()</li>
</ul>
<h2 id="v-for-的原理"><a href="#v-for-的原理" class="headerlink" title="v-for 的原理"></a>v-for 的原理</h2><h2 id="computed-的原理"><a href="#computed-的原理" class="headerlink" title="computed 的原理"></a>computed 的原理</h2><ul>
<li>初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。</li>
<li>初始化 computed, 遍历 computed 里的每个属性，<strong>每个 computed 属性都是一个 watch 实例</strong>。每个属性提供的函数作为属性的 - getter，使用 Object.defineProperty 转化。</li>
<li>Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。</li>
<li>若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集</li>
</ul>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><h3 id="v-if-与-v-show-的区别"><a href="#v-if-与-v-show-的区别" class="headerlink" title="v-if 与 v-show 的区别"></a>v-if 与 v-show 的区别</h3><p>v-if 按照条件是否渲染，v-show 是 display 的 block 或 none；</p>
<h3 id="v-el-作用"><a href="#v-el-作用" class="headerlink" title="v-el 作用"></a>v-el 作用</h3><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p>
<h3 id="vue-的优点是什么？"><a href="#vue-的优点是什么？" class="headerlink" title="vue 的优点是什么？"></a>vue 的优点是什么？</h3><ul>
<li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变</li>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写</li>
</ul>
<h3 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h3><p>每个组件都是 Vue 的实例。组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他</p>
<h3 id="为什么官方建议数据异步请求在-mounted-事件进行"><a href="#为什么官方建议数据异步请求在-mounted-事件进行" class="headerlink" title="为什么官方建议数据异步请求在 mounted 事件进行"></a>为什么官方建议数据异步请求在 mounted 事件进行</h3><p>请求是需要时间的，而且这个时间具有不稳定性，很可能 vue 的虚拟 DOM 准备好了，你的数据才请求到，然后又得更新一遍虚拟 DOM，再渲染，极大地延长了白屏时间，用户体验很不好。而在 mounted 事件请求数据呢，静态页面会先渲染好，等数据好了，再更新部分 DOM 即可</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a><br>Vue，Vue-cli，Vue-router，Vuex 的官方文档</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/22/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%8F%8AVue/" data-id="clmniym81004gbb87gzfg5ugu" data-title="框架入门及Vue" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/23/Web%20Component/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Web Component
        
      </div>
    </a>
  
  
    <a href="/2019/10/21/%E9%83%A8%E5%88%86%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">部分刷题记录</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>