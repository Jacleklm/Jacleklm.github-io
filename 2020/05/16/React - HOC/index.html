<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>React - HOC | Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="本文大部分来自ConardLi 的 blog，建议直接看原博客 概述Mixin 的危害React 官方文档在Mixins Considered Harmful一文中提到了 Mixin 带来了危害：  Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的 Mixin 中的方法可能会相互冲突 Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性">
<meta property="og:type" content="article">
<meta property="og:title" content="React - HOC">
<meta property="og:url" content="http://example.com/2020/05/16/React%20-%20HOC/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="本文大部分来自ConardLi 的 blog，建议直接看原博客 概述Mixin 的危害React 官方文档在Mixins Considered Harmful一文中提到了 Mixin 带来了危害：  Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的 Mixin 中的方法可能会相互冲突 Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/React-HOC/connect.png">
<meta property="article:published_time" content="2020-05-16T08:50:21.000Z">
<meta property="article:modified_time" content="2023-09-17T14:00:22.868Z">
<meta property="article:author" content="Jacleklm">
<meta property="article:tag" content="框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/React-HOC/connect.png">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-React - HOC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/16/React%20-%20HOC/" class="article-date">
  <time class="dt-published" datetime="2020-05-16T08:50:21.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      React - HOC
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文大部分来自<a target="_blank" rel="noopener" href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a>，建议直接看原博客</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Mixin-的危害"><a href="#Mixin-的危害" class="headerlink" title="Mixin 的危害"></a>Mixin 的危害</h2><p>React 官方文档在<a target="_blank" rel="noopener" href="https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html">Mixins Considered Harmful</a>一文中提到了 Mixin 带来了危害：</p>
<ul>
<li>Mixin 可能会相互依赖，相互耦合，不利于代码维护</li>
<li>不同的 Mixin 中的方法可能会相互冲突</li>
<li>Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li>
</ul>
<p>React 现在已经不再推荐使用 Mixin 来解决<strong>代码复用</strong>问题，因为 Mixin 带来的危害比他产生的价值还要巨大，并且 React 全面推荐使用高阶组件来替代它</p>
<h2 id="HOC-简介"><a href="#HOC-简介" class="headerlink" title="HOC 简介"></a>HOC 简介</h2><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/higher-order-components.html">HOC-官方文档</a><br>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身<strong>不是 React API 的一部分</strong>，它是一种基于 React 的组合特性而形成的<strong>设计模式</strong></p>
<p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。实现在原有组件的基础上对其新增功能和行为</p>
<h1 id="HOC-的实现方式"><a href="#HOC-的实现方式" class="headerlink" title="HOC 的实现方式"></a>HOC 的实现方式</h1><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><p>常用方式，一般是在 render() 返回被包裹的组件，并把需要的 props 传递给它</p>
<h3 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">visibleHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; visible, ...restProps &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><p>假设有一个组件要在 localStorage 拿数据，然后渲染出来，它的代码应该差不多长这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有很多其他组件也需要从 LocalStorage 中获取同样的数据展示出来时，那我要写很多次这段代码，为了效率我决定写用装饰器模式包装一下，所以就有了高阶组件（高阶组件本质是函数，所以这里写成函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">localHOC</span>(<span class="params">InnerComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 通过&#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的 props</li>
<li>可操作组件的生命周期</li>
<li>可操作组件的 static 方法</li>
<li>获取 refs</li>
</ul>
<h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><p>返回一个组件，继承原组件，在 render 中用 super.render() 调用原组件的 render。由于继承了原组件，能通过 this 访问到原组件的生命周期、props、state、render 等，相比属性代理它能操作更多的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritHOC</span>(<span class="params">InnerComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">InnerComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的 props</li>
<li>可操作组件的生命周期</li>
<li>可操作组件的 static 方法</li>
<li>获取 refs</li>
<li>可操作 state</li>
<li>可以渲染劫持</li>
</ul>
<h1 id="HOC-可以实现什么功能"><a href="#HOC-可以实现什么功能" class="headerlink" title="HOC 可以实现什么功能"></a>HOC 可以实现什么功能</h1><h2 id="组合渲染（常用）"><a href="#组合渲染（常用）" class="headerlink" title="组合渲染（常用）"></a>组合渲染（常用）</h2><p>可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果</p>
<p>eg. 一个在外层给组件包裹 Antd 的 Card 的 HOC。这里用了函数组件的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Card</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CardHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title = <span class="literal">null</span>, ...restProps &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Card</span> <span class="attr">title</span>=<span class="string">&#123;title&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过反向继承再实现一次。这里是 class 组件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">CardHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">InnerComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Card</span> <span class="attr">title</span>=<span class="string">&#123;this.props.title&#125;</span>&gt;</span>&#123;super.render()&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件渲染（常用）"><a href="#条件渲染（常用）" class="headerlink" title="条件渲染（常用）"></a>条件渲染（常用）</h2><p>根据特定的属性决定原组件是否渲染。第一个 DEMO 就是这个</p>
<h2 id="操作-props"><a href="#操作-props" class="headerlink" title="操作 props"></a>操作 props</h2><p>可以对传入组件的 props 进行增加、修改、删除或者根据特定的 props 进行特殊的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">propsHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">user_name</span>: <span class="string">&#x27;Jacle&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取-ref"><a href="#获取-ref" class="headerlink" title="获取 ref"></a>获取 ref</h2><p>高阶组件中可获取原组件的<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/refs-and-the-dom.html">ref</a>，通过 ref 获取组件实例，如下面的代码，当程序初始化完成后调用原组件的 log 方法 （默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例）。适合用 ref 的情况：管理 input 的 focus；触发强制动画；…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">refHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wapperRef</span>.<span class="title function_">log</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;(ref)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            this.wapperRef = ref</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意：调用高阶组件的时候并不能获取到原组件的真实 ref，需要手动进行传递。详见<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/forwarding-refs.html">refs 转发</a></p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>将原组件的状态提取到 HOC 中进行管理，如下面的代码，我们将 Input 的 value 提取到 HOC 中进行管理，使它变成受控组件，同时不影响它使用 onChange 方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHoc</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(props)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onChange &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onChange === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">onChange</span>(event)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">onChange</span>: <span class="variable language_">this</span>.<span class="property">onChange</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOC</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">proxyHoc</span>(<span class="variable constant_">HOC</span>)</span><br></pre></td></tr></table></figure>

<h2 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h2><p>上面的例子通过属性代理利用 HOC 的 state 对原组件进行了一定的增强，但并不能直接控制原组件的 state，而通过<strong>反向继承</strong>，我们可以直接操作原组件的 state。但是并<strong>不推荐直接修改或添加原组件的 state</strong>，因为这样有可能和组件内部的操作构成冲突</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debugHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props&#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;debuging&quot;</span>&gt;</span>&#123;super.render()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h2><p>通过反向继承的方式，可直接增强（而不是更改）由原组件 render 函数产生的 React 元素，eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hijackHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> tree = <span class="variable language_">super</span>.<span class="title function_">render</span>() <span class="comment">// render函数内实际上是调用React.creatElement产生的React元素。它所有属性的writable特性均被配置为了false，即所有属性是不可变的。所以我们只能重新创造一个元素，用React.cloneElement()</span></span><br><span class="line">      <span class="keyword">let</span> newProps = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (tree &amp;&amp; tree.<span class="property">type</span> === <span class="string">&#x27;input&#x27;</span>) &#123;</span><br><span class="line">        newProps = &#123; <span class="attr">value</span>: <span class="string">&#x27;渲染被劫持了&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, tree.<span class="property">props</span>, newProps)</span><br><span class="line">      <span class="keyword">const</span> newTree = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(tree, props, tree.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">      <span class="keyword">return</span> newTree</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>React.cloneElement()克隆并返回一个新的 React 元素，使用 element 作为起点。生成的元素将会拥有原始元素 props 与新 props 的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。</p>
</blockquote>
<h1 id="HOC-的优雅写法"><a href="#HOC-的优雅写法" class="headerlink" title="HOC 的优雅写法"></a>HOC 的优雅写法</h1><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>在实际应用中，一个组件可能被多个 HOC 增强，我们使用的是被所有的 HOC 增强后的组件。直接写的话代码可读性会很差：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newComponent = <span class="title function_">aHOC</span>(<span class="title function_">bHOC</span>(<span class="title function_">cHOC</span>(<span class="title class_">InnerComponent</span>)))</span><br></pre></td></tr></table></figure>

<p>我们可以用类似柯里化的方式，手动封装一个简单的函数组合工具，将写法改写如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...fns</span>) =&gt; fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">g</span>(<span class="title function_">f</span>(...args)))</span><br><span class="line"><span class="title function_">compose</span>(aHOC, bHOC, cHOC)(<span class="title class_">InnerComponent</span>)</span><br></pre></td></tr></table></figure>

<h2 id="ES7-的-Decorators"><a href="#ES7-的-Decorators" class="headerlink" title="ES7 的 Decorators"></a>ES7 的 Decorators</h2><p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/decorator">ES7-Decorators</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@aHOC</span><br><span class="line">@bHOC</span><br><span class="line">@cHOC</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这个InnerComponent等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;&#125;</span><br><span class="line"><span class="title class_">InnerComponent</span> = <span class="title function_">aHOC</span>(<span class="title class_">InnerComponent</span>) || <span class="title class_">InnerComponent</span></span><br></pre></td></tr></table></figure>

<p>Decorators 是 ES7 的一个提案，还没有被标准化，但目前 Babel 转码器已经支持，我们需要提前配置 babel-plugin-transform-decorators-legacy：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;transform-decorators-legacy&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>还可以结合上面的 compose 函数使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hoc = <span class="title function_">compose</span>(aHOC, bHOC, cHOC)</span><br><span class="line">@hoc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-HOC-的注意事项"><a href="#使用-HOC-的注意事项" class="headerlink" title="使用 HOC 的注意事项"></a>使用 HOC 的注意事项</h1><ul>
<li>静态属性拷贝<br>当我们应用 HOC 去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在 HOC 的结尾手动拷贝他们：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HOCComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">HOCComponent</span>.<span class="property">staticMethod</span> = <span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">HOCComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用<a target="_blank" rel="noopener" href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>来帮助我们解决这个问题，它可以自动帮我们拷贝所有非 React 的静态方法，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HOCComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hoistNonReactStatic</span>(<span class="title class_">HOCComponent</span>, <span class="title class_">WrappedComponent</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">HOCComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Refs 不会被传递给被包装组件</li>
<li>不要在组件的 render 方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。因为高阶组件每次都会返回一个新的组件，在 render 中使用会导致每次渲染出来的组件都不相等（&#x3D;&#x3D;&#x3D;），于是每次 render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了</li>
<li>约定：不要改变原始组件。高阶组件应该是一个没有副作用的纯函数 (函数的调用参数相同，则永远返回相同的结果)</li>
<li>约定：透传不相关的 props。即 props 传递</li>
<li>约定：最好使用<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/higher-order-components.html#convention-wrap-the-display-name-for-easy-debugging">displayName</a>，方便调试。官方推荐使用 HOCName(WrappedComponentName)。eg. 赋予 return 组件一个静态属性：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> displayName = <span class="string">`aHOC(<span class="subst">$&#123;WrappedComponent.displayName&#125;</span>)`</span></span><br></pre></td></tr></table></figure>

<h1 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h1><h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><p>多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用。eg，上面写过的 localstorage 的例子</p>
<h2 id="可用、权限控制"><a href="#可用、权限控制" class="headerlink" title="可用、权限控制"></a>可用、权限控制</h2><p>当没权限的时候不展示某个组件，就是上面提到的组合渲染</p>
<h2 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h2><p>eg. <a target="_blank" rel="noopener" href="https://semi.bytedance.net/zh-CN/components/form">Semi</a> 中用 withField 封装自定义表单控件<br>通过 withField，你可以将其他自定义组件扩展成为表单控件，由 Form 接管其行为（value, onChange; 还有在上方插入Field 的<code>&lt;Label&gt;</code>， 下方插入 Field 的<code>&lt;ErrorMessage&gt;</code>等）</p>
<p>注意：自定义组件必须为受控组件，关于受控组件&#x2F;非受控组件请参考<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/glossary.html#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-vs-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6">react docs</a></p>
<h2 id="Redux-的-connect"><a href="#Redux-的-connect" class="headerlink" title="Redux 的 connect"></a>Redux 的 <a target="_blank" rel="noopener" href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect">connect</a></h2><p><img src="/img/React-HOC/connect.png"><br>下面就是一个简化版的connect实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">xport <span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Connect</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      <span class="attr">store</span>: <span class="title class_">PropTypes</span>.<span class="property">object</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">      <span class="variable language_">super</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">allProps</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_updateProps</span>()</span><br><span class="line">      store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_updateProps</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _updateProps () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps ? <span class="title function_">mapStateToProps</span>(store.<span class="title function_">getState</span>(), <span class="variable language_">this</span>.<span class="property">props</span>): &#123;&#125; </span><br><span class="line">      <span class="keyword">let</span> dispatchProps = mapDispatchToProps? <span class="title function_">mapDispatchToProps</span>(store.<span class="property">dispatch</span>, <span class="variable language_">this</span>.<span class="property">props</span>) : &#123;&#125; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">allProps</span>: &#123;</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...<span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state.allProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Connect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connect函数其实就做了一件事: 将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>嵌套太多 HOC，代码可读性会比较差</li>
<li>HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a><br><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/higher-order-components.html">官网</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/16/React%20-%20HOC/" data-id="clmniym74001nbb879yzge5wf" data-title="React - HOC" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/23/React%20-%20Hook/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          React - Hook
        
      </div>
    </a>
  
  
    <a href="/2020/04/30/CSS%20Modules/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">CSS Modules</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>