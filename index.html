<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jacleklm">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:locale">
<meta property="article:author" content="Jacleklm">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Python Basic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/30/Python%20Basic/" class="article-date">
  <time class="dt-published" datetime="2022-04-30T09:20:21.000Z" itemprop="datePublished">2022-04-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>基本来源于<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-tutorial.html">菜鸟教程</a></p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li>
<li>Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</li>
<li>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li>
</ul>
<ol>
<li>环境</li>
<li>需配置一些环境变量，暂不做 <a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-install.html">https://www.runoob.com/python3/python3-install.html</a></li>
<li>运行</li>
<li>python fileName.py运行</li>
<li>用vs code右键</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>多行语句。Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句，例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">item_one = <span class="number">1</span></span><br><span class="line">item_two = <span class="number">2</span></span><br><span class="line">item_three = <span class="number">2</span></span><br><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="built_in">print</span>(total) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建；Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型</p>
</li>
<li><p>允许你同时为多个变量赋值<br>a &#x3D; b &#x3D; c &#x3D; 1<br>a, b, c &#x3D; 1, true, “demo”</p>
</li>
<li><p>Import</p>
</li>
<li><p>在 python 用 import 或者 from…import 来导入相应的模块。</p>
</li>
<li><p>将整个模块(somemodule)导入，格式为： import somemodule</p>
</li>
<li><p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p>
</li>
<li><p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p>
</li>
<li><p>将某个模块中的全部函数导入，格式为： from somemodule import *</p>
</li>
<li><p>Python3 中有六个标准的数据类型：</p>
</li>
<li><p>Number（数字）</p>
</li>
<li><p>String（字符串）</p>
</li>
<li><p>List（列表）</p>
</li>
<li><p>Tuple（元组）</p>
</li>
<li><p>Set（集合）</p>
</li>
<li><p>Dictionary（字典）</p>
</li>
<li><p>Python3 的六个标准数据类型中：</p>
</li>
<li><p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br>1. 其实是指字符串中某个字符不可改变. Eg. str &#x3D; ‘abc’; str[1] &#x3D; ‘d’这种是不行的</p>
</li>
<li><p>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p>
</li>
<li><p>内置的 type() 函数 可以用来查询变量所指的对象类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line"><span class="comment"># &lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此外还可以用 isinstance 来判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">111</span></span><br><span class="line"><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用del语句删除一个或多个对象引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><p>单引号 ‘ 和双引号 “  使用完全相同；使用三引号 ‘’’ 或 “”” 可以指定一个多行字符串<br>word &#x3D; ‘字符串’<br>sentence &#x3D; “这是一个句子。”<br>paragraph &#x3D; “””这是一个段落，<br>可以由多行组成”””</p>
</li>
<li><p>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)                 <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])           <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])              <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])            <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])             <span class="comment"># 输出从第三个开始后的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])          <span class="comment"># 输出从第二个开始到第五个且每隔一个的字符（步长为2）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)             <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&#x27;你好&#x27;</span>)         <span class="comment"># 连接字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\nrunoob&#x27;</span>)      <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nrunoob&#x27;</span>)     <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br><span class="line"></span><br><span class="line">----------------------------输出部分-------------------------------------------</span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="number">3456789</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">123456789123456789</span></span><br><span class="line"><span class="number">123456789</span>你好</span><br><span class="line">------------------------------</span><br><span class="line">hello</span><br><span class="line">runoob</span><br><span class="line">hello\nrunoob</span><br></pre></td></tr></table></figure></li>
<li><p>字符串函数</p>
</li>
<li><p>capitalize()：首字转大写</p>
</li>
<li><p>count(str, beg&#x3D; 0,end&#x3D;len(string))：返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</p>
</li>
<li><p>endswith(suffix, beg&#x3D;0, end&#x3D;len(string))：检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</p>
</li>
<li><p>startswith(substr, beg&#x3D;0,end&#x3D;len(string))：检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查</p>
</li>
<li><p>split(str&#x3D;””, num&#x3D;string.count(str))：以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</p>
</li>
<li><p>find(str, beg&#x3D;0, end&#x3D;len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</p>
</li>
<li><p>index(str, beg&#x3D;0, end&#x3D;len(string))：跟find()方法一样，只不过如果str不在字符串中会报一个异常</p>
</li>
<li><p>rfind(str, beg&#x3D;0,end&#x3D;len(string))：类似于 find()函数，不过是从右边开始查找</p>
</li>
<li><p>lower()：转换字符串中所有大写字符为小写</p>
</li>
<li><p>replace(old, new [, max])：把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次</p>
</li>
<li></li>
<li><p>isalnum()：如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</p>
</li>
<li><p>isalpha()：如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</p>
</li>
<li><p>isdigit()：如果字符串只包含数字则返回 True 否则返回 False.</p>
</li>
<li></li>
</ol>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>python中数字有四种类型：整数int、布尔型bool（？？）、浮点数float和复数complex</p>
<ol>
<li>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加。True&#x3D;&#x3D;1、False&#x3D;&#x3D;0 会返回 True，但可以通过 is 来判断类型<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>==<span class="number">1</span>)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span>==<span class="number">0</span>)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span>+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span>)</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></li>
<li>数字运算<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></li>
<li>数学函数</li>
<li>abs(x) 绝对值</li>
<li>ceil(x) 向上取整</li>
<li>floor(x) 向下取整</li>
<li>round(x [,n]) 浮点数x的四舍五入</li>
<li>exp(x) 常数e的x次幂</li>
<li>pow(x, y) x^y</li>
<li>sqrt(x) x的平方根</li>
<li>max(a, b, c…) 最大值</li>
<li>min(a, b, c…) 最小值</li>
<li>随机数函数</li>
<li>choice(seq): 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数</li>
<li>randrange ([start,] stop [,step]): 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li>
<li>random(): 随机生成下一个实数，它在[0,1)范围内</li>
<li>shuffle(lst): 将序列的所有元素随机排序</li>
<li>uniform(x, y): 随机生成下一个实数，它在[x,y]范围内</li>
</ol>
<h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><ol>
<li>基础<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)       <span class="comment"># 输出完整列表 [&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])      <span class="comment"># 输出列表第一个元素  abcd</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])     <span class="comment"># 从第二个开始输出到第三个元素 [786, 2.23]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])     <span class="comment"># 输出从第三个元素开始的所有元素 [2.23, &#x27;runoob&#x27;, 70.2]</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)   <span class="comment"># 输出两次列表 [123, &#x27;runoob&#x27;, 123, &#x27;runoob&#x27;]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist) <span class="comment"># 连接列表 [&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2, 123, &#x27;runoob&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 (包含开始，不包含结束)的位置并设置为步长为 2（间隔一个位置）来截取字符串：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(letters[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]) <span class="comment"># [&#x27;a&#x27;, &#x27;l&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(letters[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># [&#x27;a&#x27;, &#x27;l&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(letters[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>]) <span class="comment"># [&#x27;a&#x27;, &#x27;l&#x27;, &#x27;k&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串（有一说一不好理解）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="built_in">input</span> = <span class="string">&#x27;I like python&#x27;</span></span><br><span class="line">rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(rw) <span class="comment"># python like I</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>常用方法</li>
<li>list.append(1) 。添加元素 1</li>
<li>list.insert(idx, obj)</li>
<li>list.pop([idx&#x3D;-1])</li>
<li>list.remove(obj)</li>
<li>del list[3] 删除idx 3元素</li>
<li>list.count(obj) 元素出现的次数</li>
<li>list.index(obj) 返回idx</li>
<li>list.reverse()</li>
<li>list.sort( key&#x3D;None, reverse&#x3D;False)：排序</li>
<li>list.clear()</li>
<li>list.copy()</li>
<li>List 间 的 + ，是组合</li>
<li>list * 某个num，是重复几次</li>
<li>for x in [1, 2, 3]: print(x, end&#x3D;” “)。迭代</li>
</ol>
<h2 id="Tuple元组"><a href="#Tuple元组" class="headerlink" title="Tuple元组"></a>Tuple元组</h2><ol>
<li>元组（tuple）与列表类似，不同之处在于元组的元素不能修改（像 tup[0] &#x3D; 11 这种是不允许的），也不能删除某个元素。元组写在小括号 () 里，元素之间用逗号隔开<br>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表<br>string、list 和 tuple 都属于 sequence（序列）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)        <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])      <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])     <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])      <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)    <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line">abcd(<span class="number">786</span>, <span class="number">2.23</span>)</span><br><span class="line">(<span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line">(<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>包含0个或1个元素的元组，语法比较特殊：<br>tup1 &#x3D; ()    # 空元组<br>tup2 &#x3D; (20,) # 一个元素，需要在元素后添加逗号</li>
</ol>
<p>Set（集合）</p>
<ol>
<li>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。基本功能是进行成员关系测试和删除重复元素。</li>
<li>可以使用大括号 { } 或者 set() 函数创建集合<br>注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。<br>sites &#x3D; {‘Google’, ‘Taobao’, ‘Google’, ‘Facebook’, ‘Zhihu’, ‘Baidu’}<br>print(sites)   # 输出集合，重复的元素被自动去掉 {‘Baidu’, ‘Facebook’, ‘Google’, ‘Zhihu’, ‘Taobao’}</li>
</ol>
<h2 id="成员测试"><a href="#成员测试" class="headerlink" title="成员测试"></a>成员测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;RuGooglenoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>) <span class="comment"># Runoob 不在集合中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a - b)    <span class="comment"># a 和 b 的差集</span></span><br><span class="line"><span class="built_in">print</span>(a | b)    <span class="comment"># a 和 b 的并集</span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)    <span class="comment"># a 和 b 的交集</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b)    <span class="comment"># a 和 b 中不同时存在的元素</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>常见方法</li>
<li>set.add()</li>
<li>set.clear()</li>
<li>set.copy()</li>
<li>remove() 移除指定元素</li>
<li>difference() 返回多个集合的差集</li>
<li>intersection() 返回集合的交集</li>
<li>discard() 删除集合中指定的元素<br>Dictionary（字典）</li>
<li>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。</li>
<li>键(key)必须使用不可变类型；在同一个字典中，键(key)必须是唯一的。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 菜鸟教程&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]    = <span class="string">&quot;2 - 菜鸟工具&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">dict3(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>) <span class="comment"># &#123;&#x27;sape&#x27;: 4139, &#x27;jack&#x27;: 4098, &#x27;guido&#x27;: 4127&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])     <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])       <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)      <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> - 菜鸟教程</span><br><span class="line"><span class="number">2</span> - 菜鸟工具</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line">dict_keys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;site&#x27;</span>])</span><br><span class="line">dict_values([<span class="string">&#x27;runoob&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
<li>常用方法</li>
<li>len()。返回键的总数</li>
<li>str(dict)。输出字典字符串</li>
<li>dict.clear()</li>
<li>dict.copy()</li>
<li>dict.get(key)</li>
<li>dict.setdefault(key, default&#x3D;None): 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</li>
<li>key in dict: 如果键在字典dict里返回true，否则返回false</li>
<li>dict.keys()</li>
<li>dict.items(): 以列表返回一个视图对象.eg. 返回 dict_items([(‘Name’, ‘Runoob’), (‘Age’, 7), (‘Class’, ‘First’)])</li>
<li>dict.values()</li>
<li>dict.update(dict2): 把字典dict2的键&#x2F;值对更新到dict里</li>
<li>pop(key[,default]): 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值</li>
<li>popitem(): 返回并删除字典中的最后一对键和值<br>Python数据类型转换<br><a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-type-conversion.html">https://www.runoob.com/python3/python3-type-conversion.html</a></li>
</ol>
<ul>
<li>隐式类型转换。我们对两种不同类型的数据进行运算，较低数据类型（eg. 整数）就会转换为较高数据类型（eg. 浮点数）以避免数据丢失<ul>
<li>当然也有转换不了的。eg. 整型数据与字符串类型的数据进行相加，会报错因为转换不了</li>
</ul>
</li>
<li>显式类型转换。 int()、float()、str() 等<br>Python 推导式<br>推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构，支持list、dict、set、tuple推导式</li>
</ul>
<ol>
<li>list推导式<br>[out_exp_res for out_exp in input_list]<br>或者<br>[out_exp_res for out_exp in input_list if condition]</li>
</ol>
<ul>
<li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li>
<li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li>
<li>if condition：条件语句，可以过滤列表中不符合条件的值<br>整体含义：执行后面的for 和 if 部分，满足的条件的就执行 out_exp_res 部分产出最后结果<br>例子：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line">new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br><span class="line"><span class="comment"># [&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>Dict推导式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line">或</span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure>
同理，看这个case即能理解：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="built_in">print</span>(newdict)</span><br><span class="line"><span class="comment"># &#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>Set推导式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure></li>
<li>元组tuple推导式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li>运算符。除了常规的，还有</li>
<li>** 为幂。a**b 为 a^b</li>
<li>&#x2F;&#x2F; 为取整除。eg. 9&#x2F;&#x2F;2 &#x3D;&#x3D; 4</li>
<li>:&#x3D; 为海象运算符，一般用在表达式内部为变量赋值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;List is too long (<span class="subst">&#123;n&#125;</span> elements, expected &lt;= 10)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个if即判断了 if (len(a)) &gt; 10, 又把 n 赋值为 len(a)</span></span><br></pre></td></tr></table></figure></li>
<li>逻辑运算符（不是 ||、&amp;&amp;、! 这样），是：and、or、not</li>
<li>成员运算符：in、not in</li>
<li>身份运算符：is、not is</li>
<li>运算符优先级。略</li>
</ol>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fibonacci series: 斐波纳契数列</span></span><br><span class="line"><span class="comment"># 两个元素的总和确定了下一个数</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">1000</span>:</span><br><span class="line">    <span class="built_in">print</span>(b, end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    a, b = b, a+b</span><br><span class="line"><span class="comment"># 结果：1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</span></span><br></pre></td></tr></table></figure>
<p>循环</p>
<ol>
<li>While<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> counter &lt;= n:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + counter</span><br><span class="line">    counter += <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>For<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></li>
<li>range()。如果你需要遍历数字序列，可以使用内置range()函数，它会生成数列。eg：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’).eg. for i in range(0, 10, 3) 。0到10，每步为3</li>
</ul>
<ol start="4">
<li>pass 语句。Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Runoob&#x27;</span>: </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;执行 pass 块&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前字母 :&#x27;</span>, letter)</span><br><span class="line"> <span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： </span></span><br><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">执行 <span class="keyword">pass</span> 块</span><br><span class="line">当前字母 : o</span><br><span class="line">执行 <span class="keyword">pass</span> 块</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : b</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="迭代器-与-生成器"><a href="#迭代器-与-生成器" class="headerlink" title="迭代器 与 生成器"></a>迭代器 与 生成器</h2><ol>
<li>迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退</li>
<li>迭代器有两个基本的方法：iter() 和 next()</li>
<li>字符串，列表或元组对象都可用于创建迭代器<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素 # 1</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li>
<li>生成器 yield。在 Python 中，使用了 yield 的函数被称为生成器（generator）。跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象<br>函数<br>函数以 def 开头，而不是func或function这种，而且也没有 { } 这种边界，完全考层级肉眼区分</li>
<li>参数</li>
<li>默认参数。和 js 一致</li>
<li>不定长参数。<br>1. 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printMoreArgs</span>(<span class="params">a, *morArgs</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;a is&quot;</span>, a)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;morArgs is&quot;</span>, morArgs) <span class="comment"># morArgs is (5, 6, &#x27;jacle&#x27;)</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(morArgs)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">printMoreArgs(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;jacle&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>1. 加了两个星号 ** 的参数会以字典的形式导入
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jacle&#x27;, &#x27;age&#x27;: &#x27;21&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">1</span>, name=<span class="string">&#x27;jacle&#x27;</span>,age=<span class="string">&#x27;21&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>匿名函数。Python 使用 lambda 来创建匿名函数。语法如下<br><code>lambda [arg1 [,arg2,.....argn]]:expression</code></li>
</ol>
<p>Eg.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">lambda</span> a : a + <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>模块</p>
<ol>
<li>import<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module</span><br><span class="line"></span><br><span class="line">module.method(args)</span><br></pre></td></tr></table></figure></li>
<li>from … import<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> method1[, method2[, ... methodN]]</span><br></pre></td></tr></table></figure></li>
<li>from … import *   把一个模块的所有内容全都导入到当前的命名空间</li>
<li>__name__属性。每个模块都有这个属性，用来识别该模块是「自身在运行」，还是「被引用后」在运行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># path: ./mod1.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br></pre></td></tr></table></figure>
直接运行 python .&#x2F;mod1，会打印出 程序自身在运行；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># path: ./mod2.py</span></span><br><span class="line"><span class="keyword">import</span> mod1</span><br></pre></td></tr></table></figure>
若是被其他模块引用后运行，则打印出 我来自另一模块<br>命名空间和作用域链<br>感觉和js差不多<br>面向对象<br>用class关键字创建类<br>错误和异常</li>
<li>try&#x2F;expcept语句</li>
<li>try&#x2F;expcept…else语句<br>常用功能<br>输入输出<br>正则<br>JSON<br>日期和时间<br>File<br>OS</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-function.html">https://www.runoob.com/python3/python3-function.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/30/Python%20Basic/" data-id="clmniym72001gbb87bagp9jt3" data-title="Python Basic Knowledge" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-解决hexo g生成index.html为空的问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-04-17T12:33:46.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近一段时间博客通过域名访问的方式一直访问为空白页面，我以为是github的问题过段时间就好了，就没太管，后来一直没恢复，于是查了下是什么原因。刚开始以为是githubpage的问题，往这个方向折腾了好久没啥结果… 不过也知道到了 <code>username.github.io</code> 下可以通过路由的方式部署多个项目，问题没解决不过也没白折腾吧。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最终发现是之前没管的hexo的循环依赖问题：<br><code>hexo -s</code>预览博客的时候出现循环引用的报错：<code>hexo (node:7801) Warning: Accessing non-existent property &#39;filename&#39;...</code>。目前社区上认为是node版本较新导致了，回退node版本即可。于是安装了<code>n</code>进行node版本管理。(回退到 v12.16.2 就没问题了) </p>
<blockquote>
<p>用 nvm 管理 node 版本也可</p>
</blockquote>
<h1 id="n的常用命令"><a href="#n的常用命令" class="headerlink" title="n的常用命令"></a>n的常用命令</h1><ul>
<li>利用 n 下载所需node: <code>$ n 版本号</code></li>
<li>下载最新版本: <code>$ n latest</code></li>
<li>下载稳定版: <code>$ n stable</code></li>
<li>删除某个版本: <code>$ n rm 4.4.4</code></li>
<li>查看当前 node 版本: <code>$ node -v</code></li>
<li>切换版本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ n</span><br><span class="line">  <span class="number">6.9</span><span class="number">.4</span></span><br><span class="line">ο <span class="number">7.4</span><span class="number">.0</span></span><br><span class="line">  <span class="number">4.4</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></li>
<li>以指定的版本来执行脚本: <code>$ n use 7.4.0 index.js</code>ç</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="clmniym8c0058bb879fmbdj6v" data-title="解决hexo g生成index.html为空的问题" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TypeScript中的内置工具类型及其实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2020-12-09T09:25:21.000Z" itemprop="datePublished">2020-12-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>先来看下基础实现 clone，把 T 里面的都拷贝一次：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cloneT&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>将类型定义的所有属性<strong>都修改为可选</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Foo</span>&gt;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]?: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="类似Partial的实现，还有-Required，Readonly"><a href="#类似Partial的实现，还有-Required，Readonly" class="headerlink" title="类似Partial的实现，还有 Required，Readonly"></a>类似Partial的实现，还有 Required，Readonly</h1><p>Required 的作用是将传入的属性变为必选项, Readonly是将所有属性定义为自读，源码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; </span><br><span class="line">  [K <span class="keyword">in</span> keyof T]-?: T[K];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类似 <code>-?</code>, <code>readonly</code>, 同理还有 <code>-readonly</code></p>
</blockquote>
<h1 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>以 typeof 格式快速创建一个类型，此类型包含一组指定的属性且<strong>都是必填</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = &#123;</span><br><span class="line">	<span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h1 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h1><p>不管是从字面意思，还是定义上都很好理解：将所有属性定义为自读</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Record</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, <span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果进行了修改，则会报错：</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: <span class="title class_">Coord</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line">c.<span class="property">x</span> = <span class="number">2</span>; <span class="comment">// Error: Cannot assign to &#x27;x&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>
<h1 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h1><p>从类型定义的属性中，选取指定一组属性，返回一个新的类型定义。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CoordX</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Coord</span>, <span class="string">&#x27;x&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等用于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CoordX</span> = &#123;</span><br><span class="line">	<span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个很实用的实现就是 clone，把 T 里面的都拷贝一次</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cloneT&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>重要的就是这个in操作符，你完全可以把它理解为就是for…in，也就包含了遍历的过程</p>
<h1 id="Partial-1"><a href="#Partial-1" class="headerlink" title="Partial"></a>Partial</h1><p>clone再可选</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]?: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>参考文献</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/" data-id="clmniym75001rbb87agdthy6a" data-title="TypeScript中的内置工具类型及其实现" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TypeScript中的类型编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2020-12-07T09:25:21.000Z" itemprop="datePublished">2020-12-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章是读了林不渡的<a target="_blank" rel="noopener" href="https://juejin.cn/post/6885672896128090125#heading-0">TypeScript 的另一面：类型编程</a>，码了一些 demo 并查了其他文档等最后留下的学习笔记。建议直接读原文，本文可读性较差</p>
<h2 id="类型编程的特点-看法"><a href="#类型编程的特点-看法" class="headerlink" title="类型编程的特点&#x2F;看法"></a>类型编程的特点&#x2F;看法</h2><ul>
<li>它会带来代码量大大增多（可能接近甚至超过业务代码），编码耗时增长等问题，而带来的唯一好处就是<strong>类型安全</strong>，包括的类型提示，进一步减少可能存在的调用错误，以及降低维护成本。看起来似乎有得有失，但实际上，假设你花费 1 单位脑力使用基础的 TS 以及简单的类型编程，你就能够获得 5 个单位的回馈。但接下来，有可能你花费 10 个单位脑力，也只能再获得 2 个单位的回馈</li>
<li>另外一个类型编程不受重视的原因则是实际业务中并不会需要多么苛刻的类型定义，通常是底层框架类库才会有此类需求</li>
</ul>
<h1 id="泛型-Generic-Type"><a href="#泛型-Generic-Type" class="headerlink" title="泛型 Generic Type"></a>泛型 Generic Type</h1><p>见<a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/">TypeScript 基础语法小结</a></p>
<blockquote>
<p>在类型编程里，泛型就是变量</p>
</blockquote>
<p>比如我们要写一个类似于 Pick 功能的函数，从一个 obj 中挑选一些键值对出来，可以这么写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> getValueListOfObj&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">keys</span>: U[]): T[U][] &#123;</span><br><span class="line">  <span class="keyword">return</span> keys.<span class="title function_">map</span>(<span class="function">(<span class="params">key: U</span>) =&gt;</span> obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还用 extends 做了一定的泛型约束</p>
<h1 id="索引类型与映射类型"><a href="#索引类型与映射类型" class="headerlink" title="索引类型与映射类型"></a>索引类型与映射类型</h1><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>索引类型见<a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/">TypeScript 基础语法小结</a></p>
<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>映射类型 Mapped Types 通常用于在旧有类型的基础上进行改造，包括接口包含字段、字段的类型、修饰符（readonly 与?）等等。可以利用 Readonly，Partial 等这些 TS 内置<strong>工具类型</strong>(也叫类型接口)实现这个过程。</p>
<blockquote>
<p>简单地说就是 TS 允许将一个类型映射成另外一个类型</p>
</blockquote>
<p>一个很实用的实现就是 clone，把 T 里面的都拷贝一次</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cloneT&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这种已经算是工具类型的实现了。相当于类型编程中的 utils</p>
</blockquote>
<p>这部分详见 <a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/9">TypeScript 中的内置工具类型及其实现</a></p>
<h1 id="条件类型-Conditional-Types"><a href="#条件类型-Conditional-Types" class="headerlink" title="条件类型 Conditional Types"></a>条件类型 Conditional Types</h1><p>条件类型的语法实际上就是三元表达式。其中一个常见应用就是用来实现更精准的泛型约束，<strong>使得泛型收窄</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends U ? X : Y</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种场景下 T 一般是联合类型。如果你觉得这里的 extends 不太好理解，可以暂时简单理解为 U 中的属性在 T 中都有</p>
</blockquote>
<p>条件类型理解起来更直观，唯一需要有一定理解成本的就是<strong>何时条件类型系统会收集到足够的信息来确定类型</strong>，也就是说，条件类型有可能不会被立刻完成判断。<br>有时候，条件类型的推导会被延迟（deferred），因为此时类型系统没有足够的信息来完成判断：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单纯声明而已</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> strOrNum&lt;T <span class="keyword">extends</span> <span class="built_in">boolean</span>&gt;(<span class="attr">input</span>: T): T <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>只有给出了所需信息（在这里是input值），才可以完成推导</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strReturnType = <span class="title function_">strOrNum</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="嵌套的条件类型"><a href="#嵌套的条件类型" class="headerlink" title="嵌套的条件类型"></a>嵌套的条件类型</h2><p>此外，就像三元表达式可以嵌套，条件类型也可以嵌套，如果你看过一些框架源码，也会发现其中存在着许多嵌套的条件类型，条件类型可以将类型约束收拢到非常精确的范围内</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">  ? <span class="string">&#x27;string&#x27;</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">    ? <span class="string">&#x27;number&#x27;</span></span><br><span class="line">    : T <span class="keyword">extends</span> <span class="built_in">boolean</span></span><br><span class="line">      ? <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">      : T <span class="keyword">extends</span> <span class="literal">undefined</span></span><br><span class="line">        ? <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">        : T <span class="keyword">extends</span> <span class="title class_">Function</span></span><br><span class="line">          ? <span class="string">&#x27;function&#x27;</span></span><br><span class="line">          : <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">good</span>: <span class="title class_">TypeName</span>&lt;<span class="built_in">number</span>&gt; = <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">bad</span>: <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>&gt; = <span class="string">&#x27;number&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="分布式条件类型-Distributive-Conditional-Types"><a href="#分布式条件类型-Distributive-Conditional-Types" class="headerlink" title="分布式条件类型 Distributive Conditional Types"></a>分布式条件类型 Distributive Conditional Types</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>分布式条件类型实际上不是一种特殊的条件类型，而是其特性之一。概括地说，就是<strong>对于属于裸类型参数的检查类型，条件类型会在实例化时期自动分发到联合类型上</strong></p>
<blockquote>
<p>原文: Conditional types in which the checked type is a <strong>naked type parameter</strong> are called distributive conditional types.  Distributive conditional types are automatically <strong>distributed over union types</strong> during instantiation</p>
</blockquote>
<h3 id="不负责任可能不太准确的简介"><a href="#不负责任可能不太准确的简介" class="headerlink" title="不负责任可能不太准确的简介"></a>不负责任可能不太准确的简介</h3><p>对这样一个场景：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> someTypeName&lt;T&gt; = T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>
<p>若<code>T</code>为联合类型且<code>T</code>不被包裹，则<code>T</code>中的项会被拆开分别做<code>extends U</code>判断，再把结果合并组成一个联合类型作为推断结果</p>
<p>抽象起来就是：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( A | B | C ) <span class="keyword">extends</span> U ? X : Y</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">(A <span class="keyword">extends</span> U ? X : Y) | (B <span class="keyword">extends</span> U ? X : Y) | (B <span class="keyword">extends</span> U ? X : Y)</span><br></pre></td></tr></table></figure>

<h3 id="正确版的理清概念"><a href="#正确版的理清概念" class="headerlink" title="正确版的理清概念"></a>正确版的理清概念</h3><p>先提取几个关键词，然后我们再通过例子理清这个概念：</p>
<ul>
<li>裸类型参数</li>
<li>实例化</li>
<li>分发到联合类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面的TypeName类型别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;string&quot; | &quot;function&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;string&quot; | &quot;object&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>[] | <span class="built_in">number</span>[]&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现在上面的例子里，条件类型的推导结果都是联合类型（T3实际上也是，只不过相同所以被合并了），并且就是类型参数被依次进行条件判断的结果。<br>但是当我们这样做：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Naked</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Wrapped</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">boolean</span>] ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 先分发到 Naked&lt;number&gt; | Naked&lt;boolean&gt;</span></span><br><span class="line"><span class="comment"> * 结果是 &quot;N&quot; | &quot;Y&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Distributed</span> = <span class="title class_">Naked</span>&lt;<span class="built_in">number</span> | <span class="built_in">boolean</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 不会分发 直接是 [number | boolean] extends [boolean]</span></span><br><span class="line"><span class="comment"> * 然后结果是 &quot;N&quot;</span></span><br><span class="line"><span class="comment"> * 在这两个例子中，T 都是 number | boolean。区别是 T 有没有被【包裹】过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NotDistributed</span> = <span class="title class_">Wrapped</span>&lt;<span class="built_in">number</span> | <span class="built_in">boolean</span>&gt;; </span><br></pre></td></tr></table></figure>
<p>现在我们可以来讲讲这几个概念了：</p>
<ul>
<li><strong>裸类型参数</strong>，没有额外被接口&#x2F;类型别名包裹过的，就像被Wrapped包裹后就不能再被称为裸类型参数。</li>
<li><strong>实例化</strong>，其实就是条件类型的判断过程，在这里两个例子的实例化过程实际上是不同的，具体会在下一点中介绍。</li>
<li><strong>分发至联合类型的过程</strong>：<br>对于TypeName，它内部的类型参数T是没有被包裹过的，所以<br><code>TypeName&lt;string | (() =&gt; void)&gt;</code> 会被分发为 <code>TypeName&lt;string&gt; | TypeName&lt;(() =&gt; void)&gt;</code>, 然后再次进行判断，最后分发为<code>&quot;string&quot; | &quot;function&quot;</code><br>抽象下具体过程：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( A | B | C ) <span class="keyword">extends</span> T ? X : Y</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">(A <span class="keyword">extends</span> T ? X : Y) | (B <span class="keyword">extends</span> T ? X : Y) | (B <span class="keyword">extends</span> T ? X : Y)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一句话概括：没有被额外包装的联合类型参数T，在条件类型进行判定时会<strong>将联合类型</strong>分发，分别进行判断。</p>
<h1 id="infer关键字"><a href="#infer关键字" class="headerlink" title="infer关键字"></a><a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/tips/infer.html#%E4%BB%8B%E7%BB%8D">infer关键字</a></h1><p>infer是inference的缩写，通常的使用方式是<code>infer R</code>，<code>R</code>表示 <strong>待推断的类型</strong>。通常infer不会被直接使用，而是被放置在底层工具类型中，需要在条件类型中使用<br>看一个简单的例子，用于获取函数返回值类型的工具类型<code>ReturnType</code>，其用法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getStr = (): <span class="function"><span class="params">string</span> =&gt;</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> fn = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> getStr&gt;; <span class="comment">// 推断结果是 &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>ReturnType</code>源码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>
<p>这里的<code>infer R</code>就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用。相当于预留一个变量来存函数的返回类型<br>类似前端中的loading占位符，infer也是这个思路，<strong>类型系统在获得足够的信息后，就能将infer后跟随的类型参数推导出来</strong>，最后返回这个推导结果</p>
<h1 id="类型守卫-类型保护-Type-Guards-is、in-关键字"><a href="#类型守卫-类型保护-Type-Guards-is、in-关键字" class="headerlink" title="类型守卫(类型保护)Type Guards &amp;&amp; is、in 关键字"></a>类型守卫(类型保护)Type Guards &amp;&amp; is、in 关键字</h1><p>见<a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/">TypeScript 基础语法小结</a></p>
<h1 id="工具类型Tool-Type-及其实现"><a href="#工具类型Tool-Type-及其实现" class="headerlink" title="工具类型Tool Type 及其实现"></a>工具类型Tool Type 及其实现</h1><p>工具类型就像我们自己的util或者我们用的lodash一样，虽然即使你还是不太懂这些工具类型的底层实现，也不影响你把它用好，不够我们自己还是得了解下比较好。推荐在完成学习后记录你觉得比较有价值的工具类型，并在自己的项目里新建一个<code>.d.ts</code>文件存储它</p>
<h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a></p>
<h2 id="社区工具类型"><a href="#社区工具类型" class="headerlink" title="社区工具类型"></a>社区工具类型</h2><p>参考资料<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6885672896128090125#heading-0">TypeScript 的另一面：类型编程</a><br><a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a><br>组内分享: TS 最佳实践</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/" data-id="clmniym790020bb872vvyhxpt" data-title="TypeScript中的类型编程" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hope statistics puppeteer工具小结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2020-11-03T15:04:21.000Z" itemprop="datePublished">2020-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Engineering/">Engineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h1><p><a target="_blank" rel="noopener" href="https://github.com/puppeteer/puppeteer#readme">Puppeteer</a> 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具。Chrome 作为浏览器市场的领头羊，Chrome Headless 将成为 web 应用 <strong>自动化测试</strong> 的行业标杆</p>
<blockquote>
<p>Headless浏览器是指没有窗口的浏览器</p>
</blockquote>
<h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>通过 Puppeteer 我们可以让浏览器帮我们自动完成很多事情, 例如 ：</p>
<ul>
<li>生成页面的截图或者PDF</li>
<li>自动表单提交 (模拟登陆等)，UI测试，键盘输入</li>
<li>创建自动化测试环境</li>
</ul>
<p>具体API见<a target="_blank" rel="noopener" href="https://github.com/puppeteer/puppeteer/blob/v5.4.1/docs/api.md#pageevalselector-pagefunction-args">官方文档</a></p>
<h1 id="hope-statistics-puppeteer"><a href="#hope-statistics-puppeteer" class="headerlink" title="hope statistics puppeteer"></a>hope statistics puppeteer</h1><p>一个基于 puppeteer 和 node 编写的小工具，用于统计工作室成员当月的日志、笔记、小结数目，代码见<a target="_blank" rel="noopener" href="https://github.com/Jacleklm/hope-statistics-puppeteer">仓库</a></p>
<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>考虑到需要的输入并不复杂，交互方面直接用了 <a target="_blank" rel="noopener" href="http://nodejs.cn/api/readline.html">readline</a> 模块。涉及到更多输入的可用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/prompt">prompt</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入当前的年份和月份，然后按回车键结束。eg: 202010    &#x27;</span>, <span class="function">(<span class="params">month</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入本月小结会的月份和日期，然后按回车键结束。eg: 1130    &#x27;</span>, <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据统计中, 请勿触碰键盘...&#x27;</span>);</span><br><span class="line">    <span class="title function_">app</span>(<span class="title class_">Number</span>(month), <span class="title class_">Number</span>(date));</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="计算当月任务量"><a href="#计算当月任务量" class="headerlink" title="计算当月任务量"></a>计算当月任务量</h2><p>由于每月要求的日志、学习笔记数量都是不定的，这里调用了一个 <a target="_blank" rel="noopener" href="https://www.kancloud.cn/xiaoggvip/holiday_free/1606802">免费API</a> ，用于获取当月的<strong>法定节假日情况</strong>，再封装成一个 getTask 方法完成这部分计算</p>
<h2 id="日志、笔记、小结数爬取"><a href="#日志、笔记、小结数爬取" class="headerlink" title="日志、笔记、小结数爬取"></a>日志、笔记、小结数爬取</h2><p>这里用了 puppeteer 提供的爬虫的功能，直接进行页面爬取并计算，具体见代码</p>
<p>参考资料<br>了解Puppeteer[<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903564880379912]">https://juejin.im/post/6844903564880379912]</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/" data-id="clmniym7e002jbb87csw55j80" data-title="hope statistics puppeteer 工具小结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/" rel="tag">Node</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-用 node.js 开发一个可交互的命令行应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/03/%E7%94%A8%20node.js%20%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2020-11-03T15:02:21.000Z" itemprop="datePublished">2020-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Engineering/">Engineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/03/%E7%94%A8%20node.js%20%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/">用 node.js 开发一个可交互的命令行应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="原生-node"><a href="#原生-node" class="headerlink" title="原生 node"></a>原生 node</h1><ul>
<li>用 process.argv 直接读取</li>
<li>process.stdin.on 劫持输入</li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/readline.html">readline</a> 模块 进行逐行读取。该模块提供了一个接口，用于一次一行地读取可读流（例如 <code>process.stdin</code>）中的数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入当前的年份和月份，然后按回车键。eg: 202010. &#x27;</span>, <span class="function">(<span class="params">month</span>) =&gt;</span> &#123;</span><br><span class="line">  rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入本月小结会的月份和日期，然后按回车键。eg: 1130. &#x27;</span>, <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据统计中, 请勿触碰键盘...&#x27;</span>);</span><br><span class="line">    <span class="title function_">app</span>(month, date);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一旦调用此代码，Node.js 应用程序将不会终止，直到 readline.Interface 关闭（ rl.close() ），因为接口在 input 流上等待接收数据</span></span><br><span class="line">    <span class="comment">// rl.close();</span></span><br><span class="line"></span><br><span class="line">    rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// close事件，ctrl + C 也会触发。详见 http://nodejs.cn/api/readline.html</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Goodbye 👋&quot;</span>);</span><br><span class="line">      <span class="comment">// exit the process</span></span><br><span class="line">      process.<span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="借助-prompt-包"><a href="#借助-prompt-包" class="headerlink" title="借助 prompt 包"></a>借助 prompt 包</h1><p>如果你 打算在Node.js中构建可靠的CLI工具，则 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/prompt">prompt</a> 可能是一个很好的选择。比readline更好用。<br>能像处理页面表单一样处理命令行输入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prompt = <span class="built_in">require</span>(<span class="string">&#x27;prompt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start the prompt</span></span><br><span class="line">prompt.<span class="title function_">start</span>();</span><br><span class="line"><span class="comment">// define properties schemavar schema = &#123;</span></span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: &#123;</span><br><span class="line">            <span class="attr">pattern</span>: <span class="regexp">/^[a-zA-Z\s\-]+$/</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;Name must be only letters, spaces, or dashes&#x27;</span>,</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">password</span>: &#123;</span><br><span class="line">            <span class="attr">hidden</span>: <span class="literal">true</span>  <span class="comment">// 这里能隐藏密码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask user for the input</span></span><br><span class="line">prompt.<span class="title function_">get</span>(schema, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print user credentials</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;result.name&#125;</span> / <span class="subst">$&#123;result.password&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>借助 Commander 包<br>这个感觉更像是封装命令行命令了，不仅仅是初始化时读取输入<br>代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">version</span>(<span class="string">&#x27;0.0.1&#x27;</span>)  <span class="comment">// node index --version 或 node index -V 能打印出我们定义的版本号。相当于 -V 和 -h 是自带的，其他的可以通过 .option() 来自定义</span></span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;-l, --list [list]&#x27;</span>, <span class="string">&#x27;list of customers in CSV file&#x27;</span>) <span class="comment">// 自定义的</span></span><br><span class="line">  .<span class="title function_">parse</span>(process.<span class="property">argv</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(program.<span class="property">list</span>);</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; node index --version 或 node index -V 能打印出我们定义的版本号</span><br><span class="line"><span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">&gt; node index --help</span><br><span class="line"><span class="title class_">Usage</span>: index [options]</span><br><span class="line"><span class="title class_">Options</span>:</span><br><span class="line">  -V, --version      output the version number</span><br><span class="line">  -l, --list [list]  list <span class="keyword">of</span> customers <span class="keyword">in</span> <span class="variable constant_">CSV</span> file</span><br><span class="line">  -h, --help         display help <span class="keyword">for</span> command</span><br></pre></td></tr></table></figure>


<p>参考资料<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ccf19881030/article/details/109111128">如何从Node.js中的命令行读取输入</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/6844903474316967950">用 node.js 开发一个可交互的命令行应用: commander</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/03/%E7%94%A8%20node.js%20%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/" data-id="clmniym8d005bbb878w0ghepg" data-title="用 node.js 开发一个可交互的命令行应用" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/" rel="tag">Node</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-《深入浅出Node.js》读书笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/15/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2020-07-15T15:02:21.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/15/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《深入浅出Node.js》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>感受：这本书更偏向于讲 NodeJS 的大纲和原理。所以本笔记只讲原理和case，对于API不熟的请翻<a target="_blank" rel="noopener" href="http://nodejs.cn/api/">文档</a>，或看<a target="_blank" rel="noopener" href="https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/fs.md">小卡的笔记</a>, 或看<a target="_blank" rel="noopener" href="https://blog.poetries.top/node-learning-notes/">poetries的笔记</a> </p>
<h1 id="第一章-Node-简介"><a href="#第一章-Node-简介" class="headerlink" title="第一章 Node 简介"></a>第一章 Node 简介</h1><h2 id="Chrome-浏览器的组成和-Node-的组件组成"><a href="#Chrome-浏览器的组成和-Node-的组件组成" class="headerlink" title="Chrome 浏览器的组成和 Node 的组件组成"></a>Chrome 浏览器的组成和 Node 的组件组成</h2><p><img src="/img/Node/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8CNode%E7%9A%84%E7%BB%84%E4%BB%B6%E7%BB%84%E6%88%90.png"></p>
<h2 id="Node-的特点"><a href="#Node-的特点" class="headerlink" title="Node 的特点"></a>Node 的特点</h2><ul>
<li>异步 I&#x2F;O。eg. Ajax, fs.readFile 等，Node 中绝大数的操作都以异步的方式进行调用</li>
<li>事件与回调函数。将前端中广泛成熟点时间机制引入后端，配合 IO 使用，eg. 监听 request 事件，然后执行回调函数</li>
<li>单线程。保留了 JS 在浏览器中单线程的特点<ul>
<li>优点：不用在意状态的同步问题，没有死锁的存在，也没有上下文交互的性能开销</li>
<li>弱点：<ul>
<li>无法利用多核 CPU</li>
<li>错误会引起整个应用退出，代码健壮性值得考验</li>
<li>大量计算占用 CPU 无法继续调用异步 I&#x2F;O。eg. 长时间的 CPU 占用会导致后续的异步 IO 发不出调用。浏览器中类似的问题被 Web Worker 解决，Node 也采用类似的思路：子进程 child_process</li>
</ul>
</li>
<li>子进程的出现可以解决单线程在健壮性和无法利用多核 CPU 的问题。通过将计算分发到各个子进程，可以将大量斤算分解掉，再通过进程的事件消息来传递结果，可很好地保持应用模型的简单和依赖；通过 Master-Worker 的管理方式，也可以很好地管理各个工作的进程，以达到更高的健壮性</li>
</ul>
</li>
<li>跨平台。Node 基于 libuv 实现跨平台，可以在 Linux，Window 使用。它在操作系统和 Node 上层模块系统之间构建了一层平台层架构，即 libuv。libux 也是许多系统实现跨平台的基础组件</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>I&#x2F;O 密集</li>
<li>CPU 密集是否不合适？Node 没有提供多线程用于计算支持，但是仍有两个方式充分利用 CPU:<ul>
<li>Node 可以通过编写 C++扩展的方式提高 CPU 利用，将一些 V8 不能做到性能极致的地方用 C++来实现</li>
<li>用子进程的方式，将一部分进程用来计算，然后用进程通信传递结果，将计算和 I&#x2F;O 分离</li>
</ul>
</li>
</ul>
<h2 id="应用好处"><a href="#应用好处" class="headerlink" title="应用好处"></a>应用好处</h2><p>用 Node 做 Web 开发，前端工程师在 HTTP 协议栈的两端能高效灵活开发，避免了 Java 的繁琐；另一方面，又利用 Java 作为后端接口和中间件，使其有良好的稳定性。两者取长补短</p>
<h1 id="第二章-模块机制"><a href="#第二章-模块机制" class="headerlink" title="第二章 模块机制"></a>第二章 模块机制</h1><h2 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h2><p>解决 JS 弱结构性的问题，愿景：希望 JS 能在任何地方运行<br>eg.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(‘math’)</span><br><span class="line">…</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; xxx &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Node-模块的实现"><a href="#Node-模块的实现" class="headerlink" title="Node 模块的实现"></a>Node 模块的实现</h2><h3 id="引入模块的实现步骤："><a href="#引入模块的实现步骤：" class="headerlink" title="引入模块的实现步骤："></a>引入模块的实现步骤：</h3><ul>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ul>
<blockquote>
<p>Node 提供的模块称为核心模块；用户编写的模块称为文件模块。都会优先从缓存加载 Module._cache；缓存的是 Node 编译和执行后的对象</p>
</blockquote>
<h3 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h3><blockquote>
<p>核心模块部分在 Node 源代码的变异过程中，编译进了二进制执行文件；启动时就被直接加载进内存中；而文件模块是在运行时动态加载，需要完成走上述三个流程<br>定位到具体文件后，Node 会新建一个模块对象，然后根据路径载入并编译。对不同的文件扩展名，载入方式不同:</p>
</blockquote>
<ul>
<li>.js。通过 fs 模块读取文件后编译执行</li>
<li>.node。这是 C&#x2F;C++编写的扩展文件，通过 process.dlopen()方法加载最后编译生成的文件(但其实 C&#x2F;C++模块不用编译，它本来就是编译好的)。C&#x2F;C++模块的优势是执行效率；但显然 JS 编写的模块开发速度更快</li>
<li>.json。fs 模块读取后，用 JSON.parse()解析返回结果</li>
<li>其他。都被当成.js</li>
</ul>
<h2 id="核心模块-编译-编写核心模块"><a href="#核心模块-编译-编写核心模块" class="headerlink" title="核心模块 &amp; 编译 &amp; 编写核心模块"></a>核心模块 &amp; 编译 &amp; 编写核心模块</h2><p>核心模块分为 C&#x2F;C++编写的和 JS 编写的两部分。Node 的 buffer，crypto，evals，fs，os 等模块都是部分通过 C&#x2F;C++编写的</p>
<h2 id="C-C-扩展模块-加载-编写"><a href="#C-C-扩展模块-加载-编写" class="headerlink" title="C&#x2F;C++扩展模块 &amp; 加载 &amp; 编写"></a>C&#x2F;C++扩展模块 &amp; 加载 &amp; 编写</h2><p>CPU 性能更加</p>
<h2 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h2><p><img src="/img/Node/%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%A0%88.png"></p>
<h2 id="包和-NPM"><a href="#包和-NPM" class="headerlink" title="包和 NPM"></a>包和 NPM</h2><p>在模块之外，包和 NPM 是将模块联系起来的一种机制，是在模块的基础上进一步组织 JS 代码。包结构如下：</p>
<ul>
<li>package.json</li>
<li>bin。存放可执行的二进制文件</li>
<li>lib。存放 JS 代码</li>
<li>doc</li>
<li>test。单元测试用例</li>
</ul>
<h2 id="已经很少用的-AMD-和-CMD-规范"><a href="#已经很少用的-AMD-和-CMD-规范" class="headerlink" title="已经很少用的 AMD 和 CMD 规范"></a>已经很少用的 AMD 和 CMD 规范</h2><h1 id="第三章-异步-I-O"><a href="#第三章-异步-I-O" class="headerlink" title="第三章 异步 I&#x2F;O"></a>第三章 异步 I&#x2F;O</h1><h2 id="异步-I-O-实现现状"><a href="#异步-I-O-实现现状" class="headerlink" title="异步 I&#x2F;O 实现现状"></a>异步 I&#x2F;O 实现现状</h2><p>阻塞 IO 造成 CPU 等待浪费，非阻塞带来的麻烦事需要轮训去确认是否完成数据获取，它会让 CPU 处理状态判断，是对 CPU 资源的浪费<br>轮询的五种方案：read, select,poll, epoll(效率最高), kqueue。见 P53</p>
<h2 id="Node-的异步-IO"><a href="#Node-的异步-IO" class="headerlink" title="Node 的异步 IO"></a>Node 的异步 IO</h2><blockquote>
<p>事件循环、观察者、请求对象、I&#x2F;O 线程池这四者共同构建成了 Node 异步 I&#x2F;O 模型的基本要素<br>事件循环是异步实现的核心</p>
</blockquote>
<ul>
<li>Node 自身的执行模型是<strong>事件循环</strong>，正是它使得回调函数十分普遍。进程启动的时候，Node 会创建一个类似 whlie 的循环，每执行一次循环体的过程我们称为 Tick。如下图</li>
<li>(还有事件?) 那里即是<strong>观察者</strong></li>
</ul>
<p><img src="/img/Node/Tick.png"></p>
<h3 id="请求对象-和-I-O-线程池"><a href="#请求对象-和-I-O-线程池" class="headerlink" title="请求对象 和 I&#x2F;O 线程池"></a>请求对象 和 I&#x2F;O 线程池</h3><p>没太看懂。反正整个异步 IO 流程如下：</p>
<blockquote>
<p>输入输出完成端口（Input&#x2F;Output Completion Port，IOCP）</p>
</blockquote>
<p><img src="/img/Node/%E5%BC%82%E6%AD%A5IO%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li>这里的单线程与 IO 线程池看起来有些悖论的杨祖。由于我们知道 JS 是单线程的，所以按常识容易理解为它不能充分利用多核 CPU。事实上，在 Node 中，除了 JS 是单线程外，Node 自身其实是多线程的，只是 IO 线程使用的 CPU 较少</li>
<li>另一点需要重视的观点则是，除了用户代码无法并行执行外，所有的 IO（磁盘 IO 和网络 IO 等）则是可以并行起来的</li>
</ul>
<h2 id="非-IO-的异步-API"><a href="#非-IO-的异步-API" class="headerlink" title="非 IO 的异步 API"></a>非 IO 的异步 API</h2><blockquote>
<p>Node 中与 IO 无关的异步 API：setTimeout(), setInterval(), setImmediate(), process.nextTick()</p>
</blockquote>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>setTimeout()和 setInterval()和浏览器中是一致的，分别用于单次和多次定时执行任务。</p>
<ul>
<li>原理。它们的原理与异步 IO 比较类似，只是不需要 IO 线程池的参与。调用 setTimeout()或 setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代去除定时器对象，检查是否超过时间，如果超过，就形成一个事件，它的回调函数将立即执行。这个过程包含动用红黑树，创建定时器对象和迭代等操作，较为浪费性能</li>
<li>问题。它并非精准的。尽管时间循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。eg. 通过 setTimeout 设定一个任务在 10ms 后执行，但是在 9ms 后，有一个任务占用了 5ms 的 CPU 时间片，再次轮到定时器执行时，时间就已经过期 4ms 了</li>
</ul>
<p><img src="/img/Node/settimeout.png"></p>
<h3 id="process-nextTick-和-setImmediate"><a href="#process-nextTick-和-setImmediate" class="headerlink" title="process.nextTick() 和 setImmediate()"></a>process.nextTick() 和 setImmediate()</h3><ul>
<li>每次调用 process.nextTick 函数，只会将回调函数放入队列中，在下一轮 Tick 的时候取出运行。定时器中采用红黑树操作的时间复杂度为 O(lg(n)), 而 nextTick 为 O(1)，更为高效</li>
<li>setImmediate()和 process.nextTick 十分类似，都是将回调函数延迟执行。但是执行优先级没 process.nextTick 高。似乎都属于微任务？</li>
</ul>
<h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p><img src="/img/Node/web%E6%9C%8D%E5%8A%A1%E5%99%A8.png"><br>图3-15 利用Node构建Wen服务器的流程图</p>
<h1 id="第四章-异步编程"><a href="#第四章-异步编程" class="headerlink" title="第四章 异步编程"></a>第四章 异步编程</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul>
<li>高阶函数：可以把函数作为参数，或是将函数作为返回值的函数。eg. JS中的forEach, some, reduce等</li>
<li>偏函数：指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。个人理解：偏函数会返返回一个函数，返回的函数的一部分是由偏函数的参数生成的。eg. 封装一个判断类型的函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object &#x27;</span> + type + <span class="string">&#x27;]&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Let</span> isString = <span class="title function_">isType</span>(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="title function_">isString</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="异步编程的优势和难点"><a href="#异步编程的优势和难点" class="headerlink" title="异步编程的优势和难点"></a>异步编程的优势和难点</h2><ul>
<li>优势：基于时间驱动的非阻塞IO模型</li>
<li>难点<ul>
<li>异常处理</li>
<li>函数嵌套太深</li>
<li>阻塞代码</li>
<li>多线程的编程。有了child_process</li>
<li>异步转同步</li>
</ul>
</li>
</ul>
<h2 id="异步并发控制"><a href="#异步并发控制" class="headerlink" title="异步并发控制"></a>异步并发控制</h2><h1 id="第五章-【重点】内存控制"><a href="#第五章-【重点】内存控制" class="headerlink" title="第五章 【重点】内存控制"></a>第五章 【重点】内存控制</h1><h2 id="【重点】V8的垃圾回收机制与内存限制"><a href="#【重点】V8的垃圾回收机制与内存限制" class="headerlink" title="【重点】V8的垃圾回收机制与内存限制"></a>【重点】V8的垃圾回收机制与内存限制</h2><h1 id="第六章-理解Buffer"><a href="#第六章-理解Buffer" class="headerlink" title="第六章 理解Buffer"></a>第六章 理解Buffer</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/15/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" data-id="clmniym7j002zbb874ncl4kcf" data-title="《深入浅出Node.js》读书笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-babel-plugin-import" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/27/babel-plugin-import/" class="article-date">
  <time class="dt-published" datetime="2020-06-27T15:49:21.000Z" itemprop="datePublished">2020-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Engineering/">Engineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/27/babel-plugin-import/">按需加载 &amp; 样式自动加载 —— babel-plugin-import</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>几乎完全转自 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KjkIud4-q0Nm-YBLG6D1zg">一篇文章搞定 babel-plugin-import 插件</a> ，可以理解为 读后 &amp; 自己敲一遍 的笔记，建议直接读原文章</p>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>我们用 element-ui 或 antd 的时候，样式都支持全局引入和按需引入。按需引入需要安装一个 <a target="_blank" rel="noopener" href="https://github.com/ant-design/babel-plugin-import"><code>babel-plugin-import</code></a> 的插件，将全局的写法变成按需引入的写法。其实也是用了AST语法树转换的原理，实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">var</span> _button = <span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button/style&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;antd&quot;</span>,     <span class="comment">// 包名</span></span><br><span class="line">  <span class="string">&quot;libraryDirectory&quot;</span>: <span class="string">&quot;lib&quot;</span>, <span class="comment">// 目录，默认 lib</span></span><br><span class="line">  <span class="string">&quot;style&quot;</span>: <span class="literal">true</span>,             <span class="comment">// 是否引入 style</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它的看 <a target="_blank" rel="noopener" href="https://github.com/ant-design/babel-plugin-import#usage">文档</a></p>
<h1 id="Working-mechanism"><a href="#Working-mechanism" class="headerlink" title="Working mechanism"></a>Working mechanism</h1><h2 id="What-does-babel-plugin-import-do"><a href="#What-does-babel-plugin-import-do" class="headerlink" title="What does babel-plugin-import do"></a>What does babel-plugin-import do</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当options为以下时候：</span></span><br><span class="line">&#123; <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;antd&quot;</span>, <span class="attr">style</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>);</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">var</span> _button = <span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button/style&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">_button</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">_button</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>以这段代码为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">AutoComplete</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<h3 id="第一步-依赖收集"><a href="#第一步-依赖收集" class="headerlink" title="第一步 依赖收集"></a>第一步 依赖收集</h3><p><code>babel-plubin-import</code> 会在 <code>ImportDeclaration</code> 里将所有的 <code>specifier</code> 收集起来，详见如下 ast<br><img src="/img/AST/antd.png"><br>可以从这个 ImportDeclaration 语句中提取几个关键点：</p>
<ul>
<li>source.value: antd</li>
<li>specifier.imported.name: Button</li>
<li>specifier.imported.name: AutoComplete</li>
</ul>
<p>PS: local.name 是导入进来的别名，比如 <code>import &#123; Button as MyButton &#125; from &#39;antd&#39;</code> 的 <code>MyButton</code> ; imported.name 是真实导入的变量名</p>
<p>所以要做的事：收集 依赖名 和 依赖来源。插件的代码可以实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ImportDeclaration</span>(path, state) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; node &#125; = path;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 代码里 import 的包名</span></span><br><span class="line">  <span class="keyword">const</span> &#123; value &#125; = node.<span class="property">source</span>;</span><br><span class="line">  <span class="comment">// 配在插件 options 的包名</span></span><br><span class="line">  <span class="keyword">const</span> &#123; libraryName &#125; = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// @babel/types 工具函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; types &#125; = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 内部状态</span></span><br><span class="line">  <span class="keyword">const</span> pluginState = <span class="variable language_">this</span>.<span class="title function_">getPluginState</span>(state);</span><br><span class="line">  <span class="comment">// 判断是不是需要使用该插件的包</span></span><br><span class="line">  <span class="keyword">if</span> (value === libraryName) &#123;</span><br><span class="line">    <span class="comment">// node.specifiers 表示 import 了什么</span></span><br><span class="line">    node.<span class="property">specifiers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">spec</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是不是 ImportSpecifier 类型的节点，也就是是否是大括号的</span></span><br><span class="line">      <span class="keyword">if</span> (types.<span class="title function_">isImportSpecifier</span>(spec)) &#123;</span><br><span class="line">        <span class="comment">// 收集依赖</span></span><br><span class="line">        <span class="comment">// 也就是 pluginState.specified.Button = Button</span></span><br><span class="line">        <span class="comment">// local.name 是导入进来的别名，比如 import &#123; Button as MyButton &#125; from &#x27;antd&#x27; 的 MyButton</span></span><br><span class="line">        <span class="comment">// imported.name 是真实导入的变量名</span></span><br><span class="line">        pluginState.<span class="property">specified</span>[spec.<span class="property">local</span>.<span class="property">name</span>] = spec.<span class="property">imported</span>.<span class="property">name</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// ImportDefaultSpecifier 和 ImportNamespaceSpecifier</span></span><br><span class="line">        pluginState.<span class="property">libraryObjs</span>[spec.<span class="property">local</span>.<span class="property">name</span>] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    pluginState.<span class="property">pathsToRemove</span>.<span class="title function_">push</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历了所有的 <code>ImportDeclaration</code> 类型的节点之后，就收集好了依赖关系，下一步就是如何加载它们了。</p>
<h3 id="第二步-判断是否使用"><a href="#第二步-判断是否使用" class="headerlink" title="第二步 判断是否使用"></a>第二步 判断是否使用</h3><p>判断import进来的组件是否有在后续代码中使用，即是下面代码中 <code>createElement</code> 的第一个参数，我们需要判断收集的依赖中是否有被 createElement 使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;Button&gt;Hello&lt;/Button&gt;);</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line">React.createElement(Button, null, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>所以我们可以看下 <code>React.createElement(Button, null, &quot;Hello&quot;)</code> 的AST<br><img src="/img/AST/create.png"><br>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CallExpression(path, state) &#123;</span><br><span class="line">  const &#123; node &#125; = path;</span><br><span class="line">  const file = (path &amp;&amp; path.hub &amp;&amp; path.hub.file) || (state &amp;&amp; state.file);</span><br><span class="line">  // 方法调用者的 name</span><br><span class="line">  const &#123; name &#125; = node.callee;</span><br><span class="line">  // babel-type 工具函数</span><br><span class="line">  const &#123; types &#125; = this;</span><br><span class="line">  // 内部状态</span><br><span class="line">  const pluginState = this.getPluginState(state);</span><br><span class="line"></span><br><span class="line">  // 如果方法调用者是 Identifier 类型</span><br><span class="line">  if (types.isIdentifier(node.callee)) &#123;</span><br><span class="line">    if (pluginState.specified[name]) &#123;</span><br><span class="line">      node.callee = this.importMethod(pluginState.specified[name], file, pluginState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 遍历 arguments 找我们要的 specifier</span><br><span class="line">  node.arguments = node.arguments.map(arg =&gt; &#123;</span><br><span class="line">    const &#123; name: argName &#125; = arg;</span><br><span class="line">    if (</span><br><span class="line">      pluginState.specified[argName] &amp;&amp;</span><br><span class="line">      path.scope.hasBinding(argName) &amp;&amp;</span><br><span class="line">      path.scope.getBinding(argName).path.type === &#x27;ImportSpecifier&#x27;</span><br><span class="line">    ) &#123;</span><br><span class="line">      // 找到 specifier，调用 importMethod 方法</span><br><span class="line">      return this.importMethod(pluginState.specified[argName], file, pluginState);</span><br><span class="line">    &#125;</span><br><span class="line">    return arg;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <code>React.createElement(Button)</code> 之外，还有 <code>const btn = Button / [Button]</code> … 等多种情况会使用 Button，源码中都有对应的处理方法，感兴趣的可以自己<a target="_blank" rel="noopener" href="https://github.com/ant-design/babel-plugin-import/blob/master/src/Plugin.js#L163-L272">看一下</a></p>
<h3 id="第三步-生成引入代码（核心）"><a href="#第三步-生成引入代码（核心）" class="headerlink" title="第三步 生成引入代码（核心）"></a>第三步 生成引入代码（核心）</h3><p>即删除原来的import，引入我们生成的import。创建import的时候会用到一个插件 @babel&#x2F;helper-module-imports。后续部分建议直接看原博客<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KjkIud4-q0Nm-YBLG6D1zg">一篇文章搞定 babel-plugin-import 插件</a></p>
<h1 id="插件实现"><a href="#插件实现" class="headerlink" title="插件实现"></a>插件实现</h1><p>见原文章</p>
<p>Reference<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KjkIud4-q0Nm-YBLG6D1zg">一篇文章搞定 babel-plugin-import 插件</a><br><a target="_blank" rel="noopener" href="https://chengyuming.cn/views/webpack/AST.html">AST 团队分享</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/27/babel-plugin-import/" data-id="clmniym7c002cbb870u4l37rc" data-title="按需加载 &amp; 样式自动加载 —— babel-plugin-import" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AST详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/25/AST%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2020-06-25T15:49:21.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Engineering/">Engineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/25/AST%E8%AF%A6%E8%A7%A3/">AST详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>TODO：还有这篇 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lWj1_rPm75dXROKEMf-eQg">字节分享</a><br>几乎完全转自 <a target="_blank" rel="noopener" href="https://chengyuming.cn/views/webpack/AST.html">AST 团队分享</a> ，可以理解为 读后 &amp; 自己敲一遍 的笔记</p>
<h1 id="What-Why"><a href="#What-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h1><ul>
<li>What: 抽象语法树（Abstract Syntax Tree，简称 AST）是<strong>源代码的抽象语法结构的树状表现形式</strong></li>
<li>Why:<ul>
<li>webpack、eslint 等很多工具库的核心都是通过抽象语法树来实现对代码的检查、分析等操作</li>
<li>浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作，所以将 js 转化为抽象语法树更利于程序的分析</li>
</ul>
</li>
<li>一个简单的例子:<br><img src="/img/AST/AST.png"><ul>
<li>首先<strong>一段</strong>代码转换成的抽象语法树是一个对象，该对象会有一个顶级的 type 属性 Program；第二个属性是 body 是一个数组</li>
<li>body 数组中存放的每一项都是一个对象，里面包含了所有的对于该语句的描述信息</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type: 描述该语句的类型  --&gt; 变量声明的语句</span><br><span class="line">kind: 变量声明的关键字  --&gt; var</span><br><span class="line">declaration: 声明内容的数组，里面每一项也是一个对象</span><br><span class="line">  type: 描述该语句的类型</span><br><span class="line">  id: 描述变量名称的对象</span><br><span class="line">      type: 定义</span><br><span class="line">      name: 变量的名字</span><br><span class="line">  init: 初始化变量值的对象</span><br><span class="line">      type: 类型</span><br><span class="line">      value: 值 &quot;is tree&quot; 不带引号</span><br><span class="line">      row:  &quot;\&quot;is tree&quot;\&quot; 带引号</span><br></pre></td></tr></table></figure>

<h1 id="词法分析和语法分析"><a href="#词法分析和语法分析" class="headerlink" title="词法分析和语法分析"></a>词法分析和语法分析</h1><p><code>JavaScript</code> 是<strong>解释型语言</strong>，一般通过 <code>词法分析 -&gt; 语法分析 -&gt; 语法树</code>，就可以开始解释执行了。从 code 分析成 AST ，我们可以在<a target="_blank" rel="noopener" href="http://esprima.org/">这里</a>看到效果</p>
<ul>
<li>词法分析：也叫扫描 (scans)，是将字符流转换为记号流 (tokens)，它会读取我们的代码然后按照一定的规则合成一个个的标识 (scans: code &#x3D;&gt; tokens)<br>。当词法分析源代码的时候，它会一个一个字符的读取代码；当它遇到空格、操作符，或者特殊符号的时候，它会认为一个话已经完成了。比如说：var a &#x3D; 2 ，这段代码通常会被分解成 var、a、&#x3D;、2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Keyword&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;var&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Identifier&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Punctuator&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;=&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Numeric&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;2&#x27;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>语法分析：也称解析器，将词法分析出来的数组转换成树的形式，同时验证语法。语法如果有错的话，抛出语法错误 (analyze: tokens &#x3D;&gt; syntax)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>syntax &#x3D;&gt; tree</li>
</ul>
<h1 id="What-can-AST-do"><a href="#What-can-AST-do" class="headerlink" title="What can AST do"></a>What can AST do</h1><ul>
<li>语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等</li>
<li>代码混淆压缩</li>
<li>优化变更代码，改变代码结构等</li>
</ul>
<p>eg. 有个函数 <code>function a() &#123;&#125;</code> 我想把它变成 <code>function b() &#123;&#125;</code><br>eg. 在 webpack 中代码编译完成后 <code>require(&#39;a&#39;)</code> –&gt; <code>__webapck__require__(&quot;*/**/a.js&quot;)</code></p>
<h1 id="The-analysis-process-of-AST"><a href="#The-analysis-process-of-AST" class="headerlink" title="The analysis process of AST"></a>The analysis process of AST</h1><h2 id="How-to-analysis"><a href="#How-to-analysis" class="headerlink" title="How to analysis"></a>How to analysis</h2><p>先说结果：AST 是<strong>深度优先遍历</strong><br>比如说一段代码 <code>function getUser() &#123;&#125;</code>，我们把函数名字更改为 hello<br>推荐另一个常用的 AST 在线转换网站<a target="_blank" rel="noopener" href="https://astexplorer.net/">ast explorer</a>；可以在网站看转换效果，也可以用下面的工具看效果</p>
<ul>
<li>工具 (这三个是操作 AST 的三个重要模块，也是实现 babel 的核心依赖)<ul>
<li>esprima：code &#x3D;&gt; ast</li>
<li>estraverse: traverse ast</li>
<li>escodegen: ast &#x3D;&gt; code</li>
</ul>
</li>
<li>实例代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">&#x27;esprima&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">&#x27;estraverse&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function getUser() &#123;&#125;`</span></span><br><span class="line"><span class="comment">// 生成 AST</span></span><br><span class="line"><span class="keyword">const</span> ast = esprima.<span class="title function_">parseScript</span>(code)</span><br><span class="line"><span class="comment">// 转换 AST，只会遍历 type 属性</span></span><br><span class="line"><span class="comment">// traverse 方法中有进入和离开两个钩子函数</span></span><br><span class="line">estraverse.<span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title function_">enter</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enter -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">leave</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;leave -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>打印结果<br><img src="/img/AST/output.png"></li>
<li>所以是深度优先遍历<br><img src="/img/AST/tree.png"></li>
</ul>
<h2 id="Demo-修改函数名字"><a href="#Demo-修改函数名字" class="headerlink" title="Demo: 修改函数名字"></a>Demo: 修改函数名字</h2><p>此时我们发现函数的名字在 <code>type</code> 为 <code>Identifier</code> 的时候就是该函数的名字，我们就可以直接修改它便可实现一个更改函数名字的 AST 工具</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换树</span></span><br><span class="line">estraverse.<span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="comment">// 进入离开修改都是可以的</span></span><br><span class="line">  <span class="title function_">enter</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enter -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="string">&#x27;Identifier&#x27;</span>) &#123;</span><br><span class="line">      node.<span class="property">name</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">leave</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;leave -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 生成新的代码</span></span><br><span class="line"><span class="keyword">const</span> result = escodegen.<span class="title function_">generate</span>(ast)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// function hello() &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="Application-of-AST"><a href="#Application-of-AST" class="headerlink" title="Application of AST"></a>Application of AST</h1><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><h3 id="The-working-mechanism-of-babel"><a href="#The-working-mechanism-of-babel" class="headerlink" title="The working mechanism of babel"></a>The working mechanism of babel</h3><blockquote>
<p>babel 的主要作用就是 Es6 代码转换为 Es5 的代码，以兼容所有浏览器，主要原理就是运用了 AST。有个 class 语法转为 ES5 语法的 demo，见博客 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016706589?utm_medium=referral&utm_source=tuicool">AST 抽象语法树</a></p>
</blockquote>
<p>babel两个工具包重要的包： <code>@babel/core</code> (打通webpack和babel的一个通道)、<code>@babel/preset-env</code> (翻译器) (还有一个@babel&#x2F;polyfill（添加ES6中的新函数新变量，eg. Promise和map）)。当我们配置 babel 的时候，不管是在 <code>.babelrc</code> 或者 <code>babel.config.js</code> 文件里面配置的都有 presets 和 plugins 两个配置项</p>
<h4 id="presets和plugins的区别"><a href="#presets和plugins的区别" class="headerlink" title="presets和plugins的区别"></a>presets和plugins的区别</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们配置了 presets 中有 <code>@babel/preset-env</code>，那么 <code>@babel/core</code> 就会去找 <code>preset-env</code> 预设的插件包，它是一套预设好的插件配置。</p>
<p><code>@babel/core</code>并不会去转换代码，只提供一些核心 API，真正的代码转换工作由插件或者预设来完成，比如要转换箭头函数，会用到这个 plugin：<code>@babel/plugin-transform-arrow-functions</code>，当需要转换的要求增加时，我们不可能去一一配置相应的 plugin，这个时候就可以用到预设了，也就是 presets。<strong>presets 是 plugins 的集合</strong>，一个 presets 内部包含了很多 plugin</p>
<h4 id="babel中转换代码一个demo"><a href="#babel中转换代码一个demo" class="headerlink" title="babel中转换代码一个demo"></a>babel中转换代码一个demo</h4><p>现在我们有一个箭头函数，要想把它转成普通函数，我们就可以直接这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const fn = (a, b) =&gt; a + b`</span></span><br><span class="line"><span class="comment">// babel 有 transform 方法会帮我们自动遍历，使用相应的预设或者插件转换相应的代码</span></span><br><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">code</span>)</span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line"><span class="comment">// &quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">// var fn = function fn() &#123; return a + b; &#125;;</span></span><br></pre></td></tr></table></figure>
<p>此时我们可以看到最终代码会被转成普通函数，但是我们，只需要箭头函数转通函数的功能，不需要用这么大一套包，只需要一个箭头函数转普通函数的包，我们其实是可以在 <code>node_modules</code> 下面找到有个叫做 <code>plugin-transform-arrow-functions</code> 的插件，这个插件是专门用来处理 箭头函数的，我们就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@babel/plugin-transform-arrow-functions&#x27;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">code</span>)</span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line"><span class="comment">// const fn = function () &#123; return a + b; &#125;;</span></span><br></pre></td></tr></table></figure>
<p>我们可以从打印结果发现此时并没有转换我们变量的声明方式还是 const 声明，只是转换了箭头函数</p>
<h3 id="编写一个箭头函数转普通函数的babel插件"><a href="#编写一个箭头函数转普通函数的babel插件" class="headerlink" title="编写一个箭头函数转普通函数的babel插件"></a>编写一个箭头函数转普通函数的babel插件</h3><p>首先应该看 <a target="_blank" rel="noopener" href="https://juejin.im/post/5b14257ef265da6e5546b14b">Babel插件开发入门指南</a><br>现在我们来个实战把 <code>const fn = (a, b) =&gt; a + b</code> 转换为 <code>const fn = function(a, b) &#123; return a + b &#125;</code></p>
<h4 id="分析-AST-结构"><a href="#分析-AST-结构" class="headerlink" title="分析 AST 结构"></a>分析 AST 结构</h4><p>首先我们在在线分析 AST 的网站上分析 <code>const fn = (a, b) =&gt; a + b</code> 和 <code>const fn = function(a, b) &#123; return a + b &#125;</code> 看两者语法树的区别<br><img src="/img/AST/code.png"></p>
<p>分析可得：</p>
<ul>
<li>变成普通函数之后他就不叫箭头函数了 <code>ArrowFunctionExpression</code>，而是函数表达式了 <code>FunctionExpression</code></li>
<li>所以首先我们要把 箭头函数表达式(<code>ArrowFunctionExpression</code>) 转换为 函数表达式(<code>FunctionExpression</code>)</li>
<li>要把 二进制表达式(<code>BinaryExpression</code>) 放到一个 代码块中(<code>BlockStatement</code>)的 <code>ExpressionStatement</code>&#x2F; <code>ReturnStatement</code> 中。</li>
<li>其实我们要做就是把一棵树变成另外一颗树，说白了其实就是拼成另一颗树的结构，然后生成新的代码，就可以完成代码的转换</li>
</ul>
<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>在 babel 中，我们开发 plugins 的时候要用到<strong>访问者模式</strong>，就是说在访问到某一个路径的时候进行匹配，然后在对这个节点进行修改。<strong>这里的节点指的是AST树中的节点</strong>，比如下面是访问到 ArrowFunctionExpression 节点就执行下面的 ArrowFunctionExpression() 函数</p>
<p>那么我们就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const fn = (a, b) =&gt; a + b`</span> <span class="comment">// 转换后 const fn = function(a, b) &#123; return a + b &#125;</span></span><br><span class="line"><span class="keyword">const</span> arrowFnPlugin = &#123;</span><br><span class="line">  <span class="comment">// 访问者模式</span></span><br><span class="line">  <span class="attr">visitor</span>: &#123;</span><br><span class="line">    <span class="comment">// 当访问到某个路径的时候进行匹配，比如下面是访问到 ArrowFunctionExpression 就执行下面的 ArrowFunctionExpression() 函数</span></span><br><span class="line">    <span class="title class_">ArrowFunctionExpression</span>(path) &#123;</span><br><span class="line">      <span class="comment">// 拿到节点</span></span><br><span class="line">      <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ArrowFunctionExpression -&gt; node&#x27;</span>, node)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [arrowFnPlugin],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br></pre></td></tr></table></figure>

<h4 id="修改-AST-结构"><a href="#修改-AST-结构" class="headerlink" title="修改 AST 结构"></a>修改 AST 结构</h4><p>此时我们拿到的结果是这样的节点结果是 <a target="_blank" rel="noopener" href="https://chengyuming.cn/json/arrowFn.json">这样的</a>，其实就是 <code>ArrowFunctionExpression</code> 的 AST，此时我们要做的是把 <code>ArrowFunctionExpression</code> 的结构替换成 <code>FunctionExpression的结构</code>。但要我们自己手写替换得毫无差错是很麻烦的，所以 babel 为我们提供了一个神仙工具叫做 <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-types"><code>@babel/types</code></a> <a target="_blank" rel="noopener" href="https://www.babeljs.cn/docs/babel-types">中文版</a></p>
<p><code>@babel/types</code> 有两个作用：</p>
<ul>
<li>判断当前节点是不是某种特定节点（eg. 相当于之前的 node.type &#x3D;&#x3D;&#x3D; ‘ArrowFunctionExpression’ ）</li>
<li>生成对应的表达式</li>
</ul>
<p>那么接下来我们就开始生成一个 FunctionExpression，然后把之前的 <code>ArrowFunctionExpression</code> 替换掉，我们可以看 <code>@babel/types</code> 文档，找到 functionExpression 方法，该方法接受相应的参数我们传递过去即可生成一个 <code>FunctionExpression</code></p>
<blockquote>
<p>t.functionExpression(id, params, body, generator, async)</p>
</blockquote>
<ul>
<li>id: Identifier (default: null) id 可传递 null</li>
<li>params: Array<LVal> (required) 函数参数，可以把之前的参数拿过来</li>
<li>body: BlockStatement (required) 函数体，接受一个 BlockStatement 我们需要生成一个</li>
<li>generator: boolean (default: false) 是否为 generator 函数，当然不是了</li>
<li>async: boolean (default: false) 是否为 async 函数，肯定不是了</li>
</ul>
<p>还需要生成一个 <code>BlockStatement</code>，我们接着看文档找到 <code>BlockStatement</code> 接受的参数</p>
<blockquote>
<p>t.blockStatement(body, directives)</p>
</blockquote>
<p>看文档说明，blockStatement 接受一个 body，那我们把之前的 body 拿过来就可以直接用，不过这里 body 接受一个数组</p>
<p>我们细看 AST 结构，函数表达式中的 <code>BlockStatement</code> 中的 body 是一个 <code>ReturnStatement</code>，所以我们还需要生成一个 <code>ReturnStatement</code></p>
<p>现在我们就可以改写 AST 了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const fn = (a, b) =&gt; a + b`</span> <span class="comment">// const fn = function(a, b) &#123; return a + b &#125;</span></span><br><span class="line"><span class="keyword">const</span> arrowFnPlugin = &#123;</span><br><span class="line">  <span class="comment">// 访问者模式</span></span><br><span class="line">  <span class="attr">visitor</span>: &#123;</span><br><span class="line">    <span class="comment">// 当访问到某个路径的时候进行匹配</span></span><br><span class="line">    <span class="title class_">ArrowFunctionExpression</span>(path) &#123;</span><br><span class="line">      <span class="comment">// 拿到节点然后替换节点</span></span><br><span class="line">      <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ArrowFunctionExpression -&gt; node&#x27;</span>, node)</span><br><span class="line">      <span class="comment">// 拿到函数的参数</span></span><br><span class="line">      <span class="keyword">const</span> params = node.<span class="property">params</span></span><br><span class="line">      <span class="keyword">const</span> body = node.<span class="property">body</span></span><br><span class="line">      <span class="keyword">const</span> functionExpression = t.<span class="title function_">functionExpression</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        params,</span><br><span class="line">        t.<span class="title function_">blockStatement</span>([body])</span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 替换原来的函数</span></span><br><span class="line">      path.<span class="title function_">replaceWith</span>(functionExpression)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [arrowFnPlugin],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">code</span>) <span class="comment">// const fn = function (a, b) &#123; return a + b; &#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>我们知道在剪头函数中是可以省略 return 关键字，我们上面是处理了省略关键字的写法，但是如果用户写了 return 关键字后，我们写的这个插件就有问题了，所以我们可以在优化一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">a, b</span>) =&gt; &#123; retrun a + b &#125; -&gt; <span class="keyword">const</span> fn = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure>
<p>观察代码我们发现，我们就不需要把 body 转换成 <code>blockStatement</code> 了，直接放过去就可以了，那么我们就可以这么写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ArrowFunctionExpression</span>(path) &#123;</span><br><span class="line">  <span class="comment">// 拿到节点然后替换节点</span></span><br><span class="line">  <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ArrowFunctionExpression -&gt; node&quot;</span>, node)</span><br><span class="line">  <span class="comment">// 拿到函数的参数</span></span><br><span class="line">  <span class="keyword">const</span> params = node.<span class="property">params</span></span><br><span class="line">  <span class="keyword">let</span> body = node.<span class="property">body</span></span><br><span class="line">  <span class="comment">// 判断是不是 blockStatement，不是的话让他变成 blockStatement</span></span><br><span class="line">  <span class="keyword">if</span> (!t.<span class="title function_">isBlockStatement</span>(body)) &#123;</span><br><span class="line">    body = t.<span class="title function_">blockStatement</span>([body])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> functionExpression = t.<span class="title function_">functionExpression</span>(<span class="literal">null</span>, params, body)</span><br><span class="line">  <span class="comment">// 替换原来的函数</span></span><br><span class="line">  path.<span class="title function_">replaceWith</span>(functionExpression)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写一个claas转ES5的babel插件"><a href="#编写一个claas转ES5的babel插件" class="headerlink" title="编写一个claas转ES5的babel插件"></a>编写一个claas转ES5的babel插件</h3><p>见 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016706589?utm_medium=referral&utm_source=tuicool">AST 抽象语法树</a><br>类似的实际插件是 <code>@babel/plugin-transform-classes</code></p>
<h2 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h2><p>我们用 element-ui 或 antd 的时候，样式都支持全局引入和按需引入。按需引入需要安装一个 <code>babel-plugin-import</code> 的插件，将全局的写法变成按需引入的写法。其实也是用了AST语法树转换的原理，实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">var</span> _button = <span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button/style&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>(这个插件详见另一篇博客 <a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/06/27/babel-plugin-import/">按需加载 &amp; 样式自动加载 —— babel-plugin-import</a>)</p>
<h2 id="babylon"><a href="#babylon" class="headerlink" title="babylon"></a>babylon</h2><blockquote>
<p>在 babel 官网上有一句话 <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babylon">Babylon</a> is a JavaScript parser used in Babel。（即是Babel 的解析引擎）</p>
</blockquote>
<h3 id="babel-与-babylon-的关系"><a href="#babel-与-babylon-的关系" class="headerlink" title="babel 与 babylon 的关系"></a>babel 与 babylon 的关系</h3><p>from <a target="_blank" rel="noopener" href="http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/">alloyteam-剖析babel</a> ：<br>Babel 使用的引擎是 babylon，babylon 并非由 babel 团队自己开发的，而是 fork 的 acorn 项目，acorn 的项目本人在很早之前在兴趣部落 1.0 在构建中使用，为了是做一些代码的转换，是很不错的一款引擎，不过 acorn 引擎只提供基本的解析 ast 的能力，遍历还需要配套的 acorn-travesal, 替换节点需要使用 acorn-，而这些开发，在 Babel 的插件体系开发下，变得一体化了 </p>
<h3 id="使用-babylon-编写一个数组扩展运算符-转-Es5-语法的插件"><a href="#使用-babylon-编写一个数组扩展运算符-转-Es5-语法的插件" class="headerlink" title="使用 babylon 编写一个数组扩展运算符 转 Es5 语法的插件"></a>使用 babylon 编写一个数组扩展运算符 转 Es5 语法的插件</h3><p>把 <code>const arr = [ ...arr1, ...arr2 ]</code> 转成 <code>var arr = [].concat(arr1, arr2)</code></p>
<p>我们使用 babylon 的话就不需要使用 <code>@babel/core</code> 了，只需要用到他里面的 <code>traverse</code> 和 <code>generator</code>，用到的包有 <code>babylon</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>、<code>@babel/types</code></p>
<h3 id="分析语法树"><a href="#分析语法树" class="headerlink" title="分析语法树"></a>分析语法树</h3><p>看一下两棵语法树的区别<br><img src="/img/AST/bablon.png"><br>根据上图我们分析得出：</p>
<ul>
<li>两棵树都是变量声明的方式，不同的是他们声明的关键字不一样</li>
<li>他们初始化变量值的时候是不一样的，一个数组表达式（ArrayExpression）另一个是调用表达式（CallExpression）</li>
<li>那我们要做的就很简单了，就是把 数组表达式转换为调用表达式就可以</li>
</ul>
<h3 id="分析类型"><a href="#分析类型" class="headerlink" title="分析类型"></a>分析类型</h3><p>这段代码的核心生成一个 callExpression 调用表达式，所以对应官网上的类型，我们分析需要用到的 api</p>
<ul>
<li>先来分析 init 里面的，首先是 callExpression<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; callee  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;Expression | SpreadElement | JSXNamespacedName&gt;</span>&#125; source (required)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">callExpression</span>(callee, <span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure></li>
<li>对应语法树上 callee 是一个 MemberExpression，所以要生成一个成员表达式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; object  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">if computed then Expression else Identifier</span>&#125; property (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; computed (default: false)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; optional (default: null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">memberExpression</span>(object, property, computed, optional)</span><br></pre></td></tr></table></figure></li>
<li>在 callee 的 object 是一个 ArrayExpression 数组表达式，是一个空数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;null | Expression | SpreadElement&gt;</span>&#125; elements  (default: [])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">arrayExpression</span>(elements)</span><br></pre></td></tr></table></figure></li>
<li>对了里面的东西分析完了，我们还要生成 VariableDeclarator 和 VariableDeclaration 最终生成新的语法树<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">LVal</span>&#125; id  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; init (default: null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">variableDeclarator</span>(id, init)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">&quot;var&quot; | &quot;let&quot; | &quot;const&quot;</span>&#125; kind  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;VariableDeclarator&gt;</span>&#125; declarations (required)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">variableDeclaration</span>(kind, declarations)</span><br></pre></td></tr></table></figure>
其实倒着分析语法树，分析完怎么写也就清晰了，那么我们开始上代码吧</li>
</ul>
<h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">&#x27;babylon&#x27;</span>)</span><br><span class="line"><span class="comment">// 使用 babel 提供的包，traverse 和 generator 都是被暴露在 default 对象上的</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).<span class="property">default</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">&#x27;@babel/generator&#x27;</span>).<span class="property">default</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const arr = [ ...arr1, ...arr2 ]`</span> <span class="comment">// var arr = [].concat(arr1, arr2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.<span class="title function_">parse</span>(code, &#123;</span><br><span class="line">  <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换树</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">VariableDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">    <span class="keyword">const</span> declarations = node.<span class="property">declarations</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;VariableDeclarator -&gt; declarations&#x27;</span>, declarations)</span><br><span class="line">    <span class="keyword">const</span> kind = <span class="string">&#x27;var&#x27;</span></span><br><span class="line">    <span class="comment">// 边界判定</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">kind</span> !== kind &amp;&amp; declarations.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; t.<span class="title function_">isArrayExpression</span>(declarations[<span class="number">0</span>].<span class="property">init</span>)) &#123;</span><br><span class="line">      <span class="comment">// 取得之前的 elements</span></span><br><span class="line">      <span class="keyword">const</span> args = declarations[<span class="number">0</span>].<span class="property">init</span>.<span class="property">elements</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">argument</span>)</span><br><span class="line">      <span class="keyword">const</span> callee = t.<span class="title function_">memberExpression</span>(t.<span class="title function_">arrayExpression</span>(), t.<span class="title function_">identifier</span>(<span class="string">&#x27;concat&#x27;</span>), <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">const</span> init = t.<span class="title function_">callExpression</span>(callee, args)</span><br><span class="line">      <span class="keyword">const</span> declaration = t.<span class="title function_">variableDeclarator</span>(declarations[<span class="number">0</span>].<span class="property">id</span>, init)</span><br><span class="line">      <span class="keyword">const</span> variableDeclaration = t.<span class="title function_">variableDeclaration</span>(kind, [declaration])</span><br><span class="line">      path.<span class="title function_">replaceWith</span>(variableDeclaration)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="具体语法书"><a href="#具体语法书" class="headerlink" title="具体语法书"></a>具体语法书</h1><p>和抽象语法树相对的是具体语法树（Concrete Syntax Tree）简称 CST（通常称作分析树）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。可参考抽象语法树和具体语法树有什么区别？</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>关于 node 类型，全集大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(parameter) <span class="attr">node</span>: <span class="title class_">Identifier</span> | <span class="title class_">SimpleLiteral</span> | <span class="title class_">RegExpLiteral</span> | <span class="title class_">Program</span> | <span class="title class_">FunctionDeclaration</span> | <span class="title class_">FunctionExpression</span> | </span><br><span class="line"><span class="title class_">ArrowFunctionExpression</span> | <span class="title class_">SwitchCase</span> | <span class="title class_">CatchClause</span> | <span class="title class_">VariableDeclarator</span> | <span class="title class_">ExpressionStatement</span> | <span class="title class_">BlockStatement</span> | </span><br><span class="line"><span class="title class_">EmptyStatement</span> | <span class="title class_">DebuggerStatement</span> | <span class="title class_">WithStatement</span> | <span class="title class_">ReturnStatement</span> | <span class="title class_">LabeledStatement</span> | <span class="title class_">BreakStatement</span> | </span><br><span class="line"><span class="title class_">ContinueStatement</span> | <span class="title class_">IfStatement</span> | <span class="title class_">SwitchStatement</span> | <span class="title class_">ThrowStatement</span> | <span class="title class_">TryStatement</span> | <span class="title class_">WhileStatement</span> | <span class="title class_">DoWhileStatement</span> | </span><br><span class="line"><span class="title class_">ForStatement</span> | <span class="title class_">ForInStatement</span> | <span class="title class_">ForOfStatement</span> | <span class="title class_">VariableDeclaration</span> | <span class="title class_">ClassDeclaration</span> | <span class="title class_">ThisExpression</span> | </span><br><span class="line"><span class="title class_">ArrayExpression</span> | <span class="title class_">ObjectExpression</span> | <span class="title class_">YieldExpression</span> | <span class="title class_">UnaryExpression</span> | <span class="title class_">UpdateExpression</span> | <span class="title class_">BinaryExpression</span> | </span><br><span class="line"><span class="title class_">AssignmentExpression</span> | <span class="title class_">LogicalExpression</span> | <span class="title class_">MemberExpression</span> | <span class="title class_">ConditionalExpression</span> | <span class="title class_">SimpleCallExpression</span> | </span><br><span class="line"><span class="title class_">NewExpression</span> | <span class="title class_">SequenceExpression</span> | <span class="title class_">TemplateLiteral</span> | <span class="title class_">TaggedTemplateExpression</span> | <span class="title class_">ClassExpression</span> | <span class="title class_">MetaProperty</span> | </span><br><span class="line"><span class="title class_">AwaitExpression</span> | <span class="title class_">Property</span> | <span class="title class_">AssignmentProperty</span> | <span class="title class_">Super</span> | <span class="title class_">TemplateElement</span> | <span class="title class_">SpreadElement</span> | <span class="title class_">ObjectPattern</span> |</span><br><span class="line"> <span class="title class_">ArrayPattern</span> | <span class="title class_">RestElement</span> | <span class="title class_">AssignmentPattern</span> | <span class="title class_">ClassBody</span> | <span class="title class_">MethodDefinition</span> | <span class="title class_">ImportDeclaration</span> | </span><br><span class="line"> <span class="title class_">ExportNamedDeclaration</span> | <span class="title class_">ExportDefaultDeclaration</span> | <span class="title class_">ExportAllDeclaration</span> | <span class="title class_">ImportSpecifier</span> | </span><br><span class="line"> <span class="title class_">ImportDefaultSpecifier</span> | <span class="title class_">ImportNamespaceSpecifier</span> | <span class="title class_">ExportSpecifier</span></span><br></pre></td></tr></table></figure>
<p>Babel 有文档对 AST 树的详细定义，可参考<a target="_blank" rel="noopener" href="https://github.com/babel/babylon/blob/master/ast/spec.md">这里</a></p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b14257ef265da6e5546b14b">Babel插件开发入门指南</a><br><a target="_blank" rel="noopener" href="https://chengyuming.cn/views/webpack/AST.html">AST 团队分享</a><br><a target="_blank" rel="noopener" href="http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/">alloyteam-剖析babel</a><br><a target="_blank" rel="noopener" href="https://cheogo.github.io/learn-javascript/201709/runtime.html">JavaScript 语法解析、AST、V8、JIT</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangpb123/article/details/84799198">详解AST抽象语法树</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/25/AST%E8%AF%A6%E8%A7%A3/" data-id="clmniym630001bb87463t6m1m" data-title="AST详解" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-渲染方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/27/%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2020-05-27T08:50:21.000Z" itemprop="datePublished">2020-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/27/%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/">渲染方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="长列表-无限下拉列表-渲染"><a href="#长列表-无限下拉列表-渲染" class="headerlink" title="长列表 &#x2F; 无限下拉列表 渲染"></a>长列表 &#x2F; 无限下拉列表 渲染</h1><p>考虑到性能，我们不可能将一个长列表（甚至是一个无限下拉列表）的所有列表元素都进行渲染，应该是只渲染部分数据并随着下拉渲染新数据</p>
<h2 id="方案一：Intersection-Observer-padding"><a href="#方案一：Intersection-Observer-padding" class="headerlink" title="方案一：Intersection Observer + padding"></a>方案一：Intersection Observer + padding</h2><p>该方案来自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/X2ltQyp3W0othLv_m6-Ydg">云音乐-一个简洁、有趣的无限下拉方案</a></p>
<h3 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a>Intersection Observer</h3><p>详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">MDN</a>，建议全都读完</p>
<p>一直以来，<strong>检测元素的可视状态或者两个元素的相对可视状态</strong>都不是件容易事。传统的各种方案不但复杂，而且性能成本很高，比如需要监听滚动事件，然后查询 DOM , 获取元素高度、位置，计算距离视窗高度等等。</p>
<p>这就是 Intersection Observer 要解决的问题。它为开发人员提供一种便捷的新方法来异步查询元素相对于其他元素或视窗的位置，消除了昂贵的 DOM 查询和样式读取成本</p>
<p>它不能告诉你的一件事情是 (两个元素的)重叠部分的准确像素个数或者重叠的像素属于哪一个元素。然而这个API覆盖最广的最常用的使用方式是 <strong>如果两个元素发生的交集部分在N%左右，我需要做处理一些事情(执行回调)</strong></p>
<blockquote>
<p>在 Safari 上兼容性较差，需要 12.2 及以上才兼容，否则需配合 polyfill  使用</p>
</blockquote>
<p>一些应用场景：</p>
<ul>
<li>当页面滚动时，懒加载图片或其他内容。</li>
<li>实现“可无限滚动”网站，也就是当用户滚动网页时直接加载更多内容，无需翻页。</li>
<li>为计算广告收益，检测其广告元素的曝光情况。</li>
<li>根据用户是否已滚动到相应区域来灵活开始执行任务或动画</li>
</ul>
<h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><ol>
<li>创建一个 IntersectionObserver对象。</li>
</ol>
<ul>
<li>root必须是目标元素的父级元素；如果未指定或者为null，则默认为浏览器视窗</li>
<li>rootMargin是root元素的外边距。类似于css中的 margin 属性</li>
<li>threshold。目标(target)元素与根(root)元素之间的交叉度是交叉比(intersection ratio)。这是目标(target)元素相对于根(root)的交集百分比的表示，它的取值在0.0和1.0之间。阈值为1.0意味着目标元素完全出现在root选项指定的元素中可见时，回调函数将会被执行。可以是单一的number也可以是number数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>), </span><br><span class="line">  <span class="attr">rootMargin</span>: <span class="string">&#x27;0px&#x27;</span>, </span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>每个观察者配置一个目标。每当目标满足该IntersectionObserver指定的threshold值，回调被调用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#listItem&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure></li>
<li>回调函数。回调接收 IntersectionObserverEntry对象和观察者的列表：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params">entries, observer</span>) &#123; </span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 这里的 entry 是 IntersectionObserverEntry 对象，entry.target 是目标元素</span></span><br><span class="line">    <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">    <span class="comment">//   entry.isIntersecting</span></span><br><span class="line">    <span class="comment">//   entry.rootBounds</span></span><br><span class="line">    <span class="comment">//   entry.target</span></span><br><span class="line">    <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
entry的属性大概是这样：<br><img src="/img/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/entry.png"><br>详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry">MDN-IntersectionObserverEntry</a></li>
</ol>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>总体思路：利用 Intersection Observer 来监测相关元素的滚动位置，异步监听，尽可能得减少 DOM 操作，触发回调，然后去获取新的数据来更新页面元素，并且用调整容器 padding 来替代了本该越来越多的 DOM 元素，最终实现列表滚动、无限下拉。具体如下：</p>
<ol>
<li>监听一个固定长度列表的首尾元素是否进入视窗<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 观察者创建</span><br><span class="line">this.observer = new IntersectionObserver(callback, options);</span><br><span class="line"></span><br><span class="line">// 观察列表第一个以及最后一个元素</span><br><span class="line">this.observer.observe(this.firstItem);</span><br><span class="line">this.observer.observe(this.lastItem);</span><br><span class="line"></span><br><span class="line">const callback = (entries) =&gt; &#123;</span><br><span class="line">  entries.forEach((entry) =&gt; &#123;</span><br><span class="line">    if (entry.target.id === firstItemId) &#123;</span><br><span class="line">      // 当第一个元素进入视窗</span><br><span class="line">    &#125; else if (entry.target.id === lastItemId) &#123;</span><br><span class="line">      // 当最后一个元素进入视窗</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>更新当前页面内渲染的第一个元素对应的序号(firstIndex)。我们用一个数组来维护需要渲染到页面中的数据。数组的长度会随着不断请求新的数据而不断变大，而渲染的始终是其中一定数量的元素，比如 20 个。那么：</li>
</ol>
<ul>
<li>最开始渲染的是数组中序号为 0 - 19 的元素，即此时对应的 firstIndex 为 0；</li>
<li>当序号为 19 的元素（即上一步的 lastItem ）进入视窗时，我们就会往后渲染 10 个元素，即渲染序号为 10 - 29 的元素，那么此时的 firstIndex 为 10；</li>
<li>下一次就是，当序号为 29 的元素进入视窗时，继续往后渲染 10个元素，即渲染序号为 20 - 39 的元素，那么此时的 firstIndex 为 20，以此类推。。。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 我们对原先的 firstIndex 做了缓存</span><br><span class="line">const &#123; currentIndex &#125; = this.domDataCache;</span><br><span class="line"></span><br><span class="line">// 以全部容器内所有元素的一半作为每一次渲染的增量</span><br><span class="line">const increment = Math.floor(this.listSize / 2);</span><br><span class="line"></span><br><span class="line">let firstIndex;</span><br><span class="line"></span><br><span class="line">if (isScrollDown) &#123;</span><br><span class="line">  // 向下滚动时序号增加</span><br><span class="line">  firstIndex = currentIndex + increment;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 向上滚动时序号减少</span><br><span class="line">  firstIndex = currentIndex - increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>根据上述序号，获取目标数据元素，列表内容重新渲染成对应内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const renderFunction = (firstIndex) =&gt; &#123;</span><br><span class="line">  // offset = firstIndex, limit = 10 =&gt; getData</span><br><span class="line">  // getData Done =&gt;  new dataItems =&gt; render DOM</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li>
<li>容器 padding 调整，模拟滚动实现<br>其实不用这一步也可以，直接获取了 10 个新的数据元素之后，再塞 10 个新的 DOM 元素到页面中去来渲染这些数据。但是 DOM 会越来越多，页面DOM太多可能会有性能问题。所以这里的方案是：用原来已有的 DOM 元素去渲染，替换掉已经离开视窗、不可见的数据元素；而本该由更多 DOM 元素进一步撑开容器高度的部分，我们用 padding 填充来模拟实现。</li>
</ol>
<ul>
<li>向下滚动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// padding的增量 = 每一个item的高度 x 新的数据项的数目</span><br><span class="line">const remPaddingsVal = itemHeight * (Math.floor(this.listSize / 2));</span><br><span class="line"></span><br><span class="line">if (isScrollDown) &#123;</span><br><span class="line">  // paddingTop新增，填充顶部位置</span><br><span class="line">  newCurrentPaddingTop = currentPaddingTop + remPaddingsVal;</span><br><span class="line"></span><br><span class="line">  if (currentPaddingBottom === 0) &#123;</span><br><span class="line">    newCurrentPaddingBottom = 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果原来有paddingBottom则减去，会有滚动到底部的元素进行替代</span><br><span class="line">    newCurrentPaddingBottom = currentPaddingBottom - remPaddingsVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>向上滚动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// padding的增量 = 每一个item的高度 x 新的数据项的数目</span><br><span class="line">const remPaddingsVal = itemHeight * (Math.floor(this.listSize / 2));</span><br><span class="line"></span><br><span class="line">if (!isScrollDown) &#123;</span><br><span class="line">  // paddingBottom新增，填充底部位置</span><br><span class="line">  newCurrentPaddingBottom = currentPaddingBottom + remPaddingsVal;</span><br><span class="line"></span><br><span class="line">  if (currentPaddingTop === 0) &#123;</span><br><span class="line">    newCurrentPaddingTop = 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果原来有paddingTop则减去，会有滚动到顶部的元素进行替代</span><br><span class="line">    newCurrentPaddingTop = currentPaddingTop - remPaddingsVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后是 padding 设置更新以及相关缓存数据更新<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 容器padding重新设置</span><br><span class="line">this.updateContainerPadding(&#123;</span><br><span class="line">  newCurrentPaddingBottom,</span><br><span class="line">  newCurrentPaddingTop</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// DOM元素相关数据缓存更新</span><br><span class="line">this.updateDomDataCache(&#123;</span><br><span class="line">    currentPaddingTop: newCurrentPaddingTop,</span><br><span class="line">  currentPaddingBottom: newCurrentPaddingBottom</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>完整代码实现参考<a target="_blank" rel="noopener" href="https://github.com/Guohjia/listScroll">https://github.com/Guohjia/listScroll</a></p>
</blockquote>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>padding 的计算依赖列表项固定的高度</li>
<li>这是一个同步渲染的方案，也就是目前容器 padding 的计算调整，无法计算异步获取的数据，只跟用户的滚动行为有关。解决思路：<ul>
<li>思路1：利用 Skeleton Screen Loading 来同步渲染数据元素，不受数据异步获取的影响。即在数据请求还未完成时，先使用一些图片进行占位，待内容加载完成之后再进行替换。</li>
<li>思路2：滚动到目标位置，阻塞容器 padding 的设置（即无限下拉的发生）直至数据请求完毕，用 loading gif 提示用户加载状态，但这个方案相对复杂，你需要全面考虑用户难以预测的滚动行为来设置容器的 padding。</li>
</ul>
</li>
</ul>
<h2 id="方案二：较为有名的库-iScroll"><a href="#方案二：较为有名的库-iScroll" class="headerlink" title="方案二：较为有名的库 - iScroll"></a>方案二：较为有名的库 - iScroll</h2><p>思路：<br>iScroll 通过对传统滚动事件的监听，获取滚动距离，然后：</p>
<ol>
<li>设置父元素的 translate 来实现整体内容的上移（下移）；</li>
<li>再基于这个滚动距离进行相应计算，得知相应子元素已经被滚动到视窗外，并且判断是否应该将这些离开视窗的子元素移动到末尾，从而再对它们进行 translate 的设置来移动到末尾。这就像是一个循环队列一样，随着滚动的进行，顶部元素先出视窗，但又将移动到末尾，从而实现无限下拉</li>
</ol>
<h2 id="方案一和二对比"><a href="#方案一和二对比" class="headerlink" title="方案一和二对比"></a>方案一和二对比</h2><ul>
<li>实现对比：一个是 Intersection Observer 的监听，来通知子元素离开视窗，只要定量设置父元素 padding 就行；另一个是对传统滚动事件的监听，滚动距离的获取，再进行一系列计算，去设置父元素以及子元素的 translate。显而易见，前者看起来更加简洁明了一些</li>
<li>性能对比：我知道说到对比，你脑海中肯定一下子会想到性能问题。其实性能对比的关键就是 Intersection Observer。因为单就 padding 设置还是 translate 设置，性能方面的差距是甚小的，只是个人感觉 padding 会简洁些？而 Intersection Observer 其实抽离了所有滚动层面的相关逻辑，你不再需要对滚动距离等相应 DOM 属性进行获取，也不再需要进行一系列滚动距离相关的复杂计算，并且同步的滚动事件触发变成异步的，你也不再需要另外去做防抖之类的逻辑，这在性能方面还是有所提升的</li>
</ul>
<h1 id="tree组件的渲染优化"><a href="#tree组件的渲染优化" class="headerlink" title="tree组件的渲染优化"></a>tree组件的渲染优化</h1><h1 id="高性能渲染10万个DOM"><a href="#高性能渲染10万个DOM" class="headerlink" title="高性能渲染10万个DOM"></a>高性能渲染10万个DOM</h1><p>见之前的博客<a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/11/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化-如何插入几万个 DOM 并不卡住界面</a></p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/X2ltQyp3W0othLv_m6-Ydg">云音乐-一个简洁、有趣的无限下拉方案</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55528376">前端tree组件，10000个树节点，从14.65s到0.49s</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/27/%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/" data-id="clmniym8b0054bb87gpugcz5l" data-title="渲染方案" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>