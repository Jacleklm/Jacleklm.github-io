<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jacleklm">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:locale">
<meta property="article:author" content="Jacleklm">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-哈希表 &amp; 哈希算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/26/%E5%93%88%E5%B8%8C%E8%A1%A8%20&%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-05-26T02:50:21.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/26/%E5%93%88%E5%B8%8C%E8%A1%A8%20&%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">哈希表 &amp; 哈希算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="哈希表-散列表"><a href="#哈希表-散列表" class="headerlink" title="哈希表 (散列表)"></a>哈希表 (散列表)</h2><p>在线性表中，所有的数据都是顺序存储，当我们需要在线性表中查找某一数据时，当线性表过长，需要查找的数据排序比较靠后的话，就需要花费大量的时间，导致查找性能较差</p>
<p>所以我们可以把数据存在哈希表中，通过 key 去拿到数据。这个过程可以描述为：</p>
<blockquote>
<p>拿到key(关键字) &gt; 关键字通过散列函数(哈希函数)计算出来的值则称为散列值（哈希值、Hash 值） &gt; 过散列值到**散列表（哈希表、Hash 表)**中就可以获取检索值</p>
</blockquote>
<p>如下图：<br><img src="/img/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p>
<p>所以我们需要存的信息有：key，散列函数，散列表信息。所以，散列表是一种空间换时间的存储结构，是在算法中提升效率的一种比较常用的方式。</p>
<p>散列函数的作用就是给定一个键值，然后返回值在表中的地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 散列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HashTable</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> table = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><strong>哈希函数（Hash Function），也称为散列函数或杂凑函数</strong>。哈希函数是一个公开函数，可以将任意长度的消息M映射成为一个长度较短且长度固定的值H（M），称H（M）为哈希值、散列值（Hash Value）、杂凑值或者消息摘要（Message Digest）。<strong>它是一种单向密码体制，即一个从明文到密文的不可逆映射，只有加密过程，没有解密过程</strong>。</p>
<p>它的函数表达式为：<code>h = H(m)</code></p>
<p>无论输入是什么数字格式、文件有多大，输出都是固定长度的比特串。eg. 以比特币使用Sh256算法，无论输入是什么数据文件，输出就是256bit。<br>每个bit就是一位0或者1，256bit就是256个0或者1二进制数字串，用16进制数字表示的话: 16等于2的4次方，所以每一位16进制数字可以代表4位bit，所以256位bit用16进制数字表示是256除以4等于64位。<br>于是我们通常看到的哈希值，是这样的：</p>
<blockquote>
<p>00740f40257a13bf03b40f54a9fe398c79a664bb21cfa2870ab07888b21eeba8</p>
</blockquote>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>易压缩：对于任意大小的输入x，Hash值的长度很小，在实际应用中，函数H产生的Hash值其长度是固定的。</li>
<li>易计算：对于任意给定的消息，计算其Hash值比较容易。</li>
<li>单向性：对于给定的Hash值，要找到使得在计算上是不可行的，即求Hash的逆很困难。在给定某个哈希函数H和哈希值H（M）的情况下，得出M在计算上是不可行的。即从哈希输出无法倒推输入的原始数值。这是哈希函数安全性的基础。</li>
<li>抗碰撞性：理想的Hash函数是无碰撞的，但在实际算法的设计中很难做到这一点。有两种抗碰撞性：一种是弱抗碰撞性，即对于给定的消息，要发现另一个消息，满足在计算上是不可行的；另一种是强抗碰撞性，即对于任意一对不同的消息，使得在计算上也是不可行的。</li>
<li>高灵敏性：这是从比特位角度出发的，指的是1比特位的输入变化会造成1&#x2F;2的比特位发生变化。消息M的任何改变都会导致哈希值H（M）发生改变。即如果输入有微小不同，哈希运算后的输出一定不同。</li>
</ul>
<h1 id="哈希算法的要求"><a href="#哈希算法的要求" class="headerlink" title="哈希算法的要求"></a>哈希算法的要求</h1><p>一个可靠的哈希算法，应该满足：</p>
<ul>
<li>对于给定的数据M,很容易算出哈希值X&#x3D;F(M)；根据X很难反算出M</li>
<li>很难找到M和N使得F(N)&#x3D;F(M)（这个可能是加密领域的，其实在储存领域，为了节省空间，key 值不同，通过散列函数计算出来的散列值（value）不一定不相同）</li>
</ul>
<p>哈希函数更多设计方法和冲突解决方法详见<a target="_blank" rel="noopener" href="https://github.com/sisterAn/JavaScript-Algorithms/issues/49">哈希表问题</a></p>
<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>一个初始值值对应一个唯一的结果值，根据结果还推算不出来初始值，这可以通过<strong>丢掉一部分信息</strong>的加密方式实现，称为“单向加密”，也叫哈希算法。一个简单的例子：取注册者注册的时间戳的后6位再乘6取后6位，勉勉强强可以算是一个哈希算法。</p>
<h1 id="常见的哈希算法（加密领域）"><a href="#常见的哈希算法（加密领域）" class="headerlink" title="常见的哈希算法（加密领域）"></a>常见的哈希算法（加密领域）</h1><ul>
<li>SHA-1算法</li>
<li>SHA-2算法</li>
<li>SHA-512算法</li>
<li>SHA-3算法</li>
<li>RIPEMD160算法</li>
<li>…</li>
</ul>
<blockquote>
<p>这些算法的过程大概包括：输入 &gt; 消息填充 &gt; 链接变量初始化 &gt; 处理主循环模块 &gt; 得出最终的Hash值</p>
</blockquote>
<p>算法的具体细节见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O0YGl4U14CNRX_t27khq8w">哈希算法</a></p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O0YGl4U14CNRX_t27khq8w">哈希算法</a><br><a target="_blank" rel="noopener" href="https://github.com/sisterAn/JavaScript-Algorithms/issues/49">前端瓶子君</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/26/%E5%93%88%E5%B8%8C%E8%A1%A8%20&%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" data-id="clmniym7r003sbb87cedffqaj" data-title="哈希表 &amp; 哈希算法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React - Hook" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/23/React%20-%20Hook/" class="article-date">
  <time class="dt-published" datetime="2020-05-23T08:50:21.000Z" itemprop="datePublished">2020-05-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/23/React%20-%20Hook/">React - Hook</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文大部分来自<a target="_blank" rel="noopener" href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a>，建议直接看原博客</p>
<h1 id="What-Why"><a href="#What-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h1><p>使用 Hooks，你可以在将含有 state 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks 可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案<br>解决了 HOC 嵌套地狱的问题，使得逻辑复用更加清晰</p>
<h1 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h1><p>useState 是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值</p>
<h1 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h1><p>Effect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>第一个参数是回调函数，在第组件一次 render 和之后的每次 update 后运行，React 保证在 DOM 已经更新完成之后才会运行回调；这个回调函数可以 return 一个函数，<strong>在执行下一个 useEffect 之前，会执行这个函数</strong>，常常用来对上一次调用 useEffect 进行清理，并且可以拿到上一次的状态（原理是闭包）</li>
<li>第二个参数是状态依赖</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="模拟生命周期"><a href="#模拟生命周期" class="headerlink" title="模拟生命周期"></a>模拟生命周期</h3><ul>
<li>componentDidMount：状态依赖为空数组即可（其实官方并不推荐这种写法）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useDidMount</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(callback, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>componentWillUnmount：作为回调函数的 return 函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useUnMount</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> callback, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ref-Hook"><a href="#ref-Hook" class="headerlink" title="ref Hook"></a>ref Hook</h1><p>用来获取 DOM 的 ref</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onButtonClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputEl.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 useRef()并不仅仅可以用来当作获取 ref 使用，使用 useRef 产生的 ref 的 current 属性是可变的，这意味着你可以用它来保存一个任意值</p>
<h2 id="模拟-componentDidUpdate"><a href="#模拟-componentDidUpdate" class="headerlink" title="模拟 componentDidUpdate"></a>模拟 componentDidUpdate</h2><p>componentDidUpdate 就相当于除去第一次调用的 useEffect，我们可以借助 useRef 生成一个标识，来记录是否为第一次执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useDidUpdate</span>(<span class="params">callback, prop</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> init = <span class="title function_">useRef</span>(<span class="literal">true</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.<span class="property">current</span>) &#123;</span><br><span class="line">      init.<span class="property">current</span> = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h1><p>自定义 Hook 非常简单，我们只需要定义一个函数，并且把相应需要的状态和 effect 封装进去，同时，Hook 之间也是可以相互引用的。使用 use 开头命名自定义 Hook，这样可以方便 eslint 进行检查。<br>自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，<strong>它就像一个正常的函数</strong></p>
<h2 id="使用-Hook-的动机"><a href="#使用-Hook-的动机" class="headerlink" title="使用 Hook 的动机"></a>使用 Hook 的动机</h2><ul>
<li>减少状态逻辑复用的风险<ul>
<li>多个 Hook 之前不会相互影响，不会相互覆盖；Hook 也可以避免 HOC 使用不规范时的 props 覆盖</li>
</ul>
</li>
<li>避免嵌套地狱</li>
<li>让组件更容易理解：能用 Hook 讲公共逻辑抽离成函数，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割</li>
<li>函数代替 class</li>
</ul>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>useState 的 setXX 是异步函数，所以 setXXX 后立刻 console.log（XXX）的话是得不到的</li>
<li>在 setTimeout 这种闭包中中读不到其他状态的新值</li>
<li>记住 Hook 不能写在条件（if），循环（for），和嵌套函数中使用</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E5%9B%9B%EF%BC%89.html#effect-hook">ConardLi 的 blog</a><br><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-intro.html">官方文档</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/23/React%20-%20Hook/" data-id="clmniym73001jbb878544bwhf" data-title="React - Hook" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React - HOC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/16/React%20-%20HOC/" class="article-date">
  <time class="dt-published" datetime="2020-05-16T08:50:21.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/16/React%20-%20HOC/">React - HOC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文大部分来自<a target="_blank" rel="noopener" href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a>，建议直接看原博客</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Mixin-的危害"><a href="#Mixin-的危害" class="headerlink" title="Mixin 的危害"></a>Mixin 的危害</h2><p>React 官方文档在<a target="_blank" rel="noopener" href="https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html">Mixins Considered Harmful</a>一文中提到了 Mixin 带来了危害：</p>
<ul>
<li>Mixin 可能会相互依赖，相互耦合，不利于代码维护</li>
<li>不同的 Mixin 中的方法可能会相互冲突</li>
<li>Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li>
</ul>
<p>React 现在已经不再推荐使用 Mixin 来解决<strong>代码复用</strong>问题，因为 Mixin 带来的危害比他产生的价值还要巨大，并且 React 全面推荐使用高阶组件来替代它</p>
<h2 id="HOC-简介"><a href="#HOC-简介" class="headerlink" title="HOC 简介"></a>HOC 简介</h2><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/higher-order-components.html">HOC-官方文档</a><br>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身<strong>不是 React API 的一部分</strong>，它是一种基于 React 的组合特性而形成的<strong>设计模式</strong></p>
<p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。实现在原有组件的基础上对其新增功能和行为</p>
<h1 id="HOC-的实现方式"><a href="#HOC-的实现方式" class="headerlink" title="HOC 的实现方式"></a>HOC 的实现方式</h1><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><p>常用方式，一般是在 render() 返回被包裹的组件，并把需要的 props 传递给它</p>
<h3 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">visibleHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; visible, ...restProps &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><p>假设有一个组件要在 localStorage 拿数据，然后渲染出来，它的代码应该差不多长这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有很多其他组件也需要从 LocalStorage 中获取同样的数据展示出来时，那我要写很多次这段代码，为了效率我决定写用装饰器模式包装一下，所以就有了高阶组件（高阶组件本质是函数，所以这里写成函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">localHOC</span>(<span class="params">InnerComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 通过&#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的 props</li>
<li>可操作组件的生命周期</li>
<li>可操作组件的 static 方法</li>
<li>获取 refs</li>
</ul>
<h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><p>返回一个组件，继承原组件，在 render 中用 super.render() 调用原组件的 render。由于继承了原组件，能通过 this 访问到原组件的生命周期、props、state、render 等，相比属性代理它能操作更多的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritHOC</span>(<span class="params">InnerComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">InnerComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比原生组件增强的项：</p>
<ul>
<li>可操作所有传入的 props</li>
<li>可操作组件的生命周期</li>
<li>可操作组件的 static 方法</li>
<li>获取 refs</li>
<li>可操作 state</li>
<li>可以渲染劫持</li>
</ul>
<h1 id="HOC-可以实现什么功能"><a href="#HOC-可以实现什么功能" class="headerlink" title="HOC 可以实现什么功能"></a>HOC 可以实现什么功能</h1><h2 id="组合渲染（常用）"><a href="#组合渲染（常用）" class="headerlink" title="组合渲染（常用）"></a>组合渲染（常用）</h2><p>可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果</p>
<p>eg. 一个在外层给组件包裹 Antd 的 Card 的 HOC。这里用了函数组件的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Card</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CardHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title = <span class="literal">null</span>, ...restProps &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Card</span> <span class="attr">title</span>=<span class="string">&#123;title&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过反向继承再实现一次。这里是 class 组件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">CardHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">InnerComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Card</span> <span class="attr">title</span>=<span class="string">&#123;this.props.title&#125;</span>&gt;</span>&#123;super.render()&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件渲染（常用）"><a href="#条件渲染（常用）" class="headerlink" title="条件渲染（常用）"></a>条件渲染（常用）</h2><p>根据特定的属性决定原组件是否渲染。第一个 DEMO 就是这个</p>
<h2 id="操作-props"><a href="#操作-props" class="headerlink" title="操作 props"></a>操作 props</h2><p>可以对传入组件的 props 进行增加、修改、删除或者根据特定的 props 进行特殊的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">propsHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">user_name</span>: <span class="string">&#x27;Jacle&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取-ref"><a href="#获取-ref" class="headerlink" title="获取 ref"></a>获取 ref</h2><p>高阶组件中可获取原组件的<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/refs-and-the-dom.html">ref</a>，通过 ref 获取组件实例，如下面的代码，当程序初始化完成后调用原组件的 log 方法 （默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例）。适合用 ref 的情况：管理 input 的 focus；触发强制动画；…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">refHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wapperRef</span>.<span class="title function_">log</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;(ref)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            this.wapperRef = ref</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意：调用高阶组件的时候并不能获取到原组件的真实 ref，需要手动进行传递。详见<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/forwarding-refs.html">refs 转发</a></p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>将原组件的状态提取到 HOC 中进行管理，如下面的代码，我们将 Input 的 value 提取到 HOC 中进行管理，使它变成受控组件，同时不影响它使用 onChange 方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHoc</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(props)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onChange &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onChange === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">onChange</span>(event)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">onChange</span>: <span class="variable language_">this</span>.<span class="property">onChange</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOC</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">proxyHoc</span>(<span class="variable constant_">HOC</span>)</span><br></pre></td></tr></table></figure>

<h2 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h2><p>上面的例子通过属性代理利用 HOC 的 state 对原组件进行了一定的增强，但并不能直接控制原组件的 state，而通过<strong>反向继承</strong>，我们可以直接操作原组件的 state。但是并<strong>不推荐直接修改或添加原组件的 state</strong>，因为这样有可能和组件内部的操作构成冲突</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debugHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props&#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;debuging&quot;</span>&gt;</span>&#123;super.render()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h2><p>通过反向继承的方式，可直接增强（而不是更改）由原组件 render 函数产生的 React 元素，eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hijackHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> tree = <span class="variable language_">super</span>.<span class="title function_">render</span>() <span class="comment">// render函数内实际上是调用React.creatElement产生的React元素。它所有属性的writable特性均被配置为了false，即所有属性是不可变的。所以我们只能重新创造一个元素，用React.cloneElement()</span></span><br><span class="line">      <span class="keyword">let</span> newProps = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (tree &amp;&amp; tree.<span class="property">type</span> === <span class="string">&#x27;input&#x27;</span>) &#123;</span><br><span class="line">        newProps = &#123; <span class="attr">value</span>: <span class="string">&#x27;渲染被劫持了&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, tree.<span class="property">props</span>, newProps)</span><br><span class="line">      <span class="keyword">const</span> newTree = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(tree, props, tree.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">      <span class="keyword">return</span> newTree</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>React.cloneElement()克隆并返回一个新的 React 元素，使用 element 作为起点。生成的元素将会拥有原始元素 props 与新 props 的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。</p>
</blockquote>
<h1 id="HOC-的优雅写法"><a href="#HOC-的优雅写法" class="headerlink" title="HOC 的优雅写法"></a>HOC 的优雅写法</h1><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>在实际应用中，一个组件可能被多个 HOC 增强，我们使用的是被所有的 HOC 增强后的组件。直接写的话代码可读性会很差：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newComponent = <span class="title function_">aHOC</span>(<span class="title function_">bHOC</span>(<span class="title function_">cHOC</span>(<span class="title class_">InnerComponent</span>)))</span><br></pre></td></tr></table></figure>

<p>我们可以用类似柯里化的方式，手动封装一个简单的函数组合工具，将写法改写如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...fns</span>) =&gt; fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">g</span>(<span class="title function_">f</span>(...args)))</span><br><span class="line"><span class="title function_">compose</span>(aHOC, bHOC, cHOC)(<span class="title class_">InnerComponent</span>)</span><br></pre></td></tr></table></figure>

<h2 id="ES7-的-Decorators"><a href="#ES7-的-Decorators" class="headerlink" title="ES7 的 Decorators"></a>ES7 的 Decorators</h2><p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/decorator">ES7-Decorators</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@aHOC</span><br><span class="line">@bHOC</span><br><span class="line">@cHOC</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这个InnerComponent等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;&#125;</span><br><span class="line"><span class="title class_">InnerComponent</span> = <span class="title function_">aHOC</span>(<span class="title class_">InnerComponent</span>) || <span class="title class_">InnerComponent</span></span><br></pre></td></tr></table></figure>

<p>Decorators 是 ES7 的一个提案，还没有被标准化，但目前 Babel 转码器已经支持，我们需要提前配置 babel-plugin-transform-decorators-legacy：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;transform-decorators-legacy&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>还可以结合上面的 compose 函数使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hoc = <span class="title function_">compose</span>(aHOC, bHOC, cHOC)</span><br><span class="line">@hoc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-HOC-的注意事项"><a href="#使用-HOC-的注意事项" class="headerlink" title="使用 HOC 的注意事项"></a>使用 HOC 的注意事项</h1><ul>
<li>静态属性拷贝<br>当我们应用 HOC 去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在 HOC 的结尾手动拷贝他们：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HOCComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">HOCComponent</span>.<span class="property">staticMethod</span> = <span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">HOCComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用<a target="_blank" rel="noopener" href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>来帮助我们解决这个问题，它可以自动帮我们拷贝所有非 React 的静态方法，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HOCComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hoistNonReactStatic</span>(<span class="title class_">HOCComponent</span>, <span class="title class_">WrappedComponent</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">HOCComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Refs 不会被传递给被包装组件</li>
<li>不要在组件的 render 方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。因为高阶组件每次都会返回一个新的组件，在 render 中使用会导致每次渲染出来的组件都不相等（&#x3D;&#x3D;&#x3D;），于是每次 render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了</li>
<li>约定：不要改变原始组件。高阶组件应该是一个没有副作用的纯函数 (函数的调用参数相同，则永远返回相同的结果)</li>
<li>约定：透传不相关的 props。即 props 传递</li>
<li>约定：最好使用<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/higher-order-components.html#convention-wrap-the-display-name-for-easy-debugging">displayName</a>，方便调试。官方推荐使用 HOCName(WrappedComponentName)。eg. 赋予 return 组件一个静态属性：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> displayName = <span class="string">`aHOC(<span class="subst">$&#123;WrappedComponent.displayName&#125;</span>)`</span></span><br></pre></td></tr></table></figure>

<h1 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h1><h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><p>多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用。eg，上面写过的 localstorage 的例子</p>
<h2 id="可用、权限控制"><a href="#可用、权限控制" class="headerlink" title="可用、权限控制"></a>可用、权限控制</h2><p>当没权限的时候不展示某个组件，就是上面提到的组合渲染</p>
<h2 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h2><p>eg. <a target="_blank" rel="noopener" href="https://semi.bytedance.net/zh-CN/components/form">Semi</a> 中用 withField 封装自定义表单控件<br>通过 withField，你可以将其他自定义组件扩展成为表单控件，由 Form 接管其行为（value, onChange; 还有在上方插入Field 的<code>&lt;Label&gt;</code>， 下方插入 Field 的<code>&lt;ErrorMessage&gt;</code>等）</p>
<p>注意：自定义组件必须为受控组件，关于受控组件&#x2F;非受控组件请参考<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/glossary.html#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-vs-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6">react docs</a></p>
<h2 id="Redux-的-connect"><a href="#Redux-的-connect" class="headerlink" title="Redux 的 connect"></a>Redux 的 <a target="_blank" rel="noopener" href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect">connect</a></h2><p><img src="/img/React-HOC/connect.png"><br>下面就是一个简化版的connect实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">xport <span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Connect</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      <span class="attr">store</span>: <span class="title class_">PropTypes</span>.<span class="property">object</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">      <span class="variable language_">super</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">allProps</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_updateProps</span>()</span><br><span class="line">      store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_updateProps</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _updateProps () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps ? <span class="title function_">mapStateToProps</span>(store.<span class="title function_">getState</span>(), <span class="variable language_">this</span>.<span class="property">props</span>): &#123;&#125; </span><br><span class="line">      <span class="keyword">let</span> dispatchProps = mapDispatchToProps? <span class="title function_">mapDispatchToProps</span>(store.<span class="property">dispatch</span>, <span class="variable language_">this</span>.<span class="property">props</span>) : &#123;&#125; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">allProps</span>: &#123;</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...<span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state.allProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Connect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connect函数其实就做了一件事: 将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>嵌套太多 HOC，代码可读性会比较差</li>
<li>HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a><br><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/higher-order-components.html">官网</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/16/React%20-%20HOC/" data-id="clmniym74001nbb879yzge5wf" data-title="React - HOC" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSS Modules" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/30/CSS%20Modules/" class="article-date">
  <time class="dt-published" datetime="2020-04-30T02:20:21.000Z" itemprop="datePublished">2020-04-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/30/CSS%20Modules/">CSS Modules</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CSS Modules 不同于 less，sass 等，不是把CSS改造成编程语言，而是功能很单纯，只加入了局部作用域和模块依赖</p>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul>
<li>全局样式冲突（主要问题）</li>
<li>css选择器嵌套过深，有性能问题</li>
<li>代码冗余（无继承）</li>
<li>模块化</li>
</ul>
<h1 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h1><p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。这使得在开发中很可能有类名相同造成相互影响的情况，多层嵌套css又会造成性能问题。</p>
<p>产生局部作用域的唯一方法，就是使用一个独一无二的<strong>class的名字</strong>，不会与其他选择器重名。这就是 CSS Modules 的做法</p>
<h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><p>一个React组件App.js。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import style from &#x27;./App.css&#x27;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 className=&#123;style.title&#125;&gt;</span><br><span class="line">      Hello World</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>App.css</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">// 这种写法等于：</span><br><span class="line">:local &#123;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建工具会将类名style.title编译成一个哈希字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class=&quot;_3zyde4l1yATCOkgn-DBWEL&quot;&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p>App.css也会同时被编译。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">._3zyde4l1yATCOkgn-DBWEL &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack的支持"><a href="#webpack的支持" class="headerlink" title="webpack的支持"></a>webpack的支持</h2><p>要开启 CSS Modules 功能，在webpack的loader配置中要有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  loader: &quot;style-loader!css-loader?modules&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><code>style-loader!css-loader?modules</code>，它在css-loader后面加了一个查询参数 <code>modules</code>，表示打开 CSS Modules 功能<br>与 sass， less 联用时同理</p>
<h1 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h1><p>允许使用<code>:global(.className)</code>的语法，声明一个全局规则。凡是这样声明的class，都不会被编译成哈希字符串，而是保留类名<br>css:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:global(.title) &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line">// 更常用的写法：</span><br><span class="line">:global &#123;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>js:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">  &lt;div className=&quot;title&quot;&gt;Hello World!&lt;div&gt;</span><br></pre></td></tr></table></figure>
<p>结果会是 green</p>
<h1 id="定制哈希类名"><a href="#定制哈希类名" class="headerlink" title="定制哈希类名"></a>定制哈希类名</h1><p>css-loader默认的哈希算法是<code>[hash:base64]</code>，这会将.title编译成.<code>_3zyde4l1yATCOkgn-DBWEL</code>这样的字符串。</p>
<p>webpack.config.js里面可以定制哈希字符串的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    // ...</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      loader: &quot;style-loader!css-loader?modules&amp;localIdentName=[path][name]---[local]---[hash:base64:5]&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现<code>.title</code>被编译成了<code>demo03-components-App---title---GpMto</code></p>
<h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="组合-composition"><a href="#组合-composition" class="headerlink" title="组合 composition"></a>组合 composition</h2><p>在App.css中，让.title继承 .className 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.className &#123;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.title &#123;</span><br><span class="line">  composes: className;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入其他模块"><a href="#输入其他模块" class="headerlink" title="输入其他模块"></a>输入其他模块</h2><p>选择器也可以继承其他CSS文件里面的规则。<br>another.css:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.className &#123;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>App.css可以继承another.css里面的规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  composes: className from &#x27;./another.css&#x27;;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>这些和 less，sass 等联合使用</p>
<h2 id="关于样式覆盖问题"><a href="#关于样式覆盖问题" class="headerlink" title="关于样式覆盖问题"></a>关于样式覆盖问题</h2><p>因为CSS Modules 不会覆盖属性选择器,所以可以利用属性选择器来解决这个问题<br>&#x2F;&#x2F; 组件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;div data-role=&#x27;test&#x27;&gt;</span><br><span class="line">    测试</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 样式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[data-role=&quot;test&quot;] &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html">阮一峰</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kugeliu/p/7889018.html">博客园</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8373b2e51d4538e6332dbb">掘金</a></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/30/CSS%20Modules/" data-id="clmniym680003bb872ewo306l" data-title="CSS Modules" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TypeScript基础语法小结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2020-04-14T09:25:21.000Z" itemprop="datePublished">2020-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/">TypeScript基础语法小结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="初识-TypeScript"><a href="#初识-TypeScript" class="headerlink" title="初识 TypeScript"></a>初识 TypeScript</h1><h2 id="什么是-TS"><a href="#什么是-TS" class="headerlink" title="什么是 TS"></a>什么是 TS</h2><blockquote>
<p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上</p>
</blockquote>
<h2 id="TS-的优点和缺点"><a href="#TS-的优点和缺点" class="headerlink" title="TS 的优点和缺点"></a>TS 的优点和缺点</h2><p>优点：</p>
<ul>
<li>增加了代码的可读性和可维护性。写代码的时候有更多的编译提示，代码语义更清晰易懂</li>
<li>包容性</li>
<li>拥有活跃的社区</li>
</ul>
<p>缺点：</p>
<ul>
<li>一定的学习成本；短期可能会增加一些开发成本，毕竟要多写一些类型的定义</li>
<li>集成到构建流程需要一些工作量</li>
<li>可能和一些库结合的不是很完美</li>
</ul>
<p>详见 <a target="_blank" rel="noopener" href="https://ts.xcatliu.com/introduction/what-is-typescript">什么是 TS</a></p>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><ul>
<li>编译代码：在命令行用 tsc &lt;文件名&gt; 的方式编译 .ts 文件，</li>
<li>运行代码：然后用 node 执行生成的 js 文件</li>
<li>安装了 ts-node 之后可以在命令行直接 ts-node &lt;文件名&gt; 的方式编译并执行 .ts 文件</li>
</ul>
<h2 id="静态类型的深度理解"><a href="#静态类型的深度理解" class="headerlink" title="静态类型的深度理解"></a>静态类型的深度理解</h2><ul>
<li>指定变量的类型</li>
<li>变量会具有这个类型的属性和方法</li>
</ul>
<h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>个人理解：<strong>对象类型</strong>就是<strong>非基础类型</strong>，包括 函数，自定义类型，类 等</p>
<p>基础类型中，布尔值，数字，字符串基本和 JS 一样；数组有两种定义方式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种（较常用）</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>一种数组，表示一个已知元素数量和类型的数组，各元素的类型不必相同。eg：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;Jacle&#x27;</span>, <span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<p>当访问一个越界的元素，会使用联合类型替代 (联合类型：联合类型表示一个值可以是几种类型之一。用 | 产生)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;Jacle&#x27;</span>, ’<span class="number">23</span>’]</span><br><span class="line"><span class="title class_">List</span>[<span class="number">3</span>] = <span class="string">&#x27;Chen&#x27;</span> <span class="comment">// 可以执行，是string，number 的一种. // 其实还是会报错，说这个元组没有index3</span></span><br><span class="line">list[<span class="number">4</span>] = <span class="literal">true</span> <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h3><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<p>普通 JS 的情况</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Status</span> = &#123; <span class="comment">// eg. 处理一些后端code会用到这种写法</span></span><br><span class="line">  <span class="attr">OFFLINE</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">ONLINE</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">DELETED</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getResult</span>(<span class="params">status</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">OFFLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;offline&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">ONLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;online&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">DELETED</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deleted&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getResult</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用枚举的情况</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">OFFLINE</span>,</span><br><span class="line">  <span class="variable constant_">ONLINE</span>,</span><br><span class="line">  <span class="variable constant_">DELETED</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getResult</span>(<span class="params">status</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">OFFLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;offline&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">ONLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;online&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">DELETED</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deleted&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getResult</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>);</span><br></pre></td></tr></table></figure>

<h4 id="枚举成员的初始化"><a href="#枚举成员的初始化" class="headerlink" title="枚举成员的初始化"></a>枚举成员的初始化</h4><ul>
<li>不对枚举成员的元素进行初始化的时候，默认其值是 0，1，2 … ；给某个成为初始化为某个数字都时候，后面的成员会默认接着这个数字进行初始化</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">OFFLINE</span>,</span><br><span class="line">  <span class="variable constant_">ONLINE</span>,</span><br><span class="line">  <span class="variable constant_">DELETED</span> = <span class="number">100</span>,</span><br><span class="line">  <span class="variable constant_">TEST</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Status</span>.<span class="property">OFFLINE</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>[<span class="number">0</span>]) <span class="comment">// OFFLINE 反向查枚举成员的名称</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Status</span>[<span class="number">0</span>]) <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">ONLINE</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">DELETED</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">TEST</span>) <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对某个成员初始化为非数字类型时，接下来的其他成员都得进行显式初始化，直到某个成员被显示初始化为数字类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">OFFLINE</span>,</span><br><span class="line">  <span class="variable constant_">ONLINE</span> = <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">DELETED</span> = <span class="string">&#x27;chen&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">TEST</span> = <span class="number">10</span>,</span><br><span class="line">  <span class="title class_">TETS2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">ONLINE</span>) <span class="comment">// jacle</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">DELETED</span>) <span class="comment">// chen</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">TEST</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">TETS2</span>) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>更详见 <a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/enums.html">官方文档：枚举</a></p>
<h3 id="any-常用"><a href="#any-常用" class="headerlink" title="any (常用)"></a>any (常用)</h3><p>我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">&#x27;maybe a string instead&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;free&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>void 类型像是与 any 类型相反，它表示没有任何类型。一般用于函数没返回值的时候使用；void 变量则只能赋值为 undefined 和 null</p>
<h3 id="undefined-和-null-少用"><a href="#undefined-和-null-少用" class="headerlink" title="undefined 和 null (少用)"></a>undefined 和 null (少用)</h3><p>两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大</p>
<h3 id="never-少用"><a href="#never-少用" class="headerlink" title="never (少用)"></a>never (少用)</h3><p>never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。eg：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>使用类型断言的时候，TS 认为程序员已经很确定这个变量的类型了，会假设程序员已经做了必须的检查，常和 <code>any</code> 搭配使用。有两种写法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;&gt;写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someVal</span>: <span class="built_in">any</span> = <span class="string">&#x27;this is a string, I sure&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someVal).<span class="property">length</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strLength) <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// as写法 (似乎比较好记)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someVal</span>: <span class="built_in">any</span> = <span class="string">&#x27;this is a string, I sure&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someVal <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br></pre></td></tr></table></figure>

<h2 id="类型注解（type-annotation）-类型推断-（type-inference）"><a href="#类型注解（type-annotation）-类型推断-（type-inference）" class="headerlink" title="类型注解（type annotation） &amp; 类型推断 （type inference）"></a>类型注解（type annotation） &amp; 类型推断 （type inference）</h2><p>类型注解：明显写出来的，我们告诉 TS 变量是什么类型</p>
<p>类型推断：TS 自动的去尝试分析变量类型。当 TS 无法分析出来的时候，就需要我们写类型注解</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>同 JS：var，let， const</p>
<h2 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（type alias）</h2><p>就是 type 这种语法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">User</span>[] = [&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserName</span> = <span class="string">&#x27;jacle&#x27;</span> | <span class="string">&#x27;jaclee&#x27;</span></span><br></pre></td></tr></table></figure>

<p>个人理解：类型别名 和 接口 的区别不大，类型别名 能表示基础类型，接口 只能表示对象类型；能用接口的时候尽量用接口</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约</p>
</blockquote>
<p>个人理解是：接口是对一类数据结构的约定和描述</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>可有可无的属性。eg：<code>color?: string;</code></p>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>只能在刚创建的时候赋值，后面不能修改，在接口的属性前加 <code>readonly</code>。eg:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">point1</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">point1.<span class="property">x</span> = <span class="number">3</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>此外，TypeScript 的数组具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，效果一样</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>总结：不能变的属性用 readonly，不能变的变量用 const</p>
<h4 id="一个作用：接口可能带有任意数量的其它属性"><a href="#一个作用：接口可能带有任意数量的其它属性" class="headerlink" title="一个作用：接口可能带有任意数量的其它属性"></a>一个作用：接口可能带有任意数量的其它属性</h4><p>如果我们创建一个接口，该接口除了我们明确约定好的属性，还可能会带有任意数量的其它属性，我们这时候就可以用 添加一个字符串索引签名</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是其实这种情况还有一个不用索引类型的知识点（虽然不太严谨）：直接传的对象有多余属性会报错，传的是变量的时候就不会</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">person: Person</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jacle = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">school</span>: <span class="string">&#x27;SYSU&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getName</span>(&#123; <span class="comment">// Error，school 不在 Person 中</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">school</span>: <span class="string">&#x27;SYSU&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">getName</span>(jacle) <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口也可以描述函数类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> searchFun &#123;</span><br><span class="line">  (<span class="attr">sour</span>: <span class="built_in">string</span>, <span class="attr">data</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">testFun</span>: searchFun = <span class="keyword">function</span>(<span class="params">sour: <span class="built_in">string</span>, data: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>接口也能用来描述类，强制一个类去满足某种契约。用 <code>implements</code><br>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInt</span> &#123;</span><br><span class="line">  <span class="attr">currTime</span>: <span class="title class_">Date</span>,</span><br><span class="line">  <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInt</span> &#123;</span><br><span class="line">  <span class="attr">currTime</span>: <span class="title class_">Date</span></span><br><span class="line">  <span class="title function_">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currTime</span> = d</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currTime</span> = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>一个接口可以继承一个或多个接口，创建出多个接口的合成接口。用 <code>extends</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> class1 &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> class2 &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> class3 &#123;</span><br><span class="line">  <span class="attr">city</span>: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> people <span class="keyword">extends</span> class1, class2, class3 &#123;</span><br><span class="line">  <span class="attr">ishandsome</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">jacle</span>: people = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">city</span>: [<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>],</span><br><span class="line">  <span class="attr">ishandsome</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可索引类型-索引签名"><a href="#可索引类型-索引签名" class="headerlink" title="可索引类型 &amp;&amp; 索引签名"></a>可索引类型 &amp;&amp; 索引签名</h2><p>接口也可以描述那些能够“通过索引得到”的类型，比如数组或对象: <code>a[10]</code> 或 <code>ageMap[&#39;daniel&#39;]</code>。 可索引类型具有一个<strong>索引签名</strong>，它描述了<strong>对象索引的类型，还有相应的索引返回值类型</strong>(两部分)</p>
<blockquote>
<p>一般情况下， 索引 和 索引签名 是一个概念；当我们<strong>声明一个索引签名</strong>的时候，就是声明了索引的类型，还有相应的索引返回值类型（两部分）</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StrArr</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> <span class="comment">// 暂时理解为这部分是索引签名。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strA</span>: <span class="title class_">StrArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStr</span>: <span class="built_in">string</span> = strA[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个 index 只是发挥可读性的作用，你可以随便命名</p>
</blockquote>
<h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a><a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/typings/indexSignatures.html#typescript-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D">索引签名</a></h3><p>可看文档</p>
<h3 id="JS中"><a href="#JS中" class="headerlink" title="JS中"></a>JS中</h3><ol>
<li>在JS中，一般认为索引签名的类型是字符串和数字<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jacle = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle[<span class="string">&#x27;name&#x27;</span>]) <span class="comment">// 索引签名是字符串</span></span><br><span class="line"><span class="keyword">let</span> people = [jacle]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people[<span class="number">0</span>]) <span class="comment">// 索引签名是数字</span></span><br></pre></td></tr></table></figure></li>
<li>当我们把索引签名搞成对象时，JavaScript 会在得到结果之前会先调用 .toString 方法：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString called&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">any</span> = &#123;&#125;;</span><br><span class="line">foo[obj] = <span class="string">&#x27;World&#x27;</span>; <span class="comment">// toString called</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo[obj]); <span class="comment">// toString called, World</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo[<span class="string">&#x27;Hello&#x27;</span>]); <span class="comment">// World</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只要索引位置使用了 obj，toString 方法都将会被调用</p>
</blockquote>
</li>
</ol>
<h3 id="TS中"><a href="#TS中" class="headerlink" title="TS中"></a>TS中</h3><p>TypeScript 的索引签名必须是 string 或者 number。我们搞 obj 进去会报错的，强制用户必须明确的写出 toString()</p>
<h4 id="声明一个索引签名"><a href="#声明一个索引签名" class="headerlink" title="声明一个索引签名"></a>声明一个索引签名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: &#123; <span class="attr">message</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line">&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 储存的东西必须符合结构</span></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">foo[<span class="string">&#x27;a&#x27;</span>] = &#123; <span class="attr">message</span>: <span class="string">&#x27;some message&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error, 必须包含 `message`</span></span><br><span class="line">foo[<span class="string">&#x27;a&#x27;</span>] = &#123; <span class="attr">messages</span>: <span class="string">&#x27;some message&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="所有成员都必须符合字符串的索引签名"><a href="#所有成员都必须符合字符串的索引签名" class="headerlink" title="所有成员都必须符合字符串的索引签名"></a>所有成员都必须符合字符串的索引签名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">string</span>; <span class="comment">// Error: y 属性必须为 number 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用字符串字面量-字符串组成的联合类型-当索引签名"><a href="#使用字符串字面量-字符串组成的联合类型-当索引签名" class="headerlink" title="使用字符串字面量(字符串组成的联合类型)当索引签名"></a>使用字符串字面量(字符串组成的联合类型)当索引签名</h4><p>一个索引签名可以通过<strong>映射类型</strong>来使索引字符串为联合类型中的一员：</p>
<blockquote>
<p>映射类型是 in、keyof、typeof 这些？</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> index = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> fromIndex = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> index]: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">good</span>: <span class="title class_">FromIndex</span> = &#123; <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// Error:</span></span><br><span class="line"><span class="comment">// `&#123; b: 1, c: 2, d: 3 &#125;` 不能分配给 &#x27;FromIndex&#x27;</span></span><br><span class="line"><span class="comment">// 对象字面量只能指定已知类型，&#x27;d&#x27; 不存在 &#x27;FromIndex&#x27; 类型上</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">bad</span>: <span class="title class_">FromIndex</span> = &#123; <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="同时拥有-string-和-number-类型的索引签名-少用"><a href="#同时拥有-string-和-number-类型的索引签名-少用" class="headerlink" title="同时拥有 string 和 number 类型的索引签名(少用)"></a>同时拥有 string 和 number 类型的索引签名(少用)</h4><p>TypeScript 可以同时使用字符串和数字两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ArrStr</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">// 必须包括所用成员类型</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>; <span class="comment">// 字符串索引类型的子级</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// example</span></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">greeter.<span class="title function_">greet</span>()</span><br></pre></td></tr></table></figure>

<p>创建了一个 Greeter 类，有一个 greeting 属性，一个构造函数 constructor（所以构造函数中也得有 this.greeting）和一个 greet 方法</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>同 ES6</p>
<p>此外，子类可以通过直接重写方法的形式重写父类的方法；重写的时候如果想调用父类的方法可以用 super</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;jacle&#x27;</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getName</span>() + <span class="string">&#x27; new&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jacle = <span class="keyword">new</span> <span class="title class_">Teacher</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle.<span class="title function_">getName</span>()) <span class="comment">// ‘jacle new&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h3><p>类的属性，静态属性，方法，构造函数 都可以加这些修饰符前缀，默认都是 public</p>
<ul>
<li>默认为 public。外部可访问</li>
<li>private。外部不可访问，只有内部（这个类自己）的方法可以访问</li>
<li>protected。只有 类自己 和 类的后代 可以访问</li>
<li>也可加 readonly 修饰符，使得属性无法被后续修改</li>
</ul>
<p>注意下面这两种写法都可以：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span> message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><p>可以把属性写成 pravite 的，然后定义 getter 和 setter 进行属性的读改</p>
<p>用法：用 <code>get</code> 和 <code>set</code>，一般会和 pravite 属性配合使用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> _name: <span class="built_in">string</span></span>) &#123; <span class="comment">// 内部属性可以用 _ 进行区分，可以和 get 相配合</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 可以加额外的处理逻辑</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="comment">// low 的写法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jacle2 = <span class="keyword">new</span> <span class="title class_">Person3</span>(<span class="string">&#x27;jacle&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle2.<span class="property">name</span>) <span class="comment">// 用了 get 之后可以直接这么用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle2.<span class="title function_">getName</span>())</span><br><span class="line">jacle2.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span> <span class="comment">// 调用了 setter</span></span><br></pre></td></tr></table></figure>

<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>属性加 static 前缀。静态属性存在于<strong>类本身</strong>上面而不是类的实例上，但是实例会用到这个属性，访问方法是 <code>类.静态属性</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChenFamilyPeo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> lastName = <span class="string">&#x27;Chen&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">firstname</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstname: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstname</span> = firstname</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ChenFamilyPeo</span>.<span class="property">lastName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">firstname</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jacle = <span class="keyword">new</span> <span class="title function_">chenFamilyPeo</span>(<span class="string">&#x27;Junjia&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle.<span class="title function_">getFullName</span>())  <span class="comment">// Chen Junjia</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ChenFamilyPeo</span>.<span class="property">lastName</span>)  <span class="comment">// Chen</span></span><br></pre></td></tr></table></figure>

<h4 id="应用举例：TS-中的单例模式"><a href="#应用举例：TS-中的单例模式" class="headerlink" title="应用举例：TS 中的单例模式"></a>应用举例：TS 中的单例模式</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleObj</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">instance</span>: <span class="title class_">SingleObj</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">SingleObj</span>(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title class_">SingleObj</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;jacle&#x27;</span>, <span class="number">23</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getAge</span>()) <span class="comment">// 23</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title class_">SingleObj</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;jacle&#x27;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 === person2) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">getAge</span>()) <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象类-少用"><a href="#抽象类-少用" class="headerlink" title="抽象类 (少用)"></a>抽象类 (少用)</h3><p>抽象类做为其它派生类的基类使用（抽象子类 &#x3D;&#x3D;&#x3D; 派生类）。 它们一般不会直接被实例化。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法<br>并且派生类一定要有抽象类中定义的属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Department name: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name) <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">generateReports</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generating accounting reports...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span> <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">Department</span>() <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>(<span class="string">&#x27;客增研发&#x27;</span>) <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(department.<span class="property">name</span>) <span class="comment">// 客增研发</span></span><br><span class="line">department.<span class="title function_">printName</span>() <span class="comment">// Department name: 客增研发</span></span><br><span class="line">department.<span class="title function_">printMeeting</span>() <span class="comment">// The Accounting Department meets each Monday at 10am.</span></span><br><span class="line">department.<span class="title function_">generateReports</span>() <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完整函数类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: <span class="function">(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选参数-默认参数"><a href="#可选参数-默认参数" class="headerlink" title="可选参数 &amp; 默认参数"></a>可选参数 &amp; 默认参数</h3><ul>
<li>TS 中参数是必须的，不能是 undifined，不能多也不能少。可以用 <code>?</code> 表示可选参数</li>
<li>默认参数同 ES6 如果位置靠前但是想启用默认参数，则传 undefined 即可</li>
</ul>
<p>当我们想传好几个参数，但是参数不是必选的时候，有时候执行起来会不太优雅：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">testFn</span> = (<span class="params">a?: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span> </span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>, a);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testFn</span>(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>可以改成这种对象的写法:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">testFn</span> = (<span class="params">ops: &#123; a?: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>, ops.<span class="property">a</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>, ops.<span class="property">c</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testFn</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>个人理解函数重载就是：函数根据传入不同的参数而返回不同类型的数据的场景 &#x2F; 执行不同的逻辑。<br>在 TS 当中，除了在函数内部写判断类型并具体执行的逻辑之外，还要在函数之前 为同一个函数提供多个函数类型定义来进行函数重载</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): &#123;<span class="attr">suit</span>: <span class="built_in">string</span>; <span class="attr">card</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(x)) &#123;</span><br><span class="line">    <span class="comment">// 逻辑部分</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑部分</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">suit</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">card</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在定义重载的时候，一定要把最精确的定义放在最前面</p>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型，泛指的类型</p>
<p>个人理解：泛型主要是用来<strong>提高数据类型方面的复用性</strong>：组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，比单纯写 string | number 等这种联合类型写法复用性更高<br>进一步理解：泛形应该理解为一个储存池，用来保存可能会用到的类型，相当于<strong>加了若干个类型参数</strong>。捕获输入类型只是泛型的常见应用</p>
<h3 id="类型变量-T"><a href="#类型变量-T" class="headerlink" title="类型变量 T"></a>类型变量 T</h3><p>语法是 <code>&lt;T&gt;</code>，可以帮助我们捕获用户传入的类型，eg：定义一个会返回任何传入它的值的函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123; <span class="comment">// 编译器会认为 T 是任意类型，所以该函数具有强的通用性</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不好的写法：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123; <span class="comment">// 用any能有同样的效果，但是我们会丢失 参数类型 ，这个信息</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把这个版本的 identity 函数叫做泛型，因为它可以适用于多个类型。可以使用泛型来创建可重用的组件<br>我们可以这么用该函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="title function_">identity</span>(<span class="string">&#x27;jacle&#x27;</span>) <span class="comment">// 编译器会根据传入的参数自动地帮助我们确定 T 的类型</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型类型-接口-类"><a href="#泛型类型-接口-类" class="headerlink" title="泛型类型 &amp; 接口 &amp; 类"></a>泛型类型 &amp; 接口 &amp; 类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> rec&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">newre</span>: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = rec</span><br></pre></td></tr></table></figure>

<p>泛型接口</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span>&lt;T&gt; &#123;</span><br><span class="line">  (<span class="attr">arg</span>: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span>&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></table></figure>

<p>泛型类，与接口类似</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> join&lt;T&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">join&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>) <span class="comment">// 函数使用的时候可以显式地生命泛型是什么类型，显然这里会报错；不显式则会被推断出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> join&lt;T, P&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: P) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">join&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>) <span class="comment">// 泛型还可以定义多个，这里不会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>泛型约束是一个很常用的用法</strong>，用来<strong>把类型约束成一个更严谨的类型</strong> (<strong>使得泛型收窄</strong>)，eg. 用来<strong>确保属性存在</strong>。其实泛型约束的方法挺多：extends这种简单的也算</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> rec&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>) <span class="comment">// error。编译的时候认为arg是任何类型，所以不一定有length属性</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以<strong>定义一个接口做一些约束</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> lengthwise &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> rec&lt;T <span class="keyword">extends</span> lengthwise&gt;(<span class="attr">arg</span>: T): T &#123; <span class="comment">// 意思是：T类型应该有length属性，并且该属性返回number</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">rec</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="title function_">rec</span>(<span class="number">6</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。eg:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="title class_">Person</span>[];  <span class="comment">// number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = keyof &#123; [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Person</span> &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure>
<p>所以有了 keyof 之后我们可以更愉快地和 泛型约束 玩耍</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProperty&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K): T[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发中还遇到不懂的泛型骚操作，详见 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9mvQcBM13Rt75dJpftVTIg">一文读懂 TypeScript 泛型及应用</a></p>
<h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>见<a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a></p>
<h4 id="有时可发挥类似-interface-的作用"><a href="#有时可发挥类似-interface-的作用" class="headerlink" title="有时可发挥类似 interface 的作用"></a>有时可发挥类似 interface 的作用</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">FeatureContext</span> = <span class="title class_">React</span>.<span class="property">createContext</span>&lt;&#123;</span><br><span class="line">  <span class="attr">featureList</span>: <span class="title class_">IFeature</span>[];</span><br><span class="line">  <span class="attr">supplementaryData</span>: <span class="title class_">ISupplementaryData</span>;</span><br><span class="line">  <span class="attr">fetchLoading</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">fetchFeatureData</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">searchFeature</span>(<span class="attr">queryKey</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">verifyId</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [fetchLoading, setFetchLoadingStatus] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="高级类型-其实用的还挺多的"><a href="#高级类型-其实用的还挺多的" class="headerlink" title="高级类型 (其实用的还挺多的)"></a>高级类型 (其实用的还挺多的)</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。用 &amp; 产生</p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型表示一个值可以是几种类型之一。用 | 产生</p>
<h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><h4 id="通俗版"><a href="#通俗版" class="headerlink" title="通俗版"></a>通俗版</h4><p><strong>个人理解</strong>：类型保护一般出现在有联合类型的地方，类型保护就是用来判断变量类型的，并且在对应的 if 分支内能确定变量类型，进而能提前调用那种类型的函数 (比如提前判定是 string，然后在那个分支就可以用 .substr() )</p>
<h4 id="类型保护的方式"><a href="#类型保护的方式" class="headerlink" title="类型保护的方式"></a>类型保护的方式</h4><ul>
<li>类型断言</li>
<li>in语法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="attr">fly</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">sing</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">fly</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型断言的类型保护</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trains1</span>(<span class="params">animal: Bird | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(animal.<span class="property">fly</span>) &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> <span class="title class_">Bird</span>).<span class="title function_">sing</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> <span class="title class_">Dog</span>).<span class="title function_">bark</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in 语法的类型保护</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trains2</span>(<span class="params">animal: Bird | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&#x27;sing&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal.<span class="title function_">sing</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">bark</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>typeof</li>
<li>instanceof<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 和 instanceof 语法的类型保护</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">first: <span class="built_in">string</span> | <span class="built_in">number</span>, second: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> first === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> second === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// instanceof 语法的类型保护 ，只用于能用 instanceof 的，eg. class (interface不能)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">numberObj</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">count: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add2</span>(<span class="params">first: <span class="built_in">object</span> | numberObj, second: <span class="built_in">object</span> | numberObj</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里不能写成 first instanceof numberObj === true</span></span><br><span class="line">  <span class="keyword">if</span>(first <span class="keyword">instanceof</span> numberObj &amp;&amp; second <span class="keyword">instanceof</span> numberObj) &#123;</span><br><span class="line">    <span class="keyword">return</span> first.<span class="property">count</span> + second.<span class="property">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="官方版"><a href="#官方版" class="headerlink" title="官方版"></a>官方版</h4><p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型</p>
<p>定义一个<strong>类型保护</strong>，我们只要简单地定义一个<strong>函数</strong>，它的<strong>返回值是一个类型谓词</strong>：这里 <code>pet is Fish</code> 就是类型谓词</p>
<p>就是当下面这个函数返回true的时候，就会有 <code>pet is Fish</code>，在下面的 if 中相当于一种类型断言的作用了。<strong>所以这种函数类型其实也是一种类型保护</strong>，或者说是一种底层是类型断言的类型保护</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">swim</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can swim, i am fish&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can fly, i am bird&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> petUnknow = <span class="keyword">new</span> <span class="title class_">Fish</span>(<span class="string">&#x27;pet&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trainAnimal</span>(<span class="params">pet: Fish | Bird</span>): <span class="built_in">void</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_">isFish</span>(pet)) &#123;</span><br><span class="line">    pet.<span class="title function_">swim</span>() <span class="comment">// 这里能这样调用而不会报错，因为这个分支认定 pet is Fish</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.<span class="title function_">fly</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">trainAnimal</span>(petUnknow) <span class="comment">// I can swim, i am fish</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须具有的确切值.</p>
<blockquote>
<p>字符串字面量 &#x3D;&#x3D;&#x3D; 字符串组成的联合类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Easing</span> = <span class="string">&#x27;ease-in&#x27;</span> | <span class="string">&#x27;ease-out&#x27;</span> | <span class="string">&#x27;ease-in-out&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEase</span>(<span class="params">ease: Easing</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Typescript-中的-Record-Partial-Readonly-Pick"><a href="#Typescript-中的-Record-Partial-Readonly-Pick" class="headerlink" title="Typescript 中的 Record, Partial, Readonly , Pick"></a>Typescript 中的 Record, Partial, Readonly , Pick</h2><p><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a></p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/project/namespaces.html">文档</a></p>
<h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><h2 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h2><p>使用方法。编译代码：在命令行用 tsc &lt;文件名&gt; 的方式编译 .ts 文件，然后用 node 执行生成的js文件</p>
<h2 id="tsconfig-json-配置文件及其常用语法"><a href="#tsconfig-json-配置文件及其常用语法" class="headerlink" title="tsconfig.json 配置文件及其常用语法"></a>tsconfig.json 配置文件及其常用语法</h2><p>在项目当中，根目录运行 <code>tsc --init</code> 能生成该项目的 TS 配置文件: tsconfig.json</p>
<h3 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h3><p>在根目录命令行单纯地执行 tsc ，会根据配置文件编译整个目录下所有的 .ts 文件（用ts-node ${fileName} 其实也会用这个配置文件) ；想只编译某些文件，可以 files &#x2F; include 或 exculde (数组写法）eg. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [&quot;./single.ts&quot;],</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h3><p><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/compiler-options.html">官方文档</a></p>
<p>常用配置项：</p>
<ul>
<li>常规<ul>
<li>removeComments: true  编译时去除注释</li>
<li>Incremental: true  上次编译过并且没变化的文件这次不会再编译</li>
</ul>
</li>
<li>JS<ul>
<li>allowJs: true    允许编译javascript文件（转成ES5）</li>
<li>checkJs: true   检查JS语法</li>
</ul>
</li>
<li>检查<ul>
<li>noImplicitAny: true  当一个变量是 any 的时候，必须显示地写出来，不然会报错</li>
<li>strictNullChecks: true  在严格的 null检查模式下， null和 undefined值不包含在任何类型里，只允许用它们自己和 any来赋值</li>
</ul>
</li>
<li>输入输出<ul>
<li>outDir: “.&#x2F;build”</li>
<li>rootDir: “.&#x2F;src”  此时src文件外不能有 .ts 文件</li>
</ul>
</li>
<li>额外检查<ul>
<li>noUnusedLocals    若有未使用的局部变量则抛错</li>
<li>noUnusedParameters  同理，函数参数</li>
</ul>
</li>
</ul>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><ul>
<li>项目的script命令中写成 tsc -w ，这个 -w 能监控项目中 TS 文件的变化，有变化就自动重新编译</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://ts.xcatliu.com/introduction/what-is-typescript">TypeScript 入门教程</a><br><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/basic-types.html">TypeScript 官方文档</a><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/330.html">慕课网：基于 TypeScript 从零重构 axios</a><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/412.html">慕课网：TypeScript－系统入门到项目实战</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/" data-id="clmniym7a0023bb87fg1mgw8f" data-title="TypeScript基础语法小结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-洗牌算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/08/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-03-08T05:50:21.000Z" itemprop="datePublished">2020-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/08/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/">洗牌算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>如何真正的打乱数组?</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码看似可以打乱，但是不是真正的打乱。做下测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">RandomShuffle</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">testResult</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">100000</span></span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="title class_">RandomShuffle</span>(arr)</span><br><span class="line">    <span class="keyword">let</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr)</span><br><span class="line">    res[key] ? res[key]++ : (res[key] = <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为了方便展示，转换成百分比</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> res) &#123;</span><br><span class="line">    res[key] = (res[key] / times) * <span class="number">100</span> + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testResult</span>()</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]: <span class="string">&quot;37.66%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]: <span class="string">&quot;12.57%&quot;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]: <span class="string">&quot;6.109%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]: <span class="string">&quot;6.343999999999999%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]: <span class="string">&quot;6.22%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]: <span class="string">&quot;31.097%&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出末尾数字是 3 的概率为 50%，而不是想象中的 33%。原因是因为 sort 函数底层是使用插入排序实现的。所以初始为[1,2,3]的时候，插入排序从 2 开始，和前面做比较，此时有 50%的几率顺序 50%的几率逆序，所以[1,2,3][2,1,3]出现几率都为 50%。接下来的操作如下图所示：<br><img src="/img/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95.png"></p>
<blockquote>
<p>Knuth-Durstenfeld 洗牌算法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">KnuthDurstenfeldShuffle</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 用结构赋值两项交换之前最好加 ;</span></span><br><span class="line">    ;[arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>选取数组(长度 n)中最后一个元素(arr[length-1])，将其与 n 个元素中的任意一个交换，此时最后一个元素已经确定</li>
<li>选取倒数第二个元素(arr[length-2])，将其与 n-1 个元素中的任意一个交换</li>
<li>重复第 1 2 步，直到剩下 1 个元素为止</li>
</ul>
<blockquote>
<p>Fisher-Yates 洗牌算法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 似乎有误</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">FisherYatesShuffle</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>)</span><br><span class="line">    result.<span class="title function_">push</span>(arr[randomIndex])</span><br><span class="line">    arr.<span class="title function_">splice</span>(randomIndex, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]: <span class="string">&quot;16.646%&quot;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]: <span class="string">&quot;16.633%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]: <span class="string">&quot;16.55%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]: <span class="string">&quot;16.787%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]: <span class="string">&quot;16.662%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]: <span class="string">&quot;16.722%&quot;</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>从还没处理的数组（假如还剩 n 个）中，产生一个[0, n]之间的随机数 random</li>
<li>从剩下的 n 个元素中把第 random 个元素取出到新数组中</li>
<li>删除原数组第 random 个元素</li>
<li>重复第 2 3 步直到所有元素取完</li>
<li>最终返回一个新的打乱的数组</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://dannykbsoul.github.io/2020/03/03/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/">洗牌算法</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/8593.html">如何测试洗牌程序</a><br><a target="_blank" rel="noopener" href="https://github.com/ccforward/cc/issues/44">洗牌算法(shuffle)的 js 实现</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/08/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/" data-id="clmniym85004nbb871vmsfmg2" data-title="洗牌算法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-博客项目上线部署" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/27/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" class="article-date">
  <time class="dt-published" datetime="2020-02-27T07:49:21.000Z" itemprop="datePublished">2020-02-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/27/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">博客项目上线部署总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过一番折腾之后项目终于上线了（喜极而泣，坑好多），博客项目部署在 <a target="_blank" rel="noopener" href="http://jacleklm.com/">JacleKlm.com</a>，先写一篇文章记录下近期的折腾所得吧。</p>
<h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p>买的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/season">腾讯云服务器</a>最便宜的那种，买域名，备案审批</p>
<p>云服务器中，更多-安全组-配置安全组-点连接，可以设置端口的开启及可以访问的人</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux 是一个性能稳定的多用户网络操作系统，经常用来跑服务器，eg. Linux + Nginx + MySQL + Node.js</p>
<h2 id="Linux-常见命令"><a href="#Linux-常见命令" class="headerlink" title="Linux 常见命令"></a>Linux 常见命令</h2><ul>
<li>Vim（用来打开文件）<ul>
<li>Vim 下，<code>i</code> 是进入编辑模式；<code>esc</code> 再<code>:wq</code> 是保存退出，<code>:q</code> 是退出，<code>:q!</code> 是强制退出；</li>
<li>Vim 查找。在 normal 模式下按下 <code>/</code> 即可进入查找模式，输入要查找的字符串并按下回车。在查找模式中加入 <code>\c</code> 表示大小写不敏感查找，<code>\C</code> 表示大小写敏感查找，例如： <code>/foo\c</code></li>
<li>Vim 翻页：<code>control+f</code>; <code>control+b</code></li>
</ul>
</li>
<li>查看开启的端口号<ul>
<li><code>netstat -tlnp</code></li>
</ul>
</li>
<li>查看当前路径<ul>
<li><code>pwd [-lp]</code></li>
</ul>
</li>
<li>查看端口号 <code>show global variables like &#39;port&#39;;</code></li>
<li>删除<ul>
<li><code>rm -rf svn/</code> 将会删除当前目录下的 svn&#x2F; 文件夹及其下所有文件夹，包括文件</li>
<li><code>rm -f /opt/test.txt</code> 将会强制删除 &#x2F;opt&#x2F;test.txt 这个文件</li>
</ul>
</li>
<li>解压文件 <code>unzip react-blog.zip</code></li>
<li>更换 node 版本</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin/</span><br><span class="line"><span class="comment">// 查看已有软连接：</span></span><br><span class="line">ll -all</span><br><span class="line"><span class="comment">// 删除旧node软连接</span></span><br><span class="line">rm -rf node</span><br><span class="line">rm -rf npm</span><br><span class="line">rm -rf cnpm</span><br><span class="line">cd ~</span><br><span class="line"><span class="comment">// 下载跟本地node版本相同的node</span></span><br><span class="line">wget <span class="attr">https</span>:<span class="comment">//nodejs.org/dist/v12.3.1/node-v12.3.1-linux-x64.tar.xz</span></span><br><span class="line"><span class="comment">// 解压安装包</span></span><br><span class="line">tar xvf node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64.<span class="property">tar</span>.<span class="property">xz</span></span><br><span class="line"><span class="comment">// 重建软连接</span></span><br><span class="line">ln -s /root/node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /root/node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class="line">sudo ln -s /root/node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64/bin/cnpm /usr/local/bin/cnpm</span><br></pre></td></tr></table></figure>

<p>更多常见命令详见 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/80UEbeEfPBV2LMmRqJFT7w">让你牛 B 加身的前端必会 Linux 命令</a><br>更多 Linux 教程也可见 <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程-菜鸟教程</a></p>
<h2 id="安装-cnpm"><a href="#安装-cnpm" class="headerlink" title="安装 cnpm"></a>安装 cnpm</h2><ul>
<li>Linux 安装 cnpm 后 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>
<li>sudo 创建软连接 <code>sudo ln -s /root/node-v&lt;版本号&gt;-linux-x64/bin/cnpm /usr/local/bin/cnpm</code></li>
</ul>
<h2 id="从-Mac-本地拷贝文件到云服务器"><a href="#从-Mac-本地拷贝文件到云服务器" class="headerlink" title="从 Mac 本地拷贝文件到云服务器"></a>从 Mac 本地拷贝文件到云服务器</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>eg. 在本地命令行执行 <code>scp -r /Users/chenjunjia/React/react_blog/admin.zip root@xx.xx.xx.xx:/root/blog</code> ，再输入服务器密码即可</p>
<h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p>参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/a419419/article/details/85050585">教程</a><br>eg. <code>Put React/react_blog/react-blog.zip /root/blog</code> 。注意这里的 <code>/User/chenjunjia/</code> 就被省略了（至少我的 Mac 中是这样）</p>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡</p>
<p>目前本项目的部署其实没用到 Nginx</p>
<h2 id="Nginx-常见命令"><a href="#Nginx-常见命令" class="headerlink" title="Nginx 常见命令"></a>Nginx 常见命令</h2><ul>
<li>启动<ul>
<li>直接法：<code>nignx</code> 。会没有任何返回信息，这是成功状态。此时用 <code>ps aux | grep nginx</code> 看 nginx 的启动信息</li>
<li>用通用的 Linux 命令：<code>systemctl start nginx.service</code></li>
</ul>
</li>
<li>关闭<ul>
<li>最常用：<code>nginx -s quit</code></li>
<li>不常用的关闭（关闭效果等级从轻到重）：<code>nginx -s stop</code>，<code>killall nginx</code>, <code>systemctl stop nginx.service</code></li>
</ul>
</li>
<li>重启（修改 Nginx 文件后都要重启）<ul>
<li><code>nginx -s reload</code></li>
<li><code>systemctl restart nginx.service</code></li>
</ul>
</li>
</ul>
<h2 id="Nginx-基础配置文件"><a href="#Nginx-基础配置文件" class="headerlink" title="Nginx 基础配置文件"></a>Nginx 基础配置文件</h2><p>配置文件 <code>/etc/nginx/nginx.config</code> ，用 vim 打开后看内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">user  nginx;</span><br><span class="line"># <span class="title class_">Nginx</span>进程，一般设置为和<span class="variable constant_">CPU</span>核数一样</span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"># 错误日志存放目录</span><br><span class="line">error_log  /<span class="keyword">var</span>/log/nginx/error.<span class="property">log</span> warn;</span><br><span class="line"># 进程pid存放位置</span><br><span class="line">pid        /<span class="keyword">var</span>/run/nginx.<span class="property">pid</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  <span class="number">1024</span>; # 单个后台进程的最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.<span class="property">types</span>;   # 文件扩展名与类型映射表</span><br><span class="line">    default_type  application/octet-stream;  # 默认文件类型</span><br><span class="line">    #设置日志模式</span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /<span class="keyword">var</span>/log/nginx/access.<span class="property">log</span>  main;   # nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile        on;   # 开启高效传输模式</span><br><span class="line">    #tcp_nopush     on;    # 减少网络报文段的数量</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;  # 保持连接的时间，也叫超时时间</span><br><span class="line"></span><br><span class="line">    #gzip  on;  # 开启gzip压缩</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.<span class="property">d</span><span class="comment">/*.conf; #包含的子配置项位置和文件</span></span><br></pre></td></tr></table></figure>

<p>用 vim 打开 include 的子配置项文件 <code>/etc/nginx/conf.d/default.config</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;   # 配置监听端口</span><br><span class="line">    server_name  localhost;  <span class="comment">//配置域名</span></span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /<span class="keyword">var</span>/log/nginx/host.<span class="property">access</span>.<span class="property">log</span>  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;     # 服务默认启动目录</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;    # 默认访问文件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  <span class="number">404</span>              /<span class="number">404.</span>html;   # 配置<span class="number">404</span>页面</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the <span class="keyword">static</span> page /50x.<span class="property">html</span></span><br><span class="line">    #</span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.<span class="property">html</span>;   #错误状态码的显示页面。现在是这几种错误都是用现实这个html文件</span><br><span class="line">    location = /50x.<span class="property">html</span> &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cd 到 <code>/usr/share/nginx/html</code> 默认文件夹，对 index.html 默认文件编辑并保存，然后用 nginx 命令即能启动服务器。访问 ip 地址就能看到内容了</p>
<p>同理编辑 <code>/usr/share/nginx/html/404.html</code> 是 404 时显示的页面；也可以让 404 指向其他页面：<code>error_page 404 http://github.com;</code></p>
<h2 id="Nginx-实现访问控制"><a href="#Nginx-实现访问控制" class="headerlink" title="Nginx 实现访问控制"></a>Nginx 实现访问控制</h2><blockquote>
<p>nginx 的指令是谁写在前面就谁先生效（如果有冲突）</p>
</blockquote>
<p>只允许某个主机进行访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123; <span class="comment">// 这里的 / 是全部的意思</span></span><br><span class="line">        allow  xx.<span class="property">xx</span>.<span class="property">xx</span>.<span class="property">xx</span>;  <span class="comment">//  // 允许访问的ip</span></span><br><span class="line">        deny   all; <span class="comment">// 也可以是某个ip</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>/</code> 是全部的意思；改成 <code>=/img</code> 则是网站下的 img 目录；也可以用正则，<code>~\.php$</code></p>
<h2 id="Ngingx-设置虚拟机"><a href="#Ngingx-设置虚拟机" class="headerlink" title="Ngingx 设置虚拟机"></a>Ngingx 设置虚拟机</h2><p>通过设置虚拟主机，一台云服务器也能同时跑好几个 Web 服务器。配置虚拟主机可以基于端口号，基于 IP，基于域名。最常用的是基于域名设置虚拟机<br>都是改 <code>/etc/nginx/conf.d/default.config</code> 配置文件</p>
<h3 id="基于端口号"><a href="#基于端口号" class="headerlink" title="基于端口号"></a>基于端口号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">8001</span>;</span><br><span class="line">        server_name localhost; <span class="comment">// localhost:8001端口新开虚拟机</span></span><br><span class="line">        root /usr/share/nginx/html/html8001;</span><br><span class="line">        index index.<span class="property">html</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑 <code>/usr/share/nginx/html/html8001</code> 下的 index.html ，即可访问 8001 端口了</p>
<h3 id="基于端-IP"><a href="#基于端-IP" class="headerlink" title="基于端 IP"></a>基于端 IP</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name xx.<span class="property">xx</span>.<span class="property">xx</span>.<span class="property">xx</span>; <span class="comment">// 某新ip</span></span><br><span class="line">        root /usr/share/nginx/html/html8001;</span><br><span class="line">        index index.<span class="property">html</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于域名（最常用）"><a href="#基于域名（最常用）" class="headerlink" title="基于域名（最常用）"></a>基于域名（最常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name xxx.<span class="property">com</span>; <span class="comment">// 如果有多个域名就可以配多个</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                root /usr/share/nginx/html/html8001;</span><br><span class="line">                index index.<span class="property">html</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-实现反向代理"><a href="#Nginx-实现反向代理" class="headerlink" title="Nginx 实现反向代理"></a>Nginx 实现反向代理</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>正向代理（为客户端做代理）：普通的 proxy 代理，把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做 proxy 服务器，再转发给客户。eg. 翻墙（你没有权限，但是 proxy 服务器有权限）<br><img src="/img/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png"><br>反向代理（为服务器做代理）：反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。<br><img src="/img/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png"></p>
<h3 id="反向代理的用途和好处"><a href="#反向代理的用途和好处" class="headerlink" title="反向代理的用途和好处"></a>反向代理的用途和好处</h3><ul>
<li>安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。</li>
<li>功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配。</li>
</ul>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123; <span class="comment">// 访问 nginx2.jspang.com 反向代理到 jspang.com 这个网站。所以当我们访问nginx2.jspang.com的时候呈现的是jspang.com的内容</span></span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name nginx2.<span class="property">jspang</span>.<span class="property">com</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">               proxy_pass <span class="attr">http</span>:<span class="comment">//jspang.com;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-适配-PC-或移动设备"><a href="#Nginx-适配-PC-或移动设备" class="headerlink" title="Nginx 适配 PC 或移动设备"></a>Nginx 适配 PC 或移动设备</h2><p>大型网站，eg. 淘宝和京东的网站，根据 PC 端或移动端会有不同的站点，而不是用自适应布局。<br>用 Nginx 的 <code>$http_user_agent</code> 可以获取到客户端的 userAgent ，进而展示不同的页面给用户</p>
<h1 id="Linux-中搭建-MYSQL"><a href="#Linux-中搭建-MYSQL" class="headerlink" title="Linux 中搭建 MYSQL"></a>Linux 中搭建 MYSQL</h1><p>安装，搜教程</p>
<h2 id="Linux-操作数据库命令大全（结尾一定要带分号！）"><a href="#Linux-操作数据库命令大全（结尾一定要带分号！）" class="headerlink" title="Linux 操作数据库命令大全（结尾一定要带分号！）"></a>Linux 操作数据库命令大全（结尾一定要带分号！）</h2><p>参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/10/18/2216279.html">博客 1</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/stamhe/article/details/3924638">博客 2</a></p>
<ul>
<li>开启 mysql <code>service mysqld start</code>，<code>mysql -u root</code></li>
<li>关闭 <code>mysql&gt; exit;</code></li>
<li>进入 mysql 后，使用 SHOW 语句找出在服务器上当前存在什么数据库 <code>mysql&gt; SHOW DATABASES;</code></li>
<li>创建一个数据库 test <code>mysql&gt; CREATE DATABASE test character set utf8;</code></li>
<li>选择你所创建的数据库 <code>mysql&gt; USE test;</code></li>
<li>使用 SHOW 语句看数据库有几个表 <code>mysql&gt; SHOW TABLES;</code></li>
<li>创建一个表 <code>CREATE TABLE mytable (name VARCHAR(20), sex CHAR(1),birth DATE, birthaddr VARCHAR(20));</code><br>CREATE TABLE <code>type</code> (<br><code>id</code> int(10) unsigned NOT NULL auto_increment,<br><code>flag_deleted</code> enum(‘Y’,’N’) character set utf8 NOT NULL default ‘N’,<br><code>flag_type</code> int(5) NOT NULL default ‘0’,<br><code>type_name</code> varchar(50) character set utf8 NOT NULL default ‘’,<br>PRIMARY KEY (<code>id</code>)<br>) DEFAULT CHARSET&#x3D;utf8;</li>
<li>显示表的结构 <code>mysql&gt; DESCRIBE mytable;</code></li>
<li>用 SELECT 命令来查看表中的数据 <code>mysql&gt; select * from mytable;</code></li>
<li>给表加入数据 <code>mysql&gt; insert into mytable values (′jacle′,′m′,′1996-02-04′,′china′);</code><br>insert into test values (2,’jacle2’);</li>
<li>用文本方式将数据装入一个数据库。创建一个文本文件“mysql.txt”，每行包含一个记录，用定位符(tab)把值分开，并且以在 CREATE TABLE 语句中列出的列次序给出,例如<br>abccs f 1977-07-07 china 　<br>mary f 1978-12-12 usa<br>tom m 1970-09-02 usa<br>使用下面命令将文本文件“mytable.txt”装载到 mytable 表中:<br><code>mysql&gt; LOAD DATA LOCAL INFILE &quot;/data/mytable.txt” INTO TABLE mytable;</code></li>
<li>修改表结构，更详见 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a6771d05ad59">博客 3</a>，其中添加字段是 <code>ALTER TABLE &lt;表名&gt; ADD &lt;字段名称&gt; &lt;字段定义&gt;</code></li>
<li>删除表 <code>DROP TABLE table_name ;</code></li>
<li>查看表的编码 <code>show create table &lt;表名&gt;;</code></li>
<li>修改数据库成 utf8 的 <code>mysql&gt; alter database name character set utf8;</code></li>
<li>修改表默认用 utf8 <code>mysql&gt; alter table type character set utf8;</code></li>
<li>修改字段用 utf8 <code>mysql&gt; alter table type modify type_name varchar(50) CHARACTER SET utf8;</code></li>
<li>更新数据 <code>UPDATE &lt;表名&gt; SET id=2 WHERE type_id=2;</code></li>
</ul>
<h2 id="一些-bug"><a href="#一些-bug" class="headerlink" title="一些 bug"></a>一些 bug</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lkforce/article/details/79006838">mysql 的 char，varchar，text 类型的区别总结</a><br>Linux 中 mysql 表无法写入中文，解决方法是 varchar 类型建议用 utf-8</p>
<h1 id="Linux-中搭建-Node-js-，npm-和-PM2"><a href="#Linux-中搭建-Node-js-，npm-和-PM2" class="headerlink" title="Linux 中搭建 Node.js ，npm 和 PM2"></a>Linux 中搭建 Node.js ，npm 和 PM2</h1><p>安装方法自行谷歌</p>
<h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><p>pm2 是一个带有负载均衡功能的应用进程管理器，也可以用来做进程守护。<a target="_blank" rel="noopener" href="https://juejin.im/post/5be406705188256dbb5176f9">pm2 简易使用手册</a></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>查看进程 <code>pm2 list</code></li>
<li>停止所有 <code>pm2 stop all</code></li>
<li>运行某个 node 文件 <code>pm2 start xxx.js</code></li>
<li>运行项目 <code>pm2 start npm —- run start/dev</code></li>
<li>重启 <code>pm2 restart XXX</code></li>
<li>停止 <code>pm2 stop XXX</code></li>
<li>删除 <code>pm2 delete XXX</code></li>
<li>查看某个进程&#x2F;应用具体情况 <code>pm2 describe Travel</code></li>
<li>查看进程&#x2F;应用的资源消耗情况 <code>pm2 monit</code></li>
<li>查看所有日志 <code>pm2 logs (Travel)</code></li>
<li>查看 7001 端口的进程 （PID 就是进程 id）<code>lsof -i:7001</code></li>
<li>关闭进程 <code>kill -9 &lt;进程id&gt;</code></li>
</ul>
<h3 id="pm2-项目管理"><a href="#pm2-项目管理" class="headerlink" title="pm2 项目管理"></a>pm2 项目管理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;项目目录&gt;</span><br><span class="line"><span class="comment">// 在项目目录生成pm2配置文件：ecosystem.config.js。改该文件的name属性为自定义进程名字，script属性为react项目npm run start时执行的脚本（需要先npm run eject才会出现这个脚本）</span></span><br><span class="line">pm2 ecosystem</span><br><span class="line"><span class="comment">// 执行进程</span></span><br><span class="line">pm2 start ecosystem.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line"><span class="comment">// 查看执行的进程，发现会有自定义名字的进程</span></span><br><span class="line">pm2 list</span><br></pre></td></tr></table></figure>

<h1 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h1><blockquote>
<p>每次更改项目后应该先 build，再用 pm2 start；测试的时候应该用 dev</p>
</blockquote>
<h2 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h2><p>对于博客项目，前台是 Next.js 项目，拷贝之后先 <code>build</code> ，然后再 <code>pm2 start npm — run start</code> 就可以了<br>http 默认是 80 端口，可以把前台项目改成 80 端口；其次，你还要在安全组开放相关的端口才能成功访问的（其实我没做这一步）</p>
<h2 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h2><p>中台是 Egg.js 项目，直接 npm run start 就行（自带进程守护）。中台连接云服务器数据库方法暂时是把 <code>config.default.js</code> 改成下面如下配置，可以通过 IP 或者域名+端口号访问接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config.<span class="property">cluter</span> = &#123;</span><br><span class="line">  <span class="attr">listen</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span> <span class="comment">// 其实就是localhost</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><p>后台是 React 项目，是直接用 pm2 进行管理直接 start</p>
<h1 id="踩坑集合"><a href="#踩坑集合" class="headerlink" title="踩坑集合"></a>踩坑集合</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul>
<li>前后台项目中请求应该以服务器 ip 地址为准，而不是 localhost</li>
<li>数据中台的跨域设置是参考<a target="_blank" rel="noopener" href="https://github.com/eggjs/egg/issues/3160">该贴</a>，最后配置如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只想让 domainWhiteList 的可以跨域，那就不用配置 origin</span></span><br><span class="line">config.<span class="property">security</span> = &#123;</span><br><span class="line">  <span class="attr">csrf</span>: &#123; <span class="attr">enable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  <span class="attr">domainWhiteList</span>: [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你要用 origin: &#x27;*&#x27; 又想带 withCredentials，配置改成这样</span></span><br><span class="line">config.<span class="property">cors</span> = &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">origin</span>: <span class="function"><span class="params">ctx</span> =&gt;</span> ctx.<span class="title function_">get</span>(<span class="string">&#x27;origin&#x27;</span>),</span><br><span class="line">  <span class="attr">allowMethods</span>: <span class="string">&#x27;GET, HEAD, PUT, POST, DELETE, PATCH, OPTIONS&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改项目默认接口"><a href="#修改项目默认接口" class="headerlink" title="修改项目默认接口"></a>修改项目默认接口</h2><ul>
<li>React 项目修改默认接口：<code>node_modules</code> 文件夹里的可以看到 <code>react-scripts</code> 文件夹，在 <code>start.js</code> 里可以找到修改端口的代码。直接搜索 <code>||</code></li>
<li>Next 项目改默认端口是直接在<code>script</code>命令最后加 <code>-p &lt;端口号&gt;</code></li>
</ul>
<h2 id="React-项目-TypeError-ERR-INVALID-ARG-TYPE-The-“path”-argument-must-be-of-type-string-Received-type-undefined"><a href="#React-项目-TypeError-ERR-INVALID-ARG-TYPE-The-“path”-argument-must-be-of-type-string-Received-type-undefined" class="headerlink" title="React 项目 TypeError [ERR_INVALID_ARG_TYPE]: The “path” argument must be of type string. Received type undefined"></a>React 项目 TypeError [ERR_INVALID_ARG_TYPE]: The “path” argument must be of type string. Received type undefined</h2><p>react-scripts 版本问题，升级到 3.4.0。果然成功了！！！哭了！</p>
<p>参考文章<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/80UEbeEfPBV2LMmRqJFT7w">让你牛 B 加身的前端必会 Linux 命令-奇舞团</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程-菜鸟教程</a><br><a target="_blank" rel="noopener" href="https://jspang.com/detailed?id=39">一个前端必会的 Nginx 免费教程-技术胖</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5be406705188256dbb5176f9">pm2 简易使用手册</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/27/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" data-id="clmniym7o003gbb87533e2sut" data-title="博客项目上线部署总结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React小结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/04/React%E5%B0%8F%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2020-02-04T06:50:21.000Z" itemprop="datePublished">2020-02-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/04/React%E5%B0%8F%E7%BB%93/">React基本原理 &amp; 一些特性 &amp; 性能优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="Virtual-Dom"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom</h2><p>虚拟 DOM 本质上是 JavaScript 对象,是对真实 DOM 的抽象，状态变更时，通过 diff 算法计算出记录新树和旧树的差异，最后把差异更新到真正的 dom 中</p>
<h3 id="虚拟-DOM-的实现"><a href="#虚拟-DOM-的实现" class="headerlink" title="虚拟 DOM 的实现"></a>虚拟 DOM 的实现</h3><p>相较于 DOM 来说，<strong>操作 JS 对象会快很多</strong>，并且我们也可以通过 JS 来模拟 DOM</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对应的 DOM 就是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="keyword">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>那么既然 DOM 可以通过 <strong>JS 对象来模拟</strong>，反之也可以<strong>通过 JS 对象来渲染出对应的 DOM</strong>。难点在于如何<strong>判断新旧两个 JS 对象的最小差异</strong>并且<strong>实现局部更新</strong> DOM。这就需要 Diff 算法了</p>
<h3 id="虚拟-DOM-真的能提升性能吗？"><a href="#虚拟-DOM-真的能提升性能吗？" class="headerlink" title="虚拟 DOM 真的能提升性能吗？"></a>虚拟 DOM 真的能提升性能吗？</h3><p>使用虚拟 DOM，<strong>在 DOM 阶段操作少了通讯的确是变高效了，但代价是在 JS 阶段需要完成额外的工作</strong>（diff 计算），这项额外的工作是需要耗时的！<br>虚拟 DOM<strong>并不是说比原生 DOM API 的操作快，而是说不管数据怎么变化，都可以以最小的代价来进行更新 DOM</strong>。在每个点上，其实用手工的原生方法会比 diff 好很多。比如说仅仅是修改了一个属性，需要整体重绘吗？显然这不是虚拟 DOM 提出来的意义。框架的意义在于掩盖底层的 DOM 操作，用更声明式的方式来描述，从而让代码更容易维护。</p>
<h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20346379">详解</a><br>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n3)。React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是<strong>只对比同层的节点，而不是跨层对比</strong>，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步</p>
<ul>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引 ，便于最后渲染差异</li>
<li>一旦节点有子元素，就去判断子元素是否有不同</li>
</ul>
<p>在第一步算法中，需要判断新旧节点的 tagName 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 tagName 的话，就需要判断是否有子元素，有的话就进行第二步算法。<br>在第二步算法中，需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。<br>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][</span><br><span class="line">  <span class="comment">// 这里替换上面的 li</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。<br>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 key 这个属性。<strong>这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点</strong>。<br>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。<br>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。</p>
<h2 id="如何正确使用key"><a href="#如何正确使用key" class="headerlink" title="如何正确使用key"></a><a target="_blank" rel="noopener" href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/React%E4%B8%ADkey%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.html#_1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8key">如何正确使用key</a></h2><h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36062486">详解</a><br><img src="/img/React%E5%8E%9F%E7%90%86/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"><br>React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p>
<h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段:"></a>挂载阶段:</h3><ul>
<li>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化 state 对象或者给自定义方法绑定 this</li>
<li>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState),这是个静态方法,当我们接收到新的属性想去修改我们 state，可以使用 getDerivedStateFromProps</li>
<li>render: render 函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等内容</li>
<li>componentDidMount: 组件装载之后调用，此时我们可以获取到 DOM 节点并操作，比如对 canvas，svg 的操作，<strong>服务器请求，订阅</strong>都可以写在这个里面，但是记得在 componentWillUnmount 中取消订阅</li>
</ul>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段:"></a>更新阶段:</h3><ul>
<li>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</li>
<li>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState),有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利用此生命周期来优化 React 程序性能</li>
<li>render: 更新阶段也会触发此生命周期</li>
<li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState),这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有一个返回值，会作为第三个参数传给 componentDidUpdate，如果你不想要返回值，可以返回 null，此生命周期必须与 componentDidUpdate 搭配使用</li>
<li>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot),该方法在 getSnapshotBeforeUpdate 方法之后被调用，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。</li>
</ul>
<h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段:"></a>卸载阶段:</h3><ul>
<li>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的 DOM 元素等垃圾清理工作</li>
</ul>
<h3 id="废弃"><a href="#废弃" class="headerlink" title="废弃"></a>废弃</h3><p>React 16 之后有三个生命周期被废弃(但并未删除)：componentWillMount，componentWillReceiveProps，componentWillUpdate</p>
<h3 id="周期内禁忌的事"><a href="#周期内禁忌的事" class="headerlink" title="周期内禁忌的事"></a>周期内禁忌的事</h3><ul>
<li>componentWillMount 里 请求数据，订阅，setState</li>
</ul>
<h2 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h2><p>ReaxtV16 版本中引入了 Fiber 机制，生命周期部分发生变化。<br>React Fiber 是一种基于浏览器的单线程调度算法.<br>React 16之前 ，diff 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归。Fiber将diff拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算<br>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新<br>异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。<br>Reconciliation 阶段</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
</ul>
<p>Commit 阶段</p>
<ul>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>因为 Reconciliation 阶段是可以被打断的，所以 Reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。由此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。</p>
<ul>
<li>getDerivedStateFromProps 用于替换 componentWillReceiveProps ，该函数会在初始化和 update 时被调用</li>
<li>getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据。</li>
</ul>
<h2 id="setState-机制"><a href="#setState-机制" class="headerlink" title="setState 机制"></a>setState 机制</h2><p>PS: useState 它不香吗</p>
<h3 id="理想情况："><a href="#理想情况：" class="headerlink" title="理想情况："></a>理想情况：</h3><p>setState 是“异步”的，调用 setState 只会提交一次 state 修改到队列中，不会直接修改 this.state，等到满足一定条件时，react 会合并队列中的所有修改，触发一次 update 流程，更新 this.state。因此 setState 机制减少了 update 流程的触发次数，从而提高了性能。所以会有以下情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化 `count` 为 0</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以通过以下方式来实现调用三次 setState 使得 count 为 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span> &#125;))</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 setState 会触发 update 过程，因此在 update 过程中必经的生命周期中调用 setState 会存在循环调用的风险。</p>
<p>另外用于监听 state 更新完成，可以使用 setState 方法的第二个参数，回调函数。在这个回调中读取 this.state 就是已经批量更新后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span> &#125;), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h3><p>在实际开发中，setState 的表现有时会不同于理想情况。主要是以下两种</p>
<ul>
<li>在 mount 流程中调用 setState。</li>
<li>在 setTimeout&#x2F;Promise 回调中调用 setState。</li>
</ul>
<p>在第一种情况下，不会进入 update 流程，队列在 mount 时合并修改并 render<br>在第二种情况下，setState 将不会进行队列的批更新，而是直接触发一次 update 流程。这是由于 setState 的两种更新机制导致的，只有在批量更新模式中，才会是“异步”的。</p>
<h2 id="React-事件机制"><a href="#React-事件机制" class="headerlink" title="React 事件机制"></a>React 事件机制</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5bd32493f265da0ae472cc8e">更详细的源码解析版</a><br>React 其实自己实现了一套事件机制，首先我们考虑一下以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params">&#123; list, handleClick &#125;</span>) =&gt; (&#123;</span><br><span class="line">    list.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;index&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    ))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的点击事件是否绑定在了每一个标签上？当然不是，JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过<strong>事件代理</strong>的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p>
<p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此在React中，用 return false阻止默认行为，而应该在事件处理程序中调用 event.preventDefault 或 event.stopPropagation 来阻止冒泡（所以也不会有兼容性问题）</p>
<p>合成事件的优点</p>
<ul>
<li>抹平了浏览器之间的兼容问题</li>
<li>性能优化。对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象</li>
</ul>
<h1 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h1><h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><p><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/12/29/React%E7%BB%84%E4%BB%B6/">见此博文</a></p>
<h2 id="React-Router-React-Redux"><a href="#React-Router-React-Redux" class="headerlink" title="React Router &amp; React Redux"></a>React Router &amp; React Redux</h2><p><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2020/01/04/React%E8%B7%AF%E7%94%B1%20&%20Redux/">见此博文</a></p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><ul>
<li>父子组件通信：单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过调用父组件函数的方式告知父组件修改数据</li>
<li>兄弟组件通信：可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件</li>
<li>跨多层次组件通信<ul>
<li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/context.html">Context API</a>。此外，还可以通过 context 传递一个函数，使得 consumers 组件更新 context<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Context，可以在开始就传入值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StateContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// value 就是传入 Context 中的值</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">StateContext.Provider</span> <span class="attr">value</span>=<span class="string">&#x27;yck&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">StateContext.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        // 取出值</span></span><br><span class="line"><span class="language-xml">        &#123;context =&gt; (</span></span><br><span class="line"><span class="language-xml">          name is &#123; context &#125;</span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">useContext</a>不香吗，其实是同理的</li>
</ul>
</li>
<li>任意组件：Redux等状态管理工具 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</li>
</ul>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/render-props.html">render props</a></h2><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>react 中性能主要耗费在于 update 阶段的 diff 算法，因此性能优化也主要是减少 diff 算法触发次数</p>
<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p>setState 机制在正常运行时，由于批更新策略，已经降低了 update 过程的触发次数。<br>因此，setState 优化主要在于非批更新阶段中(timeout&#x2F;Promise 回调)，减少 setState 的触发次数。<br>常见的业务场景即处理接口回调时，无论数据处理多么复杂，保证最后只调用一次 setState</p>
<h2 id="父组件-Render"><a href="#父组件-Render" class="headerlink" title="父组件 Render"></a>父组件 Render</h2><p>当组件的 state 或 props 变化时，自身 render() 会重新执行<br>父组件的 render 必然会触发子组件 render，子组件会进入 update 阶段（无论 props 是否更新）</p>
<ul>
<li>此时最常用的优化方案即为 shouldComponentUpdate 方法。在 shouldComponentUpdate 函数中我们可以通过返回布尔值来决定当前组件是否需要更新，一般来说不推荐完整地对比当前 state 和之前的 state 是否相同，一般只比较 stated 某个或某几个值。最常见的方式为进行 this.props 和 this.state 的浅比较来判断组件是否需要更新，如下，组件只有当 props.color 或者 state.count 的值改变才会更新</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">color</span> !== nextProps.<span class="property">color</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> !== nextState.<span class="property">count</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>PureComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>或者直接使用 PureComponent，原理一致</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>PureComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数组件用不了 shouldComponentUpdate，可以使用 React.memo 来实现相同的功能</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Test</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>PureComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<h2 id="DOM-操作方面减少-diff"><a href="#DOM-操作方面减少-diff" class="headerlink" title="DOM 操作方面减少 diff"></a>DOM 操作方面减少 diff</h2><ul>
<li>不使用跨层级移动节点的操作</li>
<li>对于条件渲染多个节点时，尽量采用隐藏等方式切换节点，而不是替换节点</li>
<li>尽量避免将后面的子节点移动到前面的操作，当节点数量较多时，会产生一定的性能问题</li>
</ul>
<h1 id="React的优点"><a href="#React的优点" class="headerlink" title="React的优点"></a>React的优点</h1><h2 id="React速度很快"><a href="#React速度很快" class="headerlink" title="React速度很快"></a>React速度很快</h2><p>它并不直接对DOM进行操作，引入了一个叫做虚拟DOM的概念，安插在javascript逻辑和实际的DOM之间，性能好。最大限度减少DOM交互。</p>
<h2 id="跨浏览器兼容"><a href="#跨浏览器兼容" class="headerlink" title="跨浏览器兼容"></a>跨浏览器兼容</h2><p>虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的</p>
<h2 id="一切都是component"><a href="#一切都是component" class="headerlink" title="一切都是component"></a>一切都是component</h2><p>代码更加模块化，重用代码更容易，可维护性高。这样当某个或某些组件出现问题是，可以方便地进行隔离。每个组件都可以进行独立的开发和测试，并且它们可以引入其它组件。这等同于提高了代码的可维护性。</p>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。减少了重复代码，这也是它为什么比传统数据绑定更简单。</p>
<h2 id="同构、纯粹的javascript"><a href="#同构、纯粹的javascript" class="headerlink" title="同构、纯粹的javascript"></a>同构、纯粹的javascript</h2><p>因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</p>
<h2 id="兼容性好"><a href="#兼容性好" class="headerlink" title="兼容性好"></a>兼容性好</h2><p>比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。Vue 首先考虑的是假设用户只掌握了 web 基础知识 (HTML, CSS, JS) 的情况下，如何能够最快理解和上手，实现一个看得见摸得着的应用</p>
<h1 id="React设计模式"><a href="#React设计模式" class="headerlink" title="React设计模式"></a>React设计模式</h1><p>见<a target="_blank" rel="noopener" href="https://sangka.github.io/react-in-patterns-cn/chapter-2/">React模式</a>。这篇文章写的非常好，观点简明扼要。看完想写一篇笔记发现这篇文章已经总结的很精简了，直接多看几遍吧吧233</p>
<blockquote>
<p>单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已</p>
</blockquote>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015648248">react 基本原理及性能优化</a><br><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/optimizing-performance.html">React 官方文档-性能优化</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36062486">React v16.3 版本新生命周期函数浅析及升级方案</a><br>前端面试之道<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5bd32493f265da0ae472cc8e">React事件机制源码解析</a><br><a target="_blank" rel="noopener" href="http://www.conardli.top/blog/">conardli</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/04/React%E5%B0%8F%E7%BB%93/" data-id="clmniym76001ubb8748oy1zto" data-title="React基本原理 &amp; 一些特性 &amp; 性能优化" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-博客项目小结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2020-01-29T07:49:21.000Z" itemprop="datePublished">2020-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/">博客项目小结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>该项目是<a target="_blank" rel="noopener" href="https://jspang.com/">技术胖</a>的一个项目，涉及了前台中台后台，觉得是个不错的练手项目.</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>博客前台： React Hooks + Next.js + marked + highlight + Ant Design<br>数据中台： Egg.js（阿里的一个基于 Koa2 的框架） + MySQL<br>管理后台： React Hooks + Ant Design （不用 Next.js）</p>
<blockquote>
<p>Next.js 是一个轻量级的 React 服务端渲染应用框架。有了它我们可以简单轻松的实现 React 的服务端渲染，从而加快首屏打开速度，也可以作 SEO（搜索引擎优化了）。并且路由，webpack 配置等也是框架配置好的。<br>个人看法：配置太全了，自己写着玩的项目还好，企业级的项目用起来可能不够灵活。</p>
</blockquote>
<h1 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>组件内的布局基本都是用 Antd 的 栅格-响应式布局 ，<code>&lt;Col&gt;</code> 的 xs，sm 等这些属性本质上是媒介查询；给 <code>&lt;Row&gt;</code> 添加属性实现 flex 布局 <code>type=&quot;flex&quot; justify=&quot;center&quot;</code></p>
<p>组件一般都是用 Antd 的组件组合而成</p>
<h2 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h2><p>数据来源于请求中台接口</p>
<h3 id="函数组件的-getInitialProps-方法写一个-promise-并返回-promise-的结果（Next-js-框架）"><a href="#函数组件的-getInitialProps-方法写一个-promise-并返回-promise-的结果（Next-js-框架）" class="headerlink" title="函数组件的 getInitialProps 方法写一个 promise 并返回 promise 的结果（Next.js 框架）"></a>函数组件的 <code>getInitialProps</code> 方法写一个 promise 并返回 promise 的结果（Next.js 框架）</h3><p><a target="_blank" rel="noopener" href="https://nextjs.frontendx.cn/docs/#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%8F%8A%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">文档</a><br>该方法返回的应该是一个普通的 JS 对象；不能用于子组件中，只能用于 pages 页面组件中；该方法只会加载在服务端，所以在该方法中 console 是不会显示的；</p>
<p>该方法用于一开始就请求一次的数据（之后不用请求了），然后 promise 的 resolve 的结果这个对象，会变成函数组件的 props 对象。例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [mylist, setMylist] = <span class="title function_">useState</span>(props.<span class="property">data</span>)</span><br><span class="line">  <span class="comment">// ...组件逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数组件外</span></span><br><span class="line"><span class="title class_">Home</span>.<span class="property">getInitialProps</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">axios</span>(servicePath.<span class="property">getArticleList</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>) <span class="comment">// resovle()的结果这个对象变成上面的props对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法其实和写在最普通的 useEffect 的写法效果一样</p>
<h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>中台安装 egg-cors ，并做相应配置。本质是设置 Access-Control-Allow-Origin</p>
<h3 id="跨域白名单"><a href="#跨域白名单" class="headerlink" title="跨域白名单"></a>跨域白名单</h3><p><em>Egg.js 的跨域不支持白名单，只支持单个域名，这样前后台项目不能一起跑。解决方案是需要自己写一个中间件实现白名单，这是别人写的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fa5f80924e97">中间件</a>，<a target="_blank" rel="noopener" href="https://github.com/temool/egg-origin">Github</a>，这里直接用了这个中间件</em></p>
<blockquote>
<p>最后线上版本舍弃了这个插件，见博客项目上线部署博文的 跨域</p>
</blockquote>
<h2 id="涉及-id-的页面"><a href="#涉及-id-的页面" class="headerlink" title="涉及 id 的页面"></a>涉及 id 的页面</h2><p>像不同种类的列表页，文章详情页这种涉及 id 的页面，路由设置 和 数据获取 稍微复杂一些</p>
<p>例如，列表页中每篇文章的标题，是一个带 id 的 <code>&lt;Link&gt;</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-title&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;&#123;</span> <span class="attr">pathname:</span> &#x27;/<span class="attr">detailed</span>&#x27;, <span class="attr">query:</span> &#123; <span class="attr">id:</span> <span class="attr">item.id</span> &#125; &#125;&#125;&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击后跳转带详情页，所以详情页的 <code>getInitialProps</code> 获取数据的时候是根据路由的 id 去 post</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Detailed</span>.<span class="property">getInitialProps</span> = <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> id = context.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">axios</span>(servicePath.<span class="property">getArticleById</span> + id).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>.<span class="property">data</span>[<span class="number">0</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的接口则是由文章的 id 在数据库查询</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getArticleById</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">&#x27;SELECT article.id as id,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.title as title,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.introduce as introduce,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.article_content as article_content,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.view_count as view_count ,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;type.typeName as typeName ,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;type.id as typeId &#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;FROM article LEFT JOIN type ON article.type_id = type.Id &#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;WHERE article.id=&#x27;</span> + id;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">query</span>(sql);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">body</span> = &#123; <span class="attr">data</span>: result &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>PS：前端在路由跳转的时候（<code>Router.push()</code> 或 <code>&lt;Link href=‘xx’&gt;</code>)，路由地址最后得是 <code>xx?id=1</code> 这样，而不是 <code>xx/?id=1</code>。但是后端在配置接口的时候依旧是 <code>xx/:id</code></p>
<h2 id="详情页-中对-Markdown-语法的解析"><a href="#详情页-中对-Markdown-语法的解析" class="headerlink" title="详情页 中对 Markdown 语法的解析"></a>详情页 中对 Markdown 语法的解析</h2><p>把从数据库取出来的 markdown 语法的字符串，编译成正常的文章并显示样式，是用 <a target="_blank" rel="noopener" href="https://github.com/markedjs/marked">marked</a> + <a target="_blank" rel="noopener" href="https://github.com/highlightjs/highlight.js/">heighlight.js</a></p>
<h2 id="详情页-中的-导航目录组件"><a href="#详情页-中的-导航目录组件" class="headerlink" title="详情页 中的 导航目录组件"></a>详情页 中的 导航目录组件</h2><p>效果如下所示：<br><img src="/img/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6.png"><br>把这个组件固定在页面右侧是用了 Antd 的 Affix 固钉 组件，Anchor 锚点</p>
<p>解析文章内容生成目录是用了阿里的一个插件 tocify.tsx</p>
<h1 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h1><h2 id="概况-RESTful-规范"><a href="#概况-RESTful-规范" class="headerlink" title="概况 &amp; RESTful 规范"></a>概况 &amp; RESTful 规范</h2><p>配置了两套路由，<code>/default/</code>开头的用于前台，<code>/admin/</code>开头的用于后台<br>所有数据的获得和业务逻辑的操作都是通过中台实现的，也就是说中台只提供接口，这里的设计我们采用 RESTful 的规则，让 egg 为前端提供 Api 接口，实现中台主要的功能</p>
<blockquote>
<p>RESTful 是目前最流行的网络应用程序设计风格和开发方式，大量使用在移动端 App 上和前后端分离的接口设计。这种形式更直观并且接口也有了一定的约束性。</p>
</blockquote>
<p>约束的请求方式和对应的操作:</p>
<ul>
<li>GET(SELECT) ： 从服务端取出资源，可以同时取出一项或者多项。</li>
<li>POST(CREATE) ：在服务器新建一个资源。</li>
<li>PUT(UPDATE) ：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>DELETE(DELETE) ：从服务器删除资源。</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库采用的是关系型数据库 MySQL，安装了官方带的 WorkBench 对数据库进行可视化管理。把 Egg.js 项目进行连接数据库的配置后即能使用</p>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>表 和 Cloum 如下：</p>
<ul>
<li><p>type</p>
<ul>
<li>id : 类型编号 int 类型</li>
<li>typeName: 文章类型名称 varchar 类型</li>
<li>orderNum: 类型排序编号 int 类型</li>
</ul>
</li>
<li><p>article</p>
<ul>
<li>id : 文章编号 int 类型</li>
<li>type_id : 文章类型编号 int 类型</li>
<li>title : 文章标题，varchar 类型</li>
<li>article_cointent : 文章主体内容，text 类型， TEXT(n)，这里的 n 是文本长度，可以设置一个较大值</li>
<li>introduce： 文章简介，text 类型</li>
<li>addTime : 文章发布时间，int(11)类型</li>
<li>view_count ：浏览次数， int 类型</li>
</ul>
</li>
<li><p>admin_user</p>
<ul>
<li>id</li>
<li>userName</li>
<li>password</li>
</ul>
</li>
</ul>
<h3 id="数据库语法"><a href="#数据库语法" class="headerlink" title="数据库语法"></a>数据库语法</h3><p>参考<br><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/sql_join_left.asp">W3School</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cathyqq/p/5197626.html">SQL 时间戳日期时间转换</a></p>
<blockquote>
<p>常用例子</p>
</blockquote>
<ul>
<li>增，直接对某个表进行 insert</li>
<li>删，直接根据 id，对某个表进行 delete</li>
<li>改，直接对某个表进行 udate</li>
<li>查，eg：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;SELECT article.id as id, article.title as title, article.article_content as article_content, FROM_UNIXTIME(article.addTime,&#x27;</span>%Y-%m-%d<span class="string">&#x27; ) as addTime, type.typeName as typeName, FROM article LEFT JOIN type ON article.type_id = type.Id ORDER BY article.addTime DESC&#x27;</span>; <span class="comment">// DESC是逆序的意思，ASC是正序`</span></span><br><span class="line">也可以加<span class="string">`&#x27;WHERE type_id= 2`</span> 这样的语法</span><br></pre></td></tr></table></figure>

<h1 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h1><p>直接用 React + Antd 写的，不用 Next.js</p>
<p>React 项目中的根目录的 index.js 应该是渲染一个路由组件（自己配的），由这个路由组件再去加载其他页面组件。例如路由组件可以如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;./Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AdminIndex</span> <span class="keyword">from</span> <span class="string">&#x27;./AdminIndex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/login/&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Login&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/index/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AdminIndex&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Main</span></span><br></pre></td></tr></table></figure>

<h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h2><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>样式上比较简单，是由 Antd 的 Card, Input, Icon, Button, Spin, message 组件写的</p>
<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>目前没有 注册 这个操作，用户名密码及 id 是采用直接在 workbench 插入新数据的方式注册<br>点击登录按钮的时候，向接口 post 用户名和密码，向数据库查询这个用户名和密码。如果登录成功就返回登录成功的信息和一个 token，组件就把 token 存到 localstorage 中（<code>localStorage.setItem(&#39;openId&#39;, res.data.openId)</code>），并跳转到首页（<code>props.history.push(&#39;/index&#39;)</code>）</p>
<p>附上接口代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断用户名密码是否正确</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">checkLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> userName = <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">request</span>.<span class="property">body</span>.<span class="property">userName</span>;</span><br><span class="line">    <span class="keyword">const</span> password = <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span>; <span class="comment">// 这里也可以进行加密和解密</span></span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">&quot; SELECT userName FROM admin_user WHERE userName = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">query</span>(sql);</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 登录成功,进行session缓存</span></span><br><span class="line">      <span class="keyword">const</span> openId = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(); <span class="comment">// 传给前端的token，用当前时间的时间戳做token</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">session</span>.<span class="property">openId</span> = &#123; openId &#125;; <span class="comment">// 并且把这个token放到session中</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">body</span> = &#123; <span class="attr">data</span>: <span class="string">&#x27;登录成功&#x27;</span>, openId &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">body</span> = &#123; <span class="attr">data</span>: <span class="string">&#x27;登录失败&#x27;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>登录后，我们生成了 session，通过后台是不是存在对应的 session，作一个中台的路由守卫。如果没有登录，是不允许访问后台对应的接口，也没办法作对应的操作。这样就实现了接口的安全<br>其实就是路由守卫，没有 token 的时候不让访问接口（等同于不让访问某些页面）。在这里我们是通过 egg.js 的中间件实现的（详情版见<a target="_blank" rel="noopener" href="https://jspang.com/detailed?id=52#toc2123">教程</a>)</p>
<ul>
<li>写一个中间件文件，并应用在中台路由中 （目前只有<code>getTypeInfo</code>这个接口有守卫</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">adminauth</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">session</span>.<span class="property">openId</span>)</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">session</span>.<span class="property">openId</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.<span class="property">body</span> = &#123; <span class="attr">data</span>: <span class="string">&#x27;没有登录&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中台路由：对某个接口进行路由守卫</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/admin/getTypeInfo&#x27;</span>, adminauth, controller.<span class="property">admin</span>.<span class="property">main</span>.<span class="property">getTypeInfo</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在正常情况下前后台是不能共享<code>session</code>的，需要要在 egg 端的<code>/config/config.default.js</code>里的<code>config.cor</code>配置项增加<code>credentials:true</code>；并且前台的请求中，需要带 <code>withCredentials: true</code>。</li>
</ul>
<h2 id="管理页"><a href="#管理页" class="headerlink" title="管理页"></a>管理页</h2><p>布局上用 Antd 的 <a target="_blank" rel="noopener" href="https://ant.design/components/layout-cn/">layout-侧边布局</a>。再做相应的路由配置就能分页</p>
<h2 id="管理页之添加文章"><a href="#管理页之添加文章" class="headerlink" title="管理页之添加文章"></a>管理页之添加文章</h2><p>直接在 编辑文章 分页进行编辑并保存<br>前端：把文章的数据都打包好之后 POST 给后端接口<br>后端：数据库对表进行插入数据的操作。id 方面是先找到最大 id，然后让新文章的 id 等于最大值+1</p>
<h2 id="管理页之修改文章"><a href="#管理页之修改文章" class="headerlink" title="管理页之修改文章"></a>管理页之修改文章</h2><p>在 文章列表 分页，点击某篇文章的 修改 按钮，就会进行路由跳转到 编辑文章 分页并附上文章 id 保存在路由中</p>
<p>所以在 编辑文章 分页还有这样一个逻辑：有一个<code>getArticleById</code>方法，会根据 id 向接口请求对应的文章的数据并显示在页面上，这个方法会在 useEffect 中执行让它在页面刚刷新的时候就执行（如果路由有带 id 的话）。此外，改页面的 发布文章 这个按钮也会判断是否有 id，无的话就是请求发布文章的接口，有的话就是请求更新文章的接口</p>
<h1 id="项目优化计划"><a href="#项目优化计划" class="headerlink" title="项目优化计划"></a>项目优化计划</h1><h2 id="前台-1"><a href="#前台-1" class="headerlink" title="前台"></a>前台</h2><ul>
<li><input disabled="" type="checkbox"> markdown 语法中图片的解析和存储<br>markdown 语法中图片是直接写成 <code>![](/img/二叉树的遍历/二叉树的遍历_1.png)</code> 这种形式，完全不做配置的话会出现下图这种 404 的情况<br><img src="/img/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/img.png"></li>
<li><input disabled="" type="checkbox"> 文章简介的实现</li>
<li><input disabled="" type="checkbox"> 访问人数的实现。目前的访问人数是随机生成的</li>
<li><input disabled="" type="checkbox"> UI 美化</li>
</ul>
<h2 id="后台-1"><a href="#后台-1" class="headerlink" title="后台"></a>后台</h2><ul>
<li><input disabled="" type="checkbox"> 登录账号和密码加密</li>
<li><input disabled="" type="checkbox"> 实现手机号注册？或者说这种管理中台一般是管理者才能使用，管理者账号直接写在数据库就行了，不必要有注册功能</li>
<li><input disabled="" type="checkbox"> 页面 UI 优化，使该系统美观一些</li>
<li><input disabled="" type="checkbox"> 添加文章能插入图片</li>
</ul>
<h1 id="上线及部署"><a href="#上线及部署" class="headerlink" title="上线及部署"></a>上线及部署</h1><p>见另一篇文章</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://jspang.com/">技术胖博客</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" data-id="clmniym7n003dbb871viadaya" data-title="博客项目小结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React路由 &amp; Redux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/04/React%E8%B7%AF%E7%94%B1%20&%20Redux/" class="article-date">
  <time class="dt-published" datetime="2020-01-04T06:50:21.000Z" itemprop="datePublished">2020-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/04/React%E8%B7%AF%E7%94%B1%20&%20Redux/">React Router &amp; Redux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h1><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><p>前端路由的本质是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面，核心是<strong>改变视图的同时不会向后端发出请求</strong>。目前前端使用的路由就只有两种实现方式:<br>Hash 模式和 History 模式</p>
<h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><p>Vue-router 默认是 hash 模式</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.test.com/#/">www.test.com/#/</a> 就是 Hash URL（有 &#x2F;#&#x2F; 就是），当 # 后面的哈希值发生变化时</li>
<li><strong>hash 的修改不会导致浏览器刷新，因为</strong> window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中</li>
<li>所以我们可以通过 hashchange 事件来监听到 URL 的变化，写一些逻辑进行组件替换实现更新页面的效果；同时浏览器监听到 hash 变化，会把更新历史记录，并且按后退键能回到上个位置</li>
<li>*无论哈希值如何变化，服务端接收到的 URL 请求永远是 <a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Hash 模式优点：</p>
<ul>
<li>简单，兼容性也更好（ie8）</li>
<li>不需要服务器端进行任何设置和开发</li>
<li>除了资源加载和ajax请求以外，不会发起其他请求</li>
</ul>
<p>缺点：</p>
<ul>
<li>不太美观</li>
<li>对于部分需要重定向的操作，后端无法获取hash部分内容，导致后台无法取得url中的数据，典型的例子就是微信公众号的oauth验证</li>
<li>服务器端无法准确跟踪前端路由信息</li>
<li>对于需要锚点功能的需求会与目前路由机制冲突</li>
</ul>
<h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。<br>通过 History 模式改变 URL 同样<strong>不会引起页面的刷新，只会更新浏览器的历史记录</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增历史记录</span></span><br><span class="line">history.<span class="title function_">pushState</span>(stateObject, title, <span class="variable constant_">URL</span>) <span class="comment">// 前两个参数可以写成null，url必须是同源的</span></span><br><span class="line"><span class="comment">// 替换当前历史记录</span></span><br><span class="line">history.<span class="title function_">replaceState</span>(stateObject, title, <span class="variable constant_">URL</span>)</span><br></pre></td></tr></table></figure>

<p>当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">state</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h3><p>history 的优点：</p>
<ul>
<li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li>
<li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li>
<li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li>
<li>pushState() 可额外设置 title 属性供后续使用</li>
</ul>
<p>history 的缺点：一是兼容性，二是需要后端的支持，当真正想输入 url 发起 http 请求的时候，eg. 用户手动输入 URL 后回车</p>
<ul>
<li>hash 模式下，仅 # 之前的内容会被包含在请求中，所以对后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误</li>
<li>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a target="_blank" rel="noopener" href="http://www.abc.com/book/id%E3%80%82%E5%A6%82%E6%9E%9C%E5%90%8E%E7%AB%AF%E7%BC%BA%E5%B0%91%E5%AF%B9">http://www.abc.com/book/id。如果后端缺少对</a> &#x2F;book&#x2F;id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>感觉 React 的路由比 Vue 的路由更复杂些<br>exect 的区别<br><code>&lt;Route&gt;</code>,<code>&lt;Router&gt;</code>,<code>&lt;Route&gt;</code>, <a target="_blank" rel="noopener" href="https://juejin.im/post/5d53e885f265da03bc1270ee">https://juejin.im/post/5d53e885f265da03bc1270ee</a> 。应该确实是组件被<Route>包裹和 withRouter 是等价的<br>props.history.push()</p>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul>
<li>Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个 Store。</li>
<li>State：Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫做 State。</li>
<li>Action：State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</li>
<li>Action Creator：View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 Action Creator。</li>
<li>Reducer：Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</li>
<li>dispatch：是 View 发出 Action 的唯一方法。</li>
</ul>
<p>然后我们过下整个工作流程：</p>
<ul>
<li>首先，用户（通过 View）发出 Action，发出方式就用到了 dispatch 方法。</li>
<li>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State</li>
<li>State 一旦有变化，Store 就会调用监听函数，来更新 View。</li>
</ul>
<p>到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。<br><img src="/img/React%E5%8E%9F%E7%90%86/Redux.png"></p>
<h2 id="react-redux-工作流程"><a href="#react-redux-工作流程" class="headerlink" title="react-redux 工作流程"></a>react-redux 工作流程</h2><ul>
<li>Provider: Provider 的作用是从最外部封装了整个应用，并向 connect 模块传递 store</li>
<li>connect: 负责连接 React 和 Redux<ul>
<li>获取 state: connect 通过 context 获取 Provider 中的 store，通过 store.getState()获取整个 store tree 上所有 state</li>
<li>包装原组件: 将 state 和 action 通过 props 的方式传入到原组件内部 wrapWithConnect 返回一个 ReactComponent 对象 Connect，Connect 重新 render 外部传入的原组件 WrappedComponent，并把 connect 中传入的 mapStateToProps, mapDispatchToProps 与组件上原有的 props 合并后，通过属性的方式传给 WrappedComponent</li>
<li>监听 store tree 变化: connect 缓存了 store tree 中 state 的状态,通过当前 state 状态和变更前 state 状态进行比较,从而确定是否调用 this.setState()方法触发 Connect 及其子组件的重新渲染</li>
</ul>
</li>
</ul>
<p><img src="/img/React%E5%8E%9F%E7%90%86/React-redux.png"></p>
<h2 id="Redux-VS-Mobx"><a href="#Redux-VS-Mobx" class="headerlink" title="Redux VS Mobx"></a>Redux VS Mobx</h2><p>两者对比:</p>
<ul>
<li>redux 将数据保存在单一的 store 中，mobx 将数据保存在分散的多个 store 中</li>
<li>redux 使用 plain object 保存数据，需要手动处理变化后的操作；mobx 适用 observable 保存数据，数据变化后自动处理响应的操作</li>
<li>redux 使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx 中的状态是可变的，可以直接对其进行修改</li>
<li>mobx 相对来说比较简单，在其中有很多的抽象，mobx 更多的使用面向对象的编程思维；redux 会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li>
<li>mobx 中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而 redux 提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li>
</ul>
<p>场景辨析:</p>
<ul>
<li>mobx 更适合数据不复杂的应用: mobx 难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.mobx 适合短平快的项目: mobx 上手简单,样板代码少,可以很大程度上提高开发效率.</li>
<li>redux 适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于 redux 不可变的特性，天然支持这些操作.</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d5f44dae51d4561df7805b4#heading-12">高频 React 面试题及详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/04/React%E8%B7%AF%E7%94%B1%20&%20Redux/" data-id="clmniym77001xbb871zzffpj6" data-title="React Router &amp; Redux" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>