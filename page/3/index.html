<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jacleklm">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:locale">
<meta property="article:author" content="Jacleklm">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-JS函数柯里化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/30/JS%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2019-11-30T09:25:21.000Z" itemprop="datePublished">2019-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/30/JS%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">JS函数柯里化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>柯里化是指将一个函数分解为一系列函数的过程，每个函数都只接收一个参数<br>函数柯里化，英语：Currying，高阶函数的一个特殊用法。是把接受多个参数的函数变换成接受一个<strong>单一参数</strong>（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p>
<p>一个简单的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curryingadd</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">curryadd</span>(<span class="number">1</span>)(<span class="number">5</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h1 id="柯里化的用途"><a href="#柯里化的用途" class="headerlink" title="柯里化的用途"></a>柯里化的用途</h1><h2 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">reg, txt</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> reg.<span class="title function_">test</span>(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>) <span class="comment">//false</span></span><br><span class="line"><span class="title function_">check</span>(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curryingCheck</span>(<span class="params">reg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">txt</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(txt)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = <span class="title function_">curryingCheck</span>(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = <span class="title function_">curryingCheck</span>(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">hasNumber</span>(<span class="string">&#x27;test1&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">hasNumber</span>(<span class="string">&#x27;testtest&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">hasLetter</span>(<span class="string">&#x27;21212&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果有很多地方都要校验是否有数字，如果用 check 函数，得反复传递第一个参数；curryingCheck 能将第一个参数 reg 进行复用，这样别的地方就能够直接调用 hasNumber，hasLetter 等函数，让参数能够复用，调用起来也更方便</p>
<h2 id="提前确认"><a href="#提前确认" class="headerlink" title="提前确认"></a>提前确认</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> on = <span class="keyword">function</span>(<span class="params">element, event, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">      element.<span class="title function_">addEventListener</span>(event, handler, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">      element.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + event, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> on = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">element, event, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">        element.<span class="title function_">addEventListener</span>(event, handler, <span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">element, event, handler</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">        element.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + event, handler)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了</span></span><br><span class="line"><span class="keyword">var</span> on = <span class="keyword">function</span>(<span class="params">isSupport, element, event, handler</span>) &#123;</span><br><span class="line">  isSupport = isSupport || <span class="variable language_">document</span>.<span class="property">addEventListener</span></span><br><span class="line">  <span class="keyword">if</span> (isSupport) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.<span class="title function_">addEventListener</span>(event, handler, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + event, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在做项目的过程中，封装一些 dom 操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断</p>
<h2 id="延迟运行"><a href="#延迟运行" class="headerlink" title="延迟运行"></a>延迟运行</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 实现的机制就是 Currying，虽然上面这个 bind 有点简单没有考虑所有情况</p>
<h1 id="柯里化的封装"><a href="#柯里化的封装" class="headerlink" title="柯里化的封装"></a>柯里化的封装</h1><p>其实和之前写的 bind 的实现很像</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初步封装</span></span><br><span class="line"><span class="keyword">var</span> currying = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// args 获取第一个方法内的全部参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 把合并后的参数通过apply作为fn的参数并执行</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)的情况无法支持，所以需要递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持多参数传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">progressCurrying</span>(<span class="params">fn, ...args</span>) &#123; <span class="comment">// fn 是原本的接受很多个参数的复杂函数</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> len = fn.<span class="property">length</span> <span class="comment">// fn.length === fn 原本参数个数</span></span><br><span class="line">  <span class="keyword">var</span> args = args || []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">    args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span></span><br><span class="line">    <span class="keyword">if</span> (_args.<span class="property">length</span> &lt; len) &#123;</span><br><span class="line">      <span class="keyword">return</span> progressCurrying.<span class="title function_">call</span>(_this, fn, _args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数收集完毕，则执行fn</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一道经典面试题"><a href="#一道经典面试题" class="headerlink" title="一道经典面试题"></a>一道经典面试题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">  <span class="keyword">let</span> _args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">  <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">  <span class="keyword">let</span> _result = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 这里不能用箭头函数</span></span><br><span class="line">    _args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> _result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">  _result.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 这里不能用箭头函数</span></span><br><span class="line">    <span class="keyword">return</span> _args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<h2 id="toString-或-valueOf-的改写"><a href="#toString-或-valueOf-的改写" class="headerlink" title="toString 或 valueOf 的改写"></a>toString 或 valueOf 的改写</h2><p>上面那道题的的 toString 的改写也是非常有意思的一个知识点</p>
<p>当变量对象（函数也是对象）遇到一些情况的时候，会偷偷地调用 toString 和 valueOf 方法（隐式调用），那我们就可以改写这两个方法做一些事</p>
<p><strong>这些情况会触发隐式调用：</strong></p>
<ul>
<li>加减乘除</li>
<li>比较运算符&gt;</li>
<li>&#x3D;&#x3D;</li>
<li>String()</li>
<li>Number()</li>
</ul>
<p>两个都重写的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了valueOf()&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i</span> + <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了toString()&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">valueOf</span>() + <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+obj) <span class="comment">// 执行了valueOf()  30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj &gt; <span class="number">40</span>) <span class="comment">// 执行了valueOf()  false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj == <span class="number">30</span>) <span class="comment">// 执行了valueOf()  true</span></span><br></pre></td></tr></table></figure>

<p>只重写了 toString</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+aa) <span class="comment">// 10 toString</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span> + aa) <span class="comment">// 10 toString</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(aa)) <span class="comment">// 10 toString</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(aa)) <span class="comment">// 10 toString</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aa == <span class="string">&#x27;10&#x27;</span>) <span class="comment">// true toString</span></span><br></pre></td></tr></table></figure>

<p>只重写了 valueOf</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+aa) <span class="comment">// 10 valueOf</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span> + aa) <span class="comment">// 10 valueOf</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(aa)) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(aa)) <span class="comment">// 10 valueOf</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aa == <span class="string">&#x27;10&#x27;</span>) <span class="comment">// true valueOf</span></span><br></pre></td></tr></table></figure>

<p>结论：如果只重写了 toString，对象转换时会无视 valueOf 的存在来进行转换。但是，如果只重写了 valueOf 方法，在要转换为字符串的时候会优先考虑 valueOf 方法。在不能调用 toString 的情况下，只能让 valueOf 上阵了<br><strong>当两者都重写的时候，优先 valueOf</strong></p>
<p>结论二：所以上面那道面试题，是触发了隐式调用，偷偷地执行了重写的toString方法。虽然还是没懂是怎么触发隐式调用的好像都不是我所知的那几种情况0.0</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2013/02/js-currying/">张鑫旭-JS 中的柯里</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2975c25e4d71">详解 JS 函数柯里化</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/barrior/p/4598354.html">JavaScript 中 valueOf、toString 的隐式调用</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aNd1coder/archive/2013/03/09/2951959.html">JavaScript 中 valueOf 函数与 toString 方法深入理解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/30/JS%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/" data-id="clmniym6u000tbb877dsf9kug" data-title="JS函数柯里化" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-内存泄露和垃圾回收" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/26/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date">
  <time class="dt-published" datetime="2019-11-26T08:50:21.000Z" itemprop="datePublished">2019-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/26/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">内存泄露和垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>程序的运行需要内存。只要程序提出要求，操作系统就会给内存。进程应及时释放不再用到的内存。<strong>不再用到的内存，没有及时释放</strong>，就叫做<strong>内存泄漏</strong>（memory leak）<br>大多数语言提供自动内存管理，减轻程序员的负担，这被称为<strong>垃圾回收机制</strong>（garbage collector）</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><strong>思想：跟踪记录所有值被引用的次数</strong><br>（阮一峰说引用计数是最常使用的，红宝书说到 2008 年为止标记清除是最常用的）<br>JS 引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种<strong>值</strong>，比如数组）的引用次数。<strong>如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放</strong><br>如果一个值不再需要了，引用数却不为 0，垃圾回收机制无法释放这块内存，从而导致内存泄漏</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">arr = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为 1。尽管后面的代码没有用到 arr，它还是会持续占用内存<br>可以<strong>手动解除引用</strong>：让变量 &#x3D; null。则数值这个值就能被垃圾回收机制释放了</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>循环引用的情况</strong>，eg. 对象 A 包含一个指向对象 B 的指针，而对象 B 中也包含一个指向 A 的指针。采用引用计数策略时，函数执行后，两个对象还将继续存在，因为<strong>它们的引用次数永远不会为 0</strong>。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>思路：给当前不使用的值加上标记，然后再回收其内存<br>只有在环境中的变量及被环境中的变量引用的变量（闭包）标记</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">//被标记&quot;进入环境&quot;</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">&quot;hello&quot;</span>; <span class="comment">//被标记&quot;进入环境&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">//执行完毕后之后，a和b又被标记&quot;离开环境&quot;，被回收</span></span><br></pre></td></tr></table></figure>

<h2 id="常见-JavaScript-内存泄露"><a href="#常见-JavaScript-内存泄露" class="headerlink" title="常见 JavaScript 内存泄露"></a>常见 JavaScript 内存泄露</h2><h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><p>eg. 如下代码，这种生命方式等于 <code>this.bar=.....</code>，函数独立调用的话 this 为 window，所以 bar 是全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生</p>
</blockquote>
<p>但是其实我们自己设全局变量也是有风险的，因为全局变量被认为的不可回收的（标记清除机制无法清除，因为全局环境到最后才会销毁）。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null</p>
<h3 id="被遗忘的-setInterval-或回调函数"><a href="#被遗忘的-setInterval-或回调函数" class="headerlink" title="被遗忘的 setInterval 或回调函数"></a>被遗忘的 setInterval 或回调函数</h3><p>用完 setInterval 记得 clearInterval</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>不解释</p>
<h2 id="内存泄漏的识别方法"><a href="#内存泄漏的识别方法" class="headerlink" title="内存泄漏的识别方法"></a>内存泄漏的识别方法</h2><h3 id="Chrome-浏览器"><a href="#Chrome-浏览器" class="headerlink" title="Chrome 浏览器"></a>Chrome 浏览器</h3><p>控制台-profiles</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>process.memoryUsage()，返回一个对象，包含了 Node 进程的内存占用信息</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>找到问题后手动释放内存</li>
<li>使用两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制</li>
</ol>
<p>参考资料</p>
<p>《Javascript 高级程序设计》</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">阮一峰-JavaScript 内存泄漏教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/26/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" data-id="clmniym7l0036bb87he3jce2t" data-title="内存泄露和垃圾回收" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器兼容性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2019-11-25T13:30:21.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/">浏览器兼容性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="常见兼容性问题"><a href="#常见兼容性问题" class="headerlink" title="常见兼容性问题"></a>常见兼容性问题</h1><ol>
<li>png24 位的图片在 iE6 浏览器上出现背景，解决方案是做成 PNG8</li>
<li>浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一，但是全局效率很低，一般是如下这样解决：</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">li</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">form</span>,<span class="selector-tag">input</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">p</span>&#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>IE 下，event 对象有 x,y 属性，但是没有 pageX，pageY 属性</li>
<li>Firefox 下，event 对象有 pageX,pageY 属性，但是没有 x,y 属性</li>
</ol>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6afd596440bb">前端浏览器兼容性问题总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/" data-id="clmniym89004xbb87a5dxelvo" data-title="浏览器兼容性" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web Worker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/22/Web%20Worker/" class="article-date">
  <time class="dt-published" datetime="2019-11-22T15:02:21.000Z" itemprop="datePublished">2019-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/22/Web%20Worker/">Web Worker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>解决JS单线程，遇到计算密集型或高延迟的任务时发生阻塞的问题<br>Web Worker 的作用，就是允许主线程创建 Worker 线程，承担一些费时的任务<br>Worker线程可以有多个，但是使用完最好计时关闭</p>
<h1 id="一个简单的例子帮助理解"><a href="#一个简单的例子帮助理解" class="headerlink" title="一个简单的例子帮助理解"></a>一个简单的例子帮助理解</h1><p><strong>改进前：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;num&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//在子线程 模拟一个耗时操作</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123; &#125;</span></span><br><span class="line"><span class="language-javascript">        num.<span class="property">innerHTML</span> = i;</span></span><br><span class="line"><span class="language-javascript">        box.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&quot;耗时操作导致页面阻塞，打开慢&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主线程中存在耗时任务，发生阻塞<br><strong>改进后：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;stop&quot;</span>&gt;</span>停止子线程<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;num&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建子线程。把耗时操作放在子线程的文件中，Worker不能读取本地文件，脚本【必须来自网络，并且同源】</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> webWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    webWorker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      num.<span class="property">innerHTML</span> = e.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&quot;有子线程后主线程快得多了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    stop.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 【终止Web Worker】</span></span></span><br><span class="line"><span class="language-javascript">      webworker.<span class="title function_">terminate</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子线程</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>  (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//模拟一个耗时操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123; &#125;</span><br><span class="line">  <span class="comment">//耗时操作完毕后，调用postMessage方法回到主线程，并且把数据传回去</span></span><br><span class="line">  <span class="title function_">postMessage</span>(i);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>在主线程创建web worker子线程，让子线程承担费时任务，主线程不会阻塞</p>
<h1 id="Web-Worker的限制"><a href="#Web-Worker的限制" class="headerlink" title="Web Worker的限制"></a>Web Worker的限制</h1><ul>
<li>new 传递的脚本文件必须来源网络并同源</li>
<li>无法访问DOM节点；</li>
<li>无法调用alert()或者confirm之类的函数；</li>
<li>无法访问window、document之类的浏览器全局变量；但是可以用navigator对象和location对象</li>
</ul>
<p>不过Web Worker中的Javascript依然可以使用setTimeout(),setInterval()之类的函数，也可以<strong>使用XMLHttpRequest对象来做Ajax通信</strong></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;work.js&#x27;</span>) <span class="comment">// 用new创建子线程，参数是一个同源网络的脚本文件</span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello World&#x27;</span>); <span class="comment">// 主线程向 Worker 发消息</span></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">ev</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(ev.<span class="property">data</span>) &#125; <span class="comment">// 主线程通过监听message事件，接收子线程发回来的消息(事件的data属性)</span></span><br><span class="line">worker.<span class="title function_">terminate</span>() <span class="comment">// 关闭 Worker</span></span><br></pre></td></tr></table></figure>
<h2 id="worker线程"><a href="#worker线程" class="headerlink" title="worker线程"></a>worker线程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">evt</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(ev.<span class="property">data</span>) &#125; <span class="comment">// 同理通过监听message事件，接收主线程发回来的消息(事件的data属性)</span></span><br><span class="line">self.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello World&#x27;</span>) <span class="comment">/// 向主线程发送消息</span></span><br><span class="line">self.<span class="title function_">close</span>() <span class="comment">// 关闭 Worker</span></span><br></pre></td></tr></table></figure>
<h2 id="使用XMLHttpRequest与服务端通信"><a href="#使用XMLHttpRequest与服务端通信" class="headerlink" title="使用XMLHttpRequest与服务端通信"></a>使用XMLHttpRequest与服务端通信</h2><p>在子线程文件中写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span>(<span class="params">evt</span>)&#123;  </span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();  </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;某个服务器的url&quot;</span>);  </span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line"><span class="title function_">postMessage</span>(xhr.<span class="property">responseText</span>);  </span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();  </span><br><span class="line">&#125;,<span class="literal">false</span>); </span><br></pre></td></tr></table></figure>
<p>上面的代码向服务器发出GET请求，并注册了获取数据后的onload事件。结果是获得数据后把数据传给主线程</p>
<h2 id="通过Error事件捕捉错误信息"><a href="#通过Error事件捕捉错误信息" class="headerlink" title="通过Error事件捕捉错误信息"></a>通过Error事件捕捉错误信息</h2><p>Web Worker恰恰提供了error事件，供开发者捕捉错误信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;scripts/lengthytask.js&quot;</span>);  </span><br><span class="line">worker.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span>(<span class="params">evt</span>)&#123;  </span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Line #&quot;</span> + evt.<span class="property">lineno</span> + <span class="string">&quot; - &quot;</span> + evt.<span class="property">message</span> + <span class="string">&quot; in &quot;</span> + evt.<span class="property">filename</span>);  </span><br><span class="line">&#125;, <span class="literal">false</span>);  </span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="number">10000</span>);  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>
<p>如上可见， Worker对象可以绑定error事件；而且evt对象中包含错误所在的代码文件（evt.filename）、错误所在的代码行数（evt.lineno）、以及错误信息</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html">阮一峰-Web Worker 使用教程</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunshq/p/4187283.html">关于Web Worker你必须知道的7件事</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/22/Web%20Worker/" data-id="clmniym7b0029bb872pg53t9h" data-title="Web Worker" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-实现鼠标拖拽DOM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/17/%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BDDOM/" class="article-date">
  <time class="dt-published" datetime="2019-11-17T08:50:21.000Z" itemprop="datePublished">2019-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/17/%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BDDOM/">实现鼠标拖拽DOM + 页面视图总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h1><h2 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h2><ul>
<li>click</li>
<li>dbclick：双击</li>
<li>mouseenter：当鼠标指针<strong>首次</strong>移动到元素上时触发。不冒泡</li>
<li>mouseleave：当鼠标指针移出元素时触发。不冒泡</li>
<li><strong>mousedown</strong>：当元素上按下鼠标按钮时候触发</li>
<li><strong>mouseup</strong>：当元素上释放鼠标按钮时触发</li>
<li><strong>mousemove</strong>：当鼠标指针在元素内部移动时<strong>重复地</strong>触发</li>
<li><strong>mouseover</strong>：当鼠标指针移动到元素上时触发</li>
<li><strong>mouseout</strong>：当鼠标指针移出元素时触发</li>
</ul>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息。会作为参数传递给函数，IE8以及之前的版本event对象是作为window对象的属性存在的。故有了以下常见的写法：<code>function (e) &#123; e = e || window.event; ... &#125;</code> 。事件对象的属性如下：<br><img src="/img/%E9%BC%A0%E6%A0%87/W3C.png"><br><img src="/img/%E9%BC%A0%E6%A0%87/IE.png"><br>应用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stopPro</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> e = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  <span class="comment">// 得到事件目标DOM对象</span></span><br><span class="line">  <span class="keyword">let</span> dom = e.<span class="property">target</span> || e.<span class="property">srcElement</span>;</span><br><span class="line">  <span class="comment">// 阻止冒泡</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">event</span> ? e.<span class="property">cancelBubble</span> = <span class="literal">true</span> : e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  <span class="comment">// 取消默认事件</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">event</span> ? e.<span class="property">returnValue</span> = <span class="literal">false</span> : e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="comment">// 阻止默认行为(但会继续冒泡)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><h3 id="事件对象-1"><a href="#事件对象-1" class="headerlink" title="事件对象"></a>事件对象</h3><ul>
<li>event对象.screenX &#x2F; screenY ：相对电脑屏幕的坐标，距离左边框和上边框的距离</li>
<li>event对象.clientX &#x2F; clientY ：相对浏览器可视区的坐标，同理</li>
</ul>
<h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><h4 id="DOM节点-offsetLeft-offsetTop"><a href="#DOM节点-offsetLeft-offsetTop" class="headerlink" title="DOM节点.offsetLeft &#x2F; offsetTop"></a>DOM节点.offsetLeft &#x2F; offsetTop</h4><p>可以获得元素 距离上方或外层元素 的位置，<strong>本质和 style.top 是一样的</strong>。二者区别：offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位（px）；offsetTop 只读，而 style.top 可读写。同理offsetWidth 与 style.width、offsetHeight 与 style.height</p>
<h4 id="DOM节点-clientHeight-clientWidth"><a href="#DOM节点-clientHeight-clientWidth" class="headerlink" title="DOM节点.clientHeight &#x2F; clientWidth"></a>DOM节点.clientHeight &#x2F; clientWidth</h4><p>浏览器中可视区高度。width + padding（不含border）</p>
<h4 id="DOM节点-scrollHeight-scrollWidth"><a href="#DOM节点-scrollHeight-scrollWidth" class="headerlink" title="DOM节点.scrollHeight &#x2F; scrollWidth"></a>DOM节点.scrollHeight &#x2F; scrollWidth</h4><p>元素内容真实的宽度，内容不超出盒子高度时为盒子的clientWidth</p>
<h3 id="Window视图"><a href="#Window视图" class="headerlink" title="Window视图"></a>Window视图</h3><p>window.innerWidth &#x2F; innerHeight：浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏） （低版本IE浏览器&lt; IE9不支持）</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>拖拽无非是鼠标按下点击元素；鼠标移动，元素移动；鼠标抬起，元素停止不动<br>所以这里我们需要绑定三个事件：mousedown、mousemove、mouseup</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//【drag元素必须是是绝对定位】</span></span><br><span class="line">  <span class="keyword">var</span> drag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">  drag.<span class="property">onmousedown</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// IE8以及之前的版本event对象是作为window对象的属性存在的。故有了以下常见的写法：</span></span><br><span class="line">    e = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">    <span class="comment">//鼠标点与拖拽元素边框的距离。由于DOM.offsetLeft 和DOM.style.left本质是一样的，所以可以这么写</span></span><br><span class="line">    <span class="keyword">let</span> diffX = e.<span class="property">clientX</span> - drag.<span class="property">offsetLeft</span>;</span><br><span class="line">    <span class="keyword">let</span> diffY = e.<span class="property">clientY</span> - drag.<span class="property">offsetTop</span>;</span><br><span class="line">    drag.<span class="property">onmousemove</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      e = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">      <span class="keyword">let</span> left = e.<span class="property">clientX</span> - diffX;</span><br><span class="line">      <span class="keyword">let</span> top = e.<span class="property">clientY</span> - diffY;</span><br><span class="line">      <span class="comment">//避免拖出可视区外</span></span><br><span class="line">      <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123; left = <span class="number">0</span>; &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; <span class="variable language_">window</span>.<span class="property">innerWidth</span> - drag.<span class="property">offsetWidth</span>) &#123;</span><br><span class="line">        <span class="comment">//超出了就放在innerWidth的位置，注意这段代码不要写错</span></span><br><span class="line">        left = <span class="variable language_">window</span>.<span class="property">innerWidth</span> - drag.<span class="property">offsetWidth</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (top &lt; <span class="number">0</span>) top = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (top &gt; <span class="variable language_">window</span>.<span class="property">innerHeight</span> - drag.<span class="property">offsetHeight</span>) &#123;</span><br><span class="line">        top = <span class="variable language_">window</span>, innerHeight - drag.<span class="property">offsetHeight</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      drag.<span class="property">style</span>.<span class="property">left</span> = left + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">      drag.<span class="property">style</span>.<span class="property">top</span> = top + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    drag.<span class="property">onmouseup</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      drag.<span class="property">onmousemove</span> = <span class="literal">null</span>;</span><br><span class="line">      drag.<span class="property">onmousedown</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/17/%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BDDOM/" data-id="clmniym7s003vbb874nq8bbel" data-title="实现鼠标拖拽DOM + 页面视图总结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MeiTuan-app项目总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/16/MeiTuan-app%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2019-11-16T15:02:21.000Z" itemprop="datePublished">2019-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/16/MeiTuan-app%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">MeiTuan-app项目总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>缘起：前段时间面试SXF二面的时候发现自己项目经验有点少，一些组件实现思路也不清晰，决定恶补一波。该项目来源是慕课网上的《Vue全家桶+SSR+Koa2全栈开发美团网》，于近期学习完毕。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Koa2"><a href="#Koa2" class="headerlink" title="Koa2"></a><a target="_blank" rel="noopener" href="https://koa.bootcss.com/#introduction">Koa2</a></h2><p>Koa2是基于Nodejs的web框架<br>对Node.js的http进行了封装（封装了一个服务器），用 Promise + async 实现异步 （Koa1是用Generator，Express是用Promise）<br><strong>ctx</strong>是一个全局的信息对象，包含所有信息</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>全局安装koa、 koa-generator。用koa2 -e ${项目名} 来初始化项目<br>主配置文件是 &#x2F;app.js ， 接口都是写在 &#x2F;routers 文件夹中</p>
<h3 id="中间件的原理"><a href="#中间件的原理" class="headerlink" title="中间件的原理"></a>中间件的原理</h3><p>每个Request和Response都要经过中间件，并且进和出中间件的执行顺序的是相反的，所以中间件就类似于洋葱的层<br><img src="/img/%E7%BE%8E%E5%9B%A2%E7%BD%91/%E6%B4%8B%E8%91%B1%E5%9B%BE.png"></p>
<h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>mongodb是非关系型数据库，mySQL是关系型数据库</li>
<li>在mongodb中：database数据库，collection 数据表，一行的数据叫document，列叫filed</li>
<li><a target="_blank" rel="noopener" href="http://www.mongoosejs.net/docs/guide.html">mongoose</a>是用来操作mongodb的，能使操作更简单；可视化的数据管理工具RoBo 3T</li>
</ul>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>能在Koa2的项目中连接mongodb，然后写一些能操作数据库的接口</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>是一个<strong>快速读写</strong>的数据库，一般用来存session的数据库</p>
<h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a><a target="_blank" rel="noopener" href="https://zh.nuxtjs.org/">Nuxt.js</a></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Nuxt.js是一个基于Vue的通用应用框架，基于Vue，包含Vue-router，支持Vuex、Vue SSR和vue-meta。SSR能解决Vue首屏时间长和SEO差的缺点；用Nuxt.js做Vue SSR很方便</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/img/%E7%BE%8E%E5%9B%A2%E7%BD%91/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"><br>重要的是写在Vuex的action中的<strong>nuxtServerInit</strong>和写在组件中的<strong>asyncData()&amp;fetch()</strong></p>
<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>&#x2F;layout 是放布局，或者说是页面的模板。把页面共同的组件放到这里，eg. footer，登录框<br>&#x2F;page 是页面的入口文件<br>&#x2F;components 只放组件<br>&#x2F;server 放服务器<br>&#x2F;store 放Vuex</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><code>&lt;nuxt-link&gt;</code>标签相当于<code>&lt;router-link&gt;</code>，用法是完全一样的；<code>&lt;nuxt /&gt;</code>相当于是<code>&lt;router-view&gt;</code>；page文件下的入口文件，其文件名就是页面路由地址</p>
<h3 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData"></a><a target="_blank" rel="noopener" href="https://zh.nuxtjs.org/guide/async-data">asyncData</a></h3><h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p>如果我们的组件需要获取异步数据，可以把mounted写成async mounted，然后在其中写axios.get()去获取数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">//  status是响应的状态码, data属性是响应的数据</span></span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      status,</span><br><span class="line">      <span class="attr">data</span>: &#123; list &#125;</span><br><span class="line">    &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;/city/list&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">200</span>) &#123;</span><br><span class="line">      self.<span class="property">list</span> = list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，我们在页面的源码中是找不到异步数据的，是浏览器拿到服务器的响应的页面，加载，在加载的mounted阶段去获取。</p>
<h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a><a target="_blank" rel="noopener" href="https://ssr.vuejs.org/zh/">SSR</a></h4><p>SSR是在服务端就完成页面所有操作（包括请求异步数据），然后渲染好，服务器再响应。<br>所以在组件中我们可以用asyncData的写法（一般用来组件获取数据<br>）。fetch() 一般用来拿到数据修改Vuex状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">asyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      status,</span><br><span class="line">      <span class="attr">data</span>: &#123; list &#125;</span><br><span class="line">    &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:3000/city/list&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 这种return的写法就相当于把asyncData得到的list复制给data中的list</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        list</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 由于asyncData方法是在组件<strong>初始化</strong>前被调用的，所以在方法内是没有办法通过<strong>this</strong>来引用组件的实例对象</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>由于Nuxt有更新，现在的写法见<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4861099edbab">链接</a></p>
<h4 id="nuxtServerInit"><a href="#nuxtServerInit" class="headerlink" title="nuxtServerInit"></a>nuxtServerInit</h4><p>一般是写在 &#x2F;store&#x2F;index.js 入口文件的actions中，用来获取异步数据并把数据添加到state中</p>
<h1 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul>
<li>页面的header+body+footer的布局可以用Element UI提供的container布局。在Nuxt项目中，header和footer如果多个页面是一样的，可以写在 &#x2F;layout&#x2F;default.vue 中或者新建布局文件</li>
<li>组件的布局用Element UI的layout布局-分栏间隔</li>
</ul>
<h2 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><h4 id="登录状态组件-user-vue"><a href="#登录状态组件-user-vue" class="headerlink" title="登录状态组件 user.vue"></a>登录状态组件 user.vue</h4><ul>
<li>需求：显示用户登录状态&#x2F;用户名</li>
<li>思路：在接收请求时，服务器就通过请求带的cookie在Redis中找是否有这个用户，有就返回 user: 用户名 为响应；否则就是 user: ‘’</li>
<li>实现：首先组件的DOM分为两部分，一部分v-if&#x3D;’username’，里面写this.username，这样有username这个数据的时候显示用户信息的状态；另一部分v-else，里面写立刻登录，就是没有用户信息的时候的状态。在组件的async mounted 去axios.get()一个写好的接口，这个接口能按上述逻辑去获取user（如果没有则 user: ‘’）</li>
</ul>
<p>这里的async mounted写法缺点是页面刷新的时候页面的用户名那里会闪一下才书来数据，如果认为不影响的话可以这么写。也可以用SSR，写成async Data()。写成async fetch的话，把state.user写成得到的user；然后DOM 里写$store.state.user</p>
<p><strong>问：如果在Vue中，没有后台的话怎么实现</strong><br>先在Vuex中，设置state.user&#x3D;’’。在组件中导入mapState后就能直接用state.user。组件一部分v-if&#x3D;这个值，里面的用户也是这个值；组件另一部分写v-else，里面写立即登录</p>
<h4 id="城市服务组件-geo-vue"><a href="#城市服务组件-geo-vue" class="headerlink" title="城市服务组件 geo.vue"></a>城市服务组件 geo.vue</h4><ul>
<li>需求：第一次访问网站的时候显示定位是用户目前在的城市。若用户手动修改则x显示新城市</li>
<li>思路：在浏览器向服务器请求首页资源的时候，服务器就解读IP地址找到city，加进首页中，把整个页面响应回去。用Vuex + SSR 就能实现</li>
<li>实现：async fetch中去axios.get()一个接口，能接口能根据IP地址定位city。然后写进store.state中。DOM里写$store.state.city</li>
</ul>
<h4 id="nav-vue组件"><a href="#nav-vue组件" class="headerlink" title="nav.vue组件"></a>nav.vue组件</h4><ul>
<li>需求：用简单的DOM实现下图<br><img src="/img/%E7%BE%8E%E5%9B%A2%E7%BD%91/nav1.png"><br><img src="/img/%E7%BE%8E%E5%9B%A2%E7%BD%91/nav2.png"></li>
<li><strong>DOM的实现</strong>：用了一种障眼法。分为两部分：美团规则，网站导航这些是一部分；里面的展开内容自己是一部分。第一部分用 ul&gt;li 实现；第二部分用一个或多个 dl&gt;dt 实现</li>
</ul>
<h4 id="搜索框-search-vue组件"><a href="#搜索框-search-vue组件" class="headerlink" title="搜索框 search.vue组件"></a>搜索框 search.vue组件</h4><ul>
<li>需求：不focus是普通状态；focus时出现下拉框，显示 热门搜索；输入内容的时候下拉框显示 搜索推荐</li>
<li>实现：<ul>
<li>DOM：input框，热门搜索，搜索推荐是兄弟节点。后两者是通过v-if显示</li>
<li>事件:<ul>
<li>@focus：<code>this.isFocus = true</code></li>
<li>@blur（失去焦点）：<code> let self = this; setTimeout(function() &#123;self.isFocus = false;&#125;, 200);</code>  setTimeout是防止点击推荐内容的同时推荐内容会消失。</li>
<li>@input：访问一个接口，这个接口能根据input的输入内容去返回一些数据。这些数据能v-for生成 搜索推荐</li>
</ul>
</li>
<li>input的v-model&#x3D;’search’。v-if后面是跟计算属性，计算属性是返回 isFocus 和 search 这两个变量的判断</li>
<li>热门搜索 的数据是直接在Vuex拿，Vuex在 nuxtServerInit 中 axios.get() 接口，并把数据commit到state中；推荐搜索的，是绑定搜索框的input事件，向后端接口获取数据&#x2F; search变量的watch</li>
</ul>
</li>
</ul>
<h4 id="菜单-menu-vue组件"><a href="#菜单-menu-vue组件" class="headerlink" title="菜单 menu.vue组件"></a>菜单 menu.vue组件</h4><ul>
<li>需求：见下图。鼠标移动到左边的item会出现右边。移开别处则右边会消失；移到右边则不会消失<br><img src="/img/%E7%BE%8E%E5%9B%A2%E7%BD%91/menu.png"></li>
<li>实现：<ul>
<li><strong>DOM</strong>： 左边的部分是 dl&gt;dt（全部分类）&gt;dd（每个栏）；右边的部分是 div&gt;template&gt;h4+span 实现，右边的v-if&#x3D;’kind’</li>
<li>事件<ul>
<li><strong>左边item的@mouseenter</strong>：<code>this.kind =e.target.querySelector(&#39;i&#39;).classname</code>。e是函数参数（鼠标移动到的节点）</li>
<li>左边的@mouseleave:  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> self = <span class="variable language_">this</span>; <span class="comment">// 这里用设置timer的方法，让鼠标移动到右框的时候就clearTimeout让右框不消失</span></span><br><span class="line">self.<span class="property">_timer</span> = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;self.<span class="property">kind</span> = <span class="string">&#x27;&#x27;</span>&#125;,<span class="number">150</span>)</span><br></pre></td></tr></table></figure></li>
<li>右边的@mouseenter：<code>clearTimeout(this._timer)</code></li>
<li>右边的@mouseleave：<code>this.kind=&#39;&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li>数据结构：见下图。name是左边item的内容，eg. 美食；type用来绑定左边item的class属性（其实是为了便于显示前面的icon）；child是item对应的子栏（右边）<br><img src="/img/%E7%BE%8E%E5%9B%A2%E7%BD%91/menu-data.png"></li>
<li>左边部分直接<code>v-for in $store.state.home.menu</code>生成；右边部分由两层v-for生成，第一层v-for一个计算属性，<strong>该属性</strong> <code>return this.$store.state.home.menu.filter(item =&gt; item.type===this.kind)[0]</code>。所以这个组件的数据也是Vuex在 nuxtServerInit 中 axios.get() 接口，并把数据commit到state中</li>
</ul>
<h4 id="城市组件-geo-vue"><a href="#城市组件-geo-vue" class="headerlink" title="城市组件 geo.vue"></a>城市组件 geo.vue</h4><p>功能：一开始是显示用户所在的城市；用户也可以在切换城市页面进行城市切换<br>实现：组件中读取Vuex的State的city<br>Vuex中在action中nuxtServerInit阶段就请求一个接口，这个接口根据IP地址找到城市，返回。Vuex得到城市后就保存在state.city中；<br>而切换城市页面调用的Vuex的mutations的changCity这个方法，会让state.city &#x3D; city 并localstorage.city &#x3D; city;<br>同时Vuex的state读取city是 if(localstorage.city) { city &#x3D; localstorage.city} 如果localstorage没有就读取ip地址的</p>
<h3 id="注册页"><a href="#注册页" class="headerlink" title="注册页"></a>注册页</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>用户输入昵称和邮箱后，给注册者的邮箱法验证码；输入正确的验证码书和遍密码后，就能进行注册</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>样式：通过Element UI的 表单-表单验证 实现 样式 和 <strong>校验规则</strong>。eg. 验证前后两次输入的密码是否一致（这个是Element UI的表单验证-自定义校验规则）</li>
<li>发送验证<br>点击发送验证码的按钮之后，绑定的函数会POST注册者的昵称和邮箱给一个接口。这个接口会用腾讯邮件提供的SMTP功能，给注册者的邮箱发送随机生成的验证码，并把验证码、过期时间、验证码和昵称的对应关系放进Redis中</li>
<li>注册<br>点击注册的按钮之后，绑定的函数会POST昵称、用户名、密码（<strong>加密传输</strong>，用<br>crypto-js）和验证码给一个接口。这个接口先校验注册者的验证码和Redis中保存的是否一致，然后从数据库中看改昵称是否被注册等，都符合的话就对新用户信息进写库</li>
</ul>
<h3 id="登录页"><a href="#登录页" class="headerlink" title="登录页"></a>登录页</h3><p>用 passport 验证，据说有固定写法 </p>
<h3 id="切换城市页"><a href="#切换城市页" class="headerlink" title="切换城市页"></a>切换城市页</h3><p>由于数据结构上的麻烦，我们这里点击城市后跳转到首页后，首页的geo.vue那里还是显示ip地址对应的城市。按理应该把Vuex中的city给改一下。</p>
<h4 id="iselect-vue-组件"><a href="#iselect-vue-组件" class="headerlink" title="iselect.vue 组件"></a>iselect.vue 组件</h4><ul>
<li>需求：按 省份+城市 进行下拉框选择；直接搜索</li>
<li>DOM：Element UI的 选择器 和 输入框-远程搜索</li>
<li>实现<ul>
<li>省份 + 城市 下拉框选择：在mounted的时候请求得到省份数据，写进 province 变量中，v-for就能得到省份的下拉框；对省份下拉框v-model&#x3D;pvalue，对pvalue变量进行watch，有变化就请求城市数据写进 city 变量中</li>
<li>直接搜索。input事件直接访问接口，最好用loadshd的debounce做延时处理</li>
</ul>
</li>
</ul>
<h4 id="按拼音选择的category-vue组件"><a href="#按拼音选择的category-vue组件" class="headerlink" title="按拼音选择的category.vue组件"></a>按拼音选择的category.vue组件</h4><ul>
<li>需求：按拼音字母选择城市；点某个字母页面会move到该字母城市所在位置</li>
<li>实现<ul>
<li>DOM: dl&gt;dt&gt;dd</li>
<li>点击字母实现页面滚动。把字母写成超链接<code>&lt;a :href=&quot;# item.id&quot;&gt;</code>，然后后面的栏都写id属性即可</li>
<li>通过async mounted得到后端给我们的中国所有城市的数据后，我们怎么进行<strong>拼音分类</strong>？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> blocks = [];</span><br><span class="line">  <span class="keyword">let</span> &#123;</span><br><span class="line">    status,</span><br><span class="line">    <span class="attr">data</span>: &#123; city &#125;</span><br><span class="line">  &#125; = <span class="keyword">await</span> self.<span class="property">$axios</span>.<span class="title function_">get</span>(<span class="string">&quot;/geo/city&quot;</span>);</span><br><span class="line">  <span class="comment">// 对全国的城市做拼音处理并分类</span></span><br><span class="line">  <span class="keyword">if</span> (status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p;</span><br><span class="line">    <span class="keyword">let</span> c;</span><br><span class="line">    <span class="keyword">let</span> d = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 拼音处理</span></span><br><span class="line">    city.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// p 变量保存城市名拼音的首位</span></span><br><span class="line">      p = pyjs</span><br><span class="line">        .<span class="title function_">getFullChars</span>(item.<span class="property">name</span>)</span><br><span class="line">        .<span class="title function_">toLocaleLowerCase</span>()</span><br><span class="line">        .<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// c 变量保存城市名拼音的首位的 ASCII 码。大写的A-Z是65-90，小写的a-z是97-122。我们通过ASCII码进行排序</span></span><br><span class="line">      c = p.<span class="title function_">charCodeAt</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (c &gt; <span class="number">96</span> &amp;&amp; c &lt; <span class="number">123</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[p]) &#123;</span><br><span class="line">          d[p] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        d[p].<span class="title function_">push</span>(item.<span class="property">name</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 整理成我们想要的数据结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(d)) &#123;</span><br><span class="line">      blocks.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: k.<span class="title function_">toUpperCase</span>(),</span><br><span class="line">        <span class="attr">city</span>: v</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    blocks.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">title</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - b.<span class="property">title</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>));</span><br><span class="line">    self.<span class="property">block</span> = blocks;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>for (let [k, v] of Object.entries(d)) &#123;  &#125;</code> 用来<strong>遍历对象，能获取对象的键和键值</strong></li>
</ul>
</li>
</ul>
<h3 id="产品列表页"><a href="#产品列表页" class="headerlink" title="产品列表页"></a>产品列表页</h3><h4 id="category-vue组件"><a href="#category-vue组件" class="headerlink" title="category.vue组件"></a>category.vue组件</h4><ul>
<li>需求<br><img src="/img/%E7%BE%8E%E5%9B%A2%E7%BD%91/%E5%88%86%E7%B1%BB.png"></li>
<li>实现<ul>
<li>DOM：dl（分类）&gt;dt（全部）&gt;dd（item），item是另一个组件，能有下拉框</li>
</ul>
</li>
</ul>
<h4 id="map-vue-组件"><a href="#map-vue-组件" class="headerlink" title="map.vue 组件"></a>map.vue 组件</h4><ul>
<li>需求：显示产品的地图位置</li>
<li>实现：用高德开放平台的JS API。使用方法见代码、笔记和官方文档</li>
</ul>
<h3 id="详情页"><a href="#详情页" class="headerlink" title="详情页"></a>详情页</h3><p>页面的路由可以是&#x2F;detail&#x2F;:id<br>由其他页面跳转到详情页可以有<strong>登录拦截</strong>，实现对登录和没登录的使用者呈现不同页面。实现方法还是获取数据的时候（eg. async Data）的时候请求接口，由接口根据passport判断登录状态</p>
<h3 id="购物车页面"><a href="#购物车页面" class="headerlink" title="购物车页面"></a>购物车页面</h3><p>用Element UI的 表格-多选，表格-自定义 和 计时器 实现。<br>纯手写实现的购物车见 &#x2F;mycart 页面 。两个注意点:</p>
<ul>
<li>checkbox的v-model&#x3D;item.choose（源数据的item可以没有choose这个属性）</li>
<li>@click&#x3D;item.count++ 可以直接写在html中，方便获取具体的item.count</li>
</ul>
<h2 id="后端与数据库"><a href="#后端与数据库" class="headerlink" title="后端与数据库"></a>后端与数据库</h2><p>说实话，还是不太熟，只能大概看懂；数据库操作相关的接口也只能大概看懂</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>见笔记和代码吧，这部分只能大概看懂而已<br>其中一些接口（eg. 由ip地址定位，中国所有城市的数据）是访问作者写的一个接口实现的</p>
<h2 id="一些样式"><a href="#一些样式" class="headerlink" title="一些样式"></a>一些样式</h2><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><ul>
<li>用lodash的debounce做函数延时执行的处理。第一个参数是要执行的函数，第二个参数是延迟的毫秒数。使用方法如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="attr">method</span>: &#123;</span><br><span class="line">    <span class="attr">test</span>: _.<span class="title function_">debounce</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>for (let [k, v] of Object.entries(d)) &#123;  &#125;</code> 用来<strong>遍历对象，能获取对象的键和键值</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/16/MeiTuan-app%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" data-id="clmniym71001cbb874123b8yh" data-title="MeiTuan-app项目总结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GoWhere项目总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/10/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2019-11-10T15:02:21.000Z" itemprop="datePublished">2019-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/10/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">GoWhere项目总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>缘起：该项目是 7 月末刚开始学 Vue 的时候，一开始看官方文档，觉得不够扎实，需要一些实战练习，所以在慕课网上看《Vue2.5 开发去哪儿网 App 从零基础入门到实战项目》做了此项目。后来又自己从头到尾把项目敲了一遍。最近复习又把这个项目的实现过了一遍，总结成此博文<br>后来又给这个项目搭了个基于Koa2的服务器，完善登录验证等功能</p>
<h1 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h1><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><ul>
<li>header 组件：用 Vuex 获取城市数据</li>
<li>轮播效果是通过 vue-awesome-swiper 实现的</li>
</ul>
<h2 id="切换城市页"><a href="#切换城市页" class="headerlink" title="切换城市页"></a>切换城市页</h2><ul>
<li>选择城市后会且切换到首页并把城市数据更新到 Vuex 中</li>
<li>搜索框：对 input 做 v-model&#x3D;’key’, 对 key 这个变量 watch，有变化就遍历数据把复合的 push 到 result 数组中（可以设置 timer 进行防抖）。</li>
<li><h2 id="字母表的滑动效果：-安装-better-scroll-实现滑动。用它的-scrollToElement-DOM-节点-实现点击滑动到某个字母"><a href="#字母表的滑动效果：-安装-better-scroll-实现滑动。用它的-scrollToElement-DOM-节点-实现点击滑动到某个字母" class="headerlink" title="字母表的滑动效果：- 安装 better-scroll 实现滑动。用它的 scrollToElement( DOM 节点 ) 实现点击滑动到某个字母"></a>字母表的滑动效果：<br>- 安装 better-scroll 实现滑动。用它的 scrollToElement( DOM 节点 ) 实现点击滑动到某个字母</h2></li>
</ul>
<h2 id="详情页"><a href="#详情页" class="headerlink" title="详情页"></a>详情页</h2><p>评论组件的星星（虽然在这个项目里没做不过需要的话也可以讲一下怎么实现的）</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>form 后端。部分 json 是通过自己写的一个爬虫到去哪儿网抓取生成的。不过爬虫代码太垃圾了了又没优化所以大家忘了这个事吧</p>
<h1 id="后端和数据交互"><a href="#后端和数据交互" class="headerlink" title="后端和数据交互"></a>后端和数据交互</h1><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>用 Koa2 搭建服务器，没有用数据库，数据放在 json 文件中，通过对 json 文件的读，写和查询实现需要的功能</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="proxy-转发请求"><a href="#proxy-转发请求" class="headerlink" title="proxy 转发请求"></a>proxy 转发请求</h3><p>用 proxy 转发请求到服务器接口 localhost:3000，这个功能能直接实现跨域？还是说我们服务器默认设置就是 Access-Control-Allow-Orgin: *<br>答：proxy 的 changeOrgin 是 true 的话，能在开发环境下虚拟一个服务端接收你的请求并代你发送该请求，不会有跨域问题；Koa2 在开发环境下似乎也不会有问题，真正想用跨域 Koa2 得在 app.js 中引入 cors 中间件并 use</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /config/index.js</span></span><br><span class="line"><span class="attr">proxyTable</span>: &#123;</span><br><span class="line">     <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//  在开发环境中（dev），当去请求api目录的时候</span></span><br><span class="line">       <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,<span class="comment">// 会把请求转发到当前服务器的3000端口上</span></span><br><span class="line">       <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 是否跨域</span></span><br><span class="line">       <span class="attr">pathRewrite</span>: &#123;<span class="comment">//  不过希望把路径做一个替换</span></span><br><span class="line">         <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/&#x27;</span><span class="comment">//  一旦请求的地址是以/app开头的，那么就替换请求到...中</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现用户登录及-token-验证"><a href="#实现用户登录及-token-验证" class="headerlink" title="实现用户登录及 token 验证"></a>实现用户登录及 token 验证</h3><ol>
<li>本项目暂时注册和验证登录功能不完善，默认用户在登录页输入用户名和密码都是新用户。点击登录则向服务器 POST 用户名和密码；服务器收到后给新用户生成随机字符 token（暂时还无法保证是唯一性的）和 token 过期时间，把这一套用户数据都写进数据库（json）中，返回给组件用户名和 token；组件收到后把用户名和 token 存进 State 和 localStorage 中</li>
<li>设置导航守卫。用 router.beforeEach 这个路由钩子，对 to.path &#x3D; 某些页面（eg. 购物车） 在跳转前检验时候是否有 token，没有就强制跳转到登录页面</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置导航守卫。用router.beforeEach注册一个全局守卫，判断是否有登录状态</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (token === <span class="string">&#x27;&#x27;</span> || token === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>让浏览器每次请求都在头部带 token。通过请求拦截器实现，通过对 axios 的配置新增一个请求拦截让请求头带上 token</li>
<li>axios 的响应拦截用来处理 token 过期的情况，收到服务器响应 401 就清空 localStorage 的 token 并跳转到登录页（这个 清空 localStorage 的 token 并跳转到登录页 其实也是点击 退出登录 按钮要做的事，可以把这个动作封装好放在 Vuex 的 actions 中）。所以服务器要做的事情是：收到除了注册外的请求，都会验证请求头的 token 是否存在，拿 token 去数据库（json）查这个 token 对应的过期时间，过期了则返回 401（这个实现在请求 json 数据的时候验证，现在只在 getAllCity 这个接口有这个验证）；没过期则正常返回数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/api/axios.js axios的配置文件</span></span><br><span class="line"><span class="comment">// 3.设置拦截器</span></span><br><span class="line"><span class="title class_">Axios</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">token</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 响应拦截用来检测服务器返回401，token过期</span></span><br><span class="line"><span class="title class_">Axios</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (error.<span class="property">response</span>.<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          <span class="comment">// 服务器检测到token和数据库存的token的过期时间已经过期了的话返回401。跳转登录</span></span><br><span class="line">          <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">          <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机字符token</span></span><br><span class="line"><span class="keyword">let</span> token = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">  .<span class="title function_">toString</span>(<span class="number">16</span>)</span><br><span class="line">  .<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// 过期时间</span></span><br><span class="line"><span class="keyword">let</span> expire = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">expire = expire.<span class="title function_">getTime</span>() + <span class="number">604800000</span> <span class="comment">// 一周的有效期</span></span><br></pre></td></tr></table></figure>

<p>实现过程中参考的博客贴<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34336292/article/details/88611230">基于 Koa2 对 json 文件进行增删改查</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41772754/article/details/88075391">axios 配置</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/web-record/p/9876916.html">Vue 项目中实现用户登录及 token 验证</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zdd2017/p/9871925.html">Vuex 登录验证及保持登录状态</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/10/GoWhere%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" data-id="clmniym6j000fbb87ddrh9ijv" data-title="GoWhere项目总结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-模块化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/07/%E6%A8%A1%E5%9D%97%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2019-11-07T08:50:21.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/07/%E6%A8%A1%E5%9D%97%E5%8C%96/">模块化开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><p>解决命名冲突、提高代码的复用性和可维护性</p>
<h2 id="模块化的实现方式"><a href="#模块化的实现方式" class="headerlink" title="模块化的实现方式"></a>模块化的实现方式</h2><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。少用了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">globalVariable</span>)&#123;</span><br><span class="line">   globalVariable.<span class="property">test</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">   <span class="comment">// ... 声明各种变量、函数都不会污染全局作用域</span></span><br><span class="line">&#125;)(globalVariable)</span><br></pre></td></tr></table></figure>
<h3 id="AMD-和-CMD"><a href="#AMD-和-CMD" class="headerlink" title="AMD 和 CMD"></a>AMD 和 CMD</h3><p>其实这两种实现方式也已经很少见到</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>Node.js，webpack<br>每个文件是一个模块，有自己的作用域；在模块内部module变量代表模块本身；<code>module.exports</code>属性代表模块的对外接口（通过写<code>module.exports</code>的属性&#x2F;其本身来导出数据，<code>require</code>的时候是得到<code>module</code>，用<code>module</code>的属性&#x2F;其本身来获取数据）</p>
<p>模块中写<code>exports</code>会默认等于<code>module.exports</code>，也可以用<code>exports</code>的属性（不能是本身，会重写exports）来导出数据</p>
<h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>ES6模块功能主要由两个命令构成：import和export。import命令用于输入其他模块提供的功能。export命令用于规范模块的对外接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&#x27;weiqinl&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="string">&#x27;2018&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出一个对象（推荐）</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;weiqinl&#x27;</span></span><br><span class="line"><span class="keyword">var</span> year = <span class="string">&#x27;2018&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, year&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出函数或类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// export default 命令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 正常命令</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span> <span class="comment">//后缀.js不能省略</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果遇到export default命令导出的模块</span></span><br><span class="line"><span class="keyword">import</span> ed <span class="keyword">from</span> <span class="string">&#x27;./export-default.js&#x27;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/07/%E6%A8%A1%E5%9D%97%E5%8C%96/" data-id="clmniym86004qbb87fcf52oo0" data-title="模块化开发" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-性能优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2019-11-06T13:30:21.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="性能优化概括"><a href="#性能优化概括" class="headerlink" title="性能优化概括"></a>性能优化概括</h2><p>主要的是：</p>
<ul>
<li>降低请求量：合并资源，减少 HTTP 请求数，minify &#x2F; gzip 压缩，webP，lazyLoad。</li>
<li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。</li>
<li>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。（HTML 文件每次都向服务器询问是否有更新，JS&#x2F;CSS&#x2F;Image资源文件则不请求更新，直接使用本地缓存）</li>
<li>渲染：JS&#x2F;CSS优化，加载顺序，服务端渲染，pipeline。</li>
</ul>
<h2 id="加载相关"><a href="#加载相关" class="headerlink" title="加载相关"></a>加载相关</h2><h3 id="为什么要强调-CSS-要放在-header-里，js-放在尾部"><a href="#为什么要强调-CSS-要放在-header-里，js-放在尾部" class="headerlink" title="为什么要强调 CSS 要放在 header 里，js 放在尾部"></a>为什么要强调 CSS 要放在 header 里，js 放在尾部</h3><p>构建 Render 树需要 DOM 和 CSSOM。由于 CSS 不会阻塞文档的解析，但是会阻塞文档渲染。把 CSS 放在头部可以先生成 CSSOM 树，后续渲染 DOM 的时候，可以一次性构建 Render 树，只需要渲染一次；如果把 CSS 放在后面，会先解析一次 DOM，加载 CSS 之后，会重新渲染之前的 DOM，需要两次渲染。所以 css 放头部能减少渲染时间</p>
<p>而 script 引的 js 文件会阻塞浏览器的解析，也就是说发现一个外链脚本时，<strong>需等待脚本下载完成并执行后才会继续解析 HTML</strong></p>
<p>普通的脚本会阻塞浏览器解析，加上 defer 或 async 属性，脚本就变成异步，可等到解析完毕再执行</p>
<ul>
<li>async 异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 前，但不确定在 DOMContentLoaded 事件的前后</li>
<li>defer 延迟执行，相当于放在 body 最后（理论上在 DOMContentLoaded 事件前）</li>
<li>执行 js 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑用 Web Worker,它可以让我们另开一个线程执行脚本，不影响渲染</li>
</ul>
<h3 id="load-DOMContentLoaded-domready"><a href="#load-DOMContentLoaded-domready" class="headerlink" title="load &amp; DOMContentLoaded &amp; domready"></a>load &amp; DOMContentLoaded &amp; domready</h3><ul>
<li>DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片</li>
<li>domready 事件在 DOM 加载后、资源加载之前被触发，在本地浏览器的 DOMContentLoaded 事件的形式被调用</li>
<li>load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已加载完成</li>
</ul>
<h3 id="白屏、首屏"><a href="#白屏、首屏" class="headerlink" title="白屏、首屏"></a>白屏、首屏</h3><h4 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h4><p>白屏时间指的是浏览器开始显示内容的时间，一般认为浏览器开始渲染 body 或者解析完 head 标签的时候就是页面白屏结束的时间<br><strong>优化</strong>：</p>
<ul>
<li>加快 js 的执行速度，比如无限滚动的页面，可以用 js 先渲染一个屏幕范围内的东西</li>
<li>减少文件体积</li>
<li>首屏同步渲染 html,后续的滚屏再异步加载和渲染</li>
</ul>
<h4 id="首屏"><a href="#首屏" class="headerlink" title="首屏"></a>首屏</h4><p>首屏时间是指用户打开网站开始，到浏览器首屏内容渲染完成的时间<br><strong>优化</strong>：</p>
<ul>
<li>图片懒加载</li>
<li>http 静态资源尽量用多个子域名（能开多个 TCP 链接）；</li>
<li>在 js，css，image 等资源响应的 httpheaders 里，设置 expires，last-modified</li>
<li>雪碧图（能减少 HTTP Requests 的数量）</li>
</ul>
<h2 id="渲染相关"><a href="#渲染相关" class="headerlink" title="渲染相关"></a>渲染相关</h2><h3 id="不考虑缓存和优化网络协议的前提下，可以通过哪些方式来最快的渲染页面"><a href="#不考虑缓存和优化网络协议的前提下，可以通过哪些方式来最快的渲染页面" class="headerlink" title="不考虑缓存和优化网络协议的前提下，可以通过哪些方式来最快的渲染页面"></a>不考虑缓存和优化网络协议的前提下，可以通过哪些方式来最快的渲染页面</h3><p>无非就是减少生成渲染树的时间了，从 DOM+CSSOM 入手，解决方案如下：</p>
<ul>
<li>从文件大小考虑</li>
<li>从 script 标签使用上来考虑 async 和 differ</li>
<li>从需要下载的内容是否需要在首屏使用上来考虑</li>
<li>CSS 选择器优化，HTML 扁平层级</li>
</ul>
<h3 id="如何减少重绘回流"><a href="#如何减少重绘回流" class="headerlink" title="如何减少重绘回流"></a>如何减少重绘回流</h3><ul>
<li>使用 transform 替代 top</li>
<li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li>
<li>CSS 选择符从右往左匹配查找，避免节点层级过多</li>
<li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。通过以下几个常用属性可以生成新图层：<ul>
<li>position: fixed</li>
<li>video、iframe 标签</li>
<li>通过动画实现的 opacity 动画转换</li>
</ul>
</li>
</ul>
<h3 id="为什么操作-DOM-性能差"><a href="#为什么操作-DOM-性能差" class="headerlink" title="为什么操作 DOM 性能差"></a>为什么操作 DOM 性能差</h3><p>DOM 属于渲染引擎中的东西，而 JS 属于 JS 引擎。当我们通过 JS 操作 DOM 的时候，涉及到两个线程之间的通信；并且操作 DOM 可能还会带来重绘回流的情况</p>
<h3 id="如何插入几万个-DOM-并不卡住界面"><a href="#如何插入几万个-DOM-并不卡住界面" class="headerlink" title="如何插入几万个 DOM 并不卡住界面"></a>如何插入几万个 DOM 并不卡住界面</h3><p>有两种实现思路：时间分片 和 虚拟列表<br>详见：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yTuoa7ug7kJf14yv5-Nliw">高性能渲染十万条数据（时间分片）</a></p>
<h4 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame()"></a>window.requestAnimationFrame()</h4><p>通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">requestAnimationFrame()</a> 去循环的插入 DOM 来。每 16 ms 刷新一次（浏览器是 60Hz 的刷新率，FPS (表示每秒画面更新的次数) 是 60frame&#x2F;s, 每 1000 &#x2F; 60 &#x3D; 16.6ms 才会更新一次）。其实不一定是16ms，因为每个人的屏幕刷新频率不一定都是60，总之 <strong>requestAnimationFrame 是跟随系统刷新时间走的，它保证回调函数在屏幕每一次刷新间隔中只能被执行一次</strong>，这样就不会引起丢帧的情况<br>该方法接收一个回调函数作为参数，回调函数会在浏览器下一次重绘之前执行，也可以用来更新动画</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//需要插入的容器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> total = <span class="number">100000</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 一次插入 20 条</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> once = <span class="number">20</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//总页数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> page = total / once</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//每条记录的索引</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> index = <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//循环加载数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params">curTotal, curIndex</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (curTotal &lt;= <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 每页多少条</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> pageCount = <span class="title class_">Math</span>.<span class="title function_">min</span>(curTotal, once)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pageCount; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          li.<span class="property">innerText</span> = curIndex + i + <span class="string">&#x27; : &#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * total)</span></span><br><span class="line"><span class="language-javascript">          ul.<span class="title function_">appendChild</span>(li)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">loop</span>(curTotal - pageCount, curIndex + pageCount)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">loop</span>(total, index)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="再优化版：DocumentFragment"><a href="#再优化版：DocumentFragment" class="headerlink" title="再优化版：DocumentFragment"></a>再优化版：DocumentFragment</h4><p>见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment/DocumentFragment">MDN</a></p>
<blockquote>
<p>DocumentFragment，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的 Document使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为 DocumentFragment不是真实DOM树的一部分，<strong>它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题</strong>。<br>可以使用 document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment</p>
</blockquote>
<p>所以我们可以认为 <code>DocumentFragment</code> 是存在内存中的，所以将子元素插入到<code>DocumentFragment</code>时不会引起页面回流<br>所以上面的 loop 函数函数可以改成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params">curTotal, curIndex</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(curTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> pageCount = <span class="title class_">Math</span>.<span class="title function_">min</span>(curTotal, once)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i &lt; pageCount;i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">      li.<span class="property">innerText</span> = curIndex + i + <span class="string">&#x27; : &#x27;</span> + (<span class="title class_">Math</span>.<span class="title function_">random</span>() * total)</span><br><span class="line">      fragment.<span class="title function_">appendChild</span>(li)</span><br><span class="line">    &#125;</span><br><span class="line">    ul.<span class="title function_">appendChild</span>(fragment)</span><br><span class="line">    <span class="title function_">loop</span>(curTotal - pageCount, curIndex + pageCount)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h4><p>这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。当我们滚动页面的时候就会实时去更新 DOM。react-virtualized 就有这个功能</p>
<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><h3 id="大小优化"><a href="#大小优化" class="headerlink" title="大小优化"></a>大小优化</h3><p>计算图片大小：<code>对于一个</code>100px _ 100px<code>的图片，图像中有</code>10000px<code>的点，每一个</code>px<code>有</code>4<code>个通道（</code>rgba<code>），每一个通道</code>1<code>个字节（</code>1byte &#x3D; 8bit<code>），所以该图片大小为</code>10000 _ 4 &#x2F; 1024&#96; &#x3D; 39KB</p>
<ul>
<li>减少像素点</li>
<li>减少每个像素点能够显示的颜色</li>
</ul>
<h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><ul>
<li>类修饰图片用 CSS 去代替</li>
<li>懒加载</li>
<li>图片都用 <strong>CDN 加载</strong>。计算出适配屏幕的宽度，然后去请求相应裁剪好的图片</li>
<li>小图使用 base64 格式</li>
<li>将多个图标文件整合到一张图片中（雪碧图）</li>
<li>选择正确的图片格式：<ul>
<li>尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。</li>
<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>
<li>照片使用 JPEG</li>
</ul>
</li>
</ul>
<h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。eg. 有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数，wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">func, wait = <span class="number">50</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 缓存一个定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">  <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// apply第二个参数是数组</span></span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">debounce</span>(<span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">&#125;, <span class="number">1000</span>)(<span class="string">&quot;666&quot;</span>); <span class="comment">// 1s后出现 666</span></span><br></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>防抖是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</strong>。eg. 滚动事件中会发起网络请求，我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要节流的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">func, wait = <span class="number">50</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 将当前时间和上一次执行函数时间对比</span></span><br><span class="line">    <span class="comment">// 如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt; wait) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试。setInterval设置了一个每隔50ms执行的，但是节流函数能强制把它改成每隔1000ms执行</span></span><br><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">  <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我要把你改成1000ms才执行&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>),</span><br><span class="line">  <span class="number">50</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>可以用<code>rel=&quot;preload&quot;</code>开启，强制浏览器请求资源</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;http://blog.poetries.top&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>可以通过预渲染<strong>将下载的文件预先在后台渲染</strong>，可以使用以下代码开启预渲染</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;prerender&quot;</span> href=<span class="string">&quot;http://blog.poetries.top&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>预渲染虽然可以提高页面的加载速度，但是要<strong>确保该页面大概率会被用户在之后打开</strong>，否则就是白白浪费资源去渲染</p>
<h2 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;dns-prefetch&quot;</span> href=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h2><p>懒执行就是<strong>将某些逻辑延迟到使用时再计算</strong><br>该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行<br>懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>懒加载就是<strong>将不关键的资源延后加载</strong><br>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西</p>
<blockquote>
<p>对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中。当进入视口区时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-src</span>=<span class="string">&quot;https://clubimg.club.vmall.com/data/attachment/forum/201911/10/101520zmot0v4cy3r1movs.jpg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有若干图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">lazyload</span>(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onscroll</span> = lazyload;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//监听页面滚动事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> clientHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>; <span class="comment">//可见区域高度</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> scrollTop =</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>; <span class="comment">//滚动条距离顶部高度</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; img.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (img[i].<span class="property">offsetTop</span> &lt; clientHeight + scrollTop) &#123;</span></span><br><span class="line"><span class="language-javascript">        img[i].<span class="property">src</span> = img[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        n = i + <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN（Content Delivery Network，内容分发网络）将源站的内容发布到接近用户的网络“边缘”，用户可以就近获取所需数据（缓存数据），不仅降低了网络的拥塞状况、提高请求的响应速度，也能够减少源站的负载压力。<br>因此，我们可以将<strong>静态资源尽量使用 CDN 加载</strong>，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意<strong>CDN 域名要与主站不同</strong>，否则每次请求都会带上主站的 Cookie，平白消耗流量</p>
<p>参考资料<br>掘金小册-前端面试之道</p>
<h3 id="CDN的原理"><a href="#CDN的原理" class="headerlink" title="CDN的原理"></a>CDN的原理</h3><p>参考 <a target="_blank" rel="noopener" href="https://juejin.im/post/5d105e1af265da1b71530095">博客1</a>，<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/67298?spm=a2c4e.11153940.0.0.597476cfqRaHgb">博客2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" data-id="clmniym7w0046bb87506p4ti6" data-title="性能优化" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JS的事件循环和Node.js的事件循环" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/03/JS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8CNode.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time class="dt-published" datetime="2019-11-03T15:02:21.000Z" itemprop="datePublished">2019-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/03/JS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8CNode.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">JS的事件循环和Node.js的事件循环</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JS-的事件循环"><a href="#JS-的事件循环" class="headerlink" title="JS 的事件循环"></a>JS 的事件循环</h1><h2 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h2><p>JS 运行的环境称之为宿主环境，eg. 浏览器，服务器，桌面等</p>
<h2 id="执行环境栈"><a href="#执行环境栈" class="headerlink" title="执行环境栈"></a>执行环境栈</h2><p>放执行环境的地方，栈尾就是活动的执行环境</p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>浏览器内核是多线程的：GUI 渲染线程、JavaScript 引擎线程、定时触发器线程、事件触发线程、异步 http 请求线程</p>
<ol>
<li>渲染引擎和 JS 引擎是互斥的，所以渲染引擎在解析 DOM 的时候遇到 srcipt 会被暂停，阻塞渲染</li>
<li>主线程依次执行代码时，遇到定时器，会将定时器交给<strong>定时器触发线程</strong>处理，当计数完毕后，<strong>事件触发线程</strong>会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行</li>
<li>事件触发线程遇到事件，eg. setTimeout 计时结束，Ajax 异步请求成功触发回调，该线程会将对应的事件处理程序加入任务队列的尾部，等待 JS 引擎的执行</li>
<li>http 请求线程处理 fetch，ajax，axios 等，也是主线程遇到异步请求就交给该线程处理，当监听到状态码变更，就把回调函数给<strong>事件线程</strong>，事件线程把回调函数加进任队列尾部</li>
</ol>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><blockquote>
<p>JS 引擎对任务队列的取出执行方式，以及与宿主环境的配合，称之为<strong>事件循环</strong>（Event Loop）</p>
</blockquote>
<p>当上面的线程发生了某些事，事件循环发现这些事有对应的处理程序（eg. 异步代码，延时器），事件循环会把处理程序挂起并放进<strong>任务队列</strong>中。一旦执行栈为空，事件循环就会从事件队列队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<h3 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h3><blockquote>
<p>不同的任务源会被分配到不同的事件队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。<strong>宏任务队列可以有多个，微任务队列只有一个</strong></p>
</blockquote>
<p><strong>微任务:</strong></p>
<ul>
<li>process.nextTick</li>
<li>promise.prototype.then</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<p><strong>宏任务:</strong></p>
<ul>
<li>script</li>
<li>setTimeout(比 setImmediate 前)</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I&#x2F;O</li>
<li>UI rendering</li>
</ul>
<p>所以正确的一次 Event loop 顺序是这样的:</p>
<ul>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 Event loop，执行宏任务中的异步代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 把async理解为promise的另一种写法即可</span></span><br><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt;async1 end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Promise1 =&gt; setTimeout1 =&gt; Promise2 =&gt; setTimeout2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一道腾讯PCG的面试题。同理把 async 理解为 Promise 的写法即可，这样 async1 函数中 的 async2 其实就是Promise中的同步部分，await后的部分就是 .then</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start - async1 start - async2 - promise1 - script end - async1 end - promise2 - setTimeout</span></span><br></pre></td></tr></table></figure>
<h1 id="Node-js-的事件循环"><a href="#Node-js-的事件循环" class="headerlink" title="Node.js 的事件循环"></a>Node.js 的事件循环</h1><p>在 Node.js 中，Event Loop 是一个消息线程。和 JS 的 Event Loop 是完！全！不！同！的！想起昨天我面试时的回答，我一直以为它们两个是一个机制，顿时觉得凉凉…</p>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>Node.js 采用 V8 作为 js 的解析引擎，而 I&#x2F;O 处理方面使用了自己设计的 libuv，<strong>libuv</strong> 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现<br><img src="/img/EventLoop/Node.png"></p>
<h2 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h2><p>libuv 引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行<br><img src="/img/EventLoop/%E9%98%B6%E6%AE%B5.png"><br>所以 node 中事件循环的顺序是：<br>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I&#x2F;O 事件回调阶段(I&#x2F;O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p>
<p><strong>我目前是理解为 node 把宏任务分类了，分为了 timer 队列， IO 队列，setImmediate 队列…这些不同的宏任务队列在 node 的不同阶段执行</strong></p>
<ul>
<li><strong>timers 阶段</strong>：这个阶段执行 timer（setTimeout、setInterval）<strong>的回调</strong>，即<strong>执行完</strong>timer 队列中的任务</li>
<li><strong>I&#x2F;O callbacks 阶段</strong>：处理一些上一轮循环中的少数未执行的 I&#x2F;O 回调</li>
<li>idle, prepare 阶段：仅 node 内部使用</li>
<li>poll 阶段：获取新的 I&#x2F;O 事件, 适当的条件下 node 将阻塞在这里</li>
<li>check 阶段：执行 <strong>setImmediate()</strong> 的回调</li>
<li>close callbacks 阶段：执行 socket 的 close 事件回调</li>
</ul>
<p>Node 中 process.nextTick 是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会执行，并且优<strong>先于其他 microtask 执行</strong>（可以理解为优先度最高的微任务？）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></span><br></pre></td></tr></table></figure>

<h1 id="两种事件循环的区别"><a href="#两种事件循环的区别" class="headerlink" title="两种事件循环的区别"></a>两种事件循环的区别</h1><p>浏览器环境下，<strong>microtask 的任务队列是每个 macrotask 执行完之后执行</strong>。而在 Node.js 中，microtask <strong>会在事件循环的各个阶段之间执行</strong>，也就是一类宏任务都执行完，再去执行 microtask 队列的任务<br>我现在理解为浏览器中是执行完<strong>一个</strong>宏任务再执行微任务，node是执行完<strong>一类</strong>宏任务再执行微任务</p>
<p><img src="/img/EventLoop/%E5%B7%AE%E5%BC%82.png"><br>我们看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code> 这个不用过多解释，常规思路<br><img src="/img/EventLoop/%E6%B5%8F%E8%A7%88%E5%99%A8.gif"><br>Node 端运行结果：<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code><br><img src="/img/EventLoop/Nodejs.gif"></p>
<p>参考文章<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Fundebug/article/details/86487117">浏览器与 Node 的事件循环(Event Loop)有何区别?</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈 Event Loop</a><br>掘金小册-前端面试之道</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/03/JS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8CNode.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" data-id="clmniym6z0015bb87233qf7or" data-title="JS的事件循环和Node.js的事件循环" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>