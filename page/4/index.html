<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jacleklm">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:locale">
<meta property="article:author" content="Jacleklm">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Nodejs基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/02/Nodejs%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2019-11-02T15:02:21.000Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/02/Nodejs%E5%9F%BA%E7%A1%80/">Nodejs基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Node-js的特性"><a href="#Node-js的特性" class="headerlink" title="Node.js的特性"></a>Node.js的特性</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境（runtime）, 是一个让 JavaScript 运行在服务端的开发平台， 使用了一个事件驱动、非阻塞 I&#x2F;O 的模型</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">非阻塞IO</a></h2><p>以JS为例，JavaScript为一种单线程语言，所以如果有很多任务需要执行，只能等前面的任务执行完了，再执行后面的任务。一旦遇到大量任务或者遇到一个耗时的任务（一个I&#x2F;O），网页就会被卡住。这种就是<strong>阻塞 I&#x2F;O</strong>。而Node.js在I&#x2F;O时函数立即返回，进程不等待I&#x2F;O完成，因为有Event Loop 的概念来解决这个问题</p>
<p><strong>Event Loop</strong>是一个程序结构，用于等待和发送消息和事件。简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I&#x2F;O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。当程序遇到耗时的I&#x2F;O操作的时候，就交给Event Loop线程去处理，同时生成一个<strong>事件队列</strong>来放置这些未执行完的任务，并且<strong>监听</strong>这些I&#x2F;O操作是否执行完成，主进程继续执行其他任务；等到I&#x2F;O操作完成后，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。这样就提高了任务执行的效率，这种运行模式就是<strong>非阻塞IO</strong> 和<strong>事件驱动</strong><br><img src="/img/Node/EventLoop.png"></p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>I&#x2F;O等异步操作结束后的通知，如上所述。其实就是观察者模式</p>
<h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/11/03/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">事件循环 Event Loop</a></h2><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/11/01/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/#more">异步编程</a></h2><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>path，fs，Buffer，EventEmitter，process </p>
<h3 id="Web为什么最适合Node-js"><a href="#Web为什么最适合Node-js" class="headerlink" title="Web为什么最适合Node.js"></a>Web为什么最适合Node.js</h3><p>用JS；在处理高并发（单位时间内访问量大）、I&#x2F;O密集场景性能优势明显<br>CPU密集：做计算、逻辑判断（压缩、解压、加密、解密）<br>I&#x2F;O密集：文件操作（文件存取）、网络操作（http）、数据库。CPU的处理速度是远大于I&#x2F;O的，也就是分析web页面需求很快，但是从计算机拿文件比较慢</p>
<h2 id="缺点-优点"><a href="#缺点-优点" class="headerlink" title="缺点 &amp; 优点"></a>缺点 &amp; 优点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node 上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。</p>
<h4 id="容错性较差，一旦出错就整个线程挂掉"><a href="#容错性较差，一旦出错就整个线程挂掉" class="headerlink" title="容错性较差，一旦出错就整个线程挂掉"></a>容错性较差，一旦出错就整个线程挂掉</h4><p>配合pm2等包，自动重启；</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>模板渲染</p>
<h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><p>提供Javascript run time进行服务端渲染</p>
<h3 id="日志上报"><a href="#日志上报" class="headerlink" title="日志上报"></a>日志上报</h3><h2 id="Nodejs的常用场景"><a href="#Nodejs的常用场景" class="headerlink" title="Nodejs的常用场景"></a>Nodejs的常用场景</h2><h2 id="http-server与其他语言搭建的服务器对比"><a href="#http-server与其他语言搭建的服务器对比" class="headerlink" title="http server与其他语言搭建的服务器对比"></a>http server与其他语言搭建的服务器对比</h2><p>参考资料<br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/146.html">慕课网-Node.js入门到企业Web开发中的应用</a><br>阮一峰的博客</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/02/Nodejs%E5%9F%BA%E7%A1%80/" data-id="clmniym6z0018bb874b5y1qx9" data-title="Nodejs基础" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-异步编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/01/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2019-11-01T15:02:21.000Z" itemprop="datePublished">2019-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/01/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>异步编程，就是通过利用客户端环境的 Event-Loop 机制，去异步地执行某些代码</p>
<h2 id="一些自己之前容易乱的关系"><a href="#一些自己之前容易乱的关系" class="headerlink" title="一些自己之前容易乱的关系"></a>一些自己之前容易乱的关系</h2><p>异步函数 &#x3D; 异步操作，异步函数中包含回调函数做参数。回调函数只是一个普通函数。异步函数可以写成Promise形式</p>
<p>以前，异步编程的方法，大概有下面四种。<br>回调函数<br>事件监听<br>Promise 对象</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。英语名为 callback。<br>例如fs的读取文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>readFile 函数的第二个参数，就是<strong>回调函数</strong>。第一个参数是错误对象err</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>当多个函数嵌套的时候，会出现“回调地狱”，代码难以理解。于是出现了Promise解决这个问题<br>Promise其实<strong>只是异步函数的一种新写法</strong>，允许将回调函数的横向加载，改成纵向加载</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFile = <span class="built_in">require</span>(<span class="string">&#x27;fs-readfile-promise&#x27;</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="property">promisify</span> </span><br><span class="line"><span class="keyword">const</span> readFile = <span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;./promisify.js&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">readFile</span>(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第一种方式是使用了 fs-readfile-promise 模块，它的作用就是返回一个 Promise 版本的 readFile 函数；第二种方法能把异步函数进行promisify处理赋值给一个变量。Promise 提供 then 方法加载回调函数，catch方法捕捉执行过程中抛出的错误</p>
<h3 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h3><p>Promise对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态<br>Promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）</p>
<h3 id="Promise实例"><a href="#Promise实例" class="headerlink" title="Promise实例"></a>Promise实例</h3><h4 id="Promise实例的生成方式"><a href="#Promise实例的生成方式" class="headerlink" title="Promise实例的生成方式"></a>Promise实例的生成方式</h4><ul>
<li>用new生成</li>
<li>promisify</li>
<li>直接require一些模块</li>
</ul>
<h4 id="监听结果的-Promise-prototype-then"><a href="#监听结果的-Promise-prototype-then" class="headerlink" title="监听结果的 Promise.prototype.then()"></a>监听结果的 Promise.prototype.then()</h4><p>普通写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  普通写法。先定义一个加载图片的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">src, callback, fail</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">  <span class="comment">//  load事件触发后就会调用作为第二个参数的callback函数</span></span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(img)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  error事件触发后就会调用作为第三个参数的fail函数</span></span><br><span class="line">  img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="title function_">fail</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  img.<span class="property">src</span> = src</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> src = <span class="string">&#x27;http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png&#x27;</span></span><br><span class="line"><span class="comment">// 正式加载</span></span><br><span class="line"><span class="title function_">loadImg</span>(src, <span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">width</span>)</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用Promise的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(img)</span><br><span class="line">    &#125;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    img.<span class="property">src</span> = src</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> src = <span class="string">&#x27;http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">loadImg</span>(src)</span><br><span class="line"><span class="comment">// then里面的第一个参数其实就是resolve函数，第二个参数（可选）就是reject函数（也可以写成catch的形式）</span></span><br><span class="line">result.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">width</span>)</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="捕获异常的Promise-prototype-catch"><a href="#捕获异常的Promise-prototype-catch" class="headerlink" title="捕获异常的Promise.prototype.catch()"></a>捕获异常的Promise.prototype.catch()</h4><p>虽然then的第二个参数可以是reject函数，不过后来大家都默认then只接收一个参数，最后统一用catch捕获异常</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">width</span>)</span><br><span class="line">&#125;.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="执行顺序与串联"><a href="#执行顺序与串联" class="headerlink" title="执行顺序与串联"></a>执行顺序与串联</h4><p>首先，Promise 新建后，<strong>里面的代码</strong>就会立即执行<br><strong>执行顺序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">width</span>)</span><br><span class="line">&#125;.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 忽然想在图片加载后也打印下hight，可以这么写，这两个.then几乎会同时触发</span></span><br><span class="line">result.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">height</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以这么写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(img)</span><br><span class="line">    &#125;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    img.<span class="property">src</span> = src</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">result.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">width</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  <span class="comment">// 如果要在后面继续加.then 打印img的height，必须return img，下一个.then才能接收到这个参数</span></span><br><span class="line">  <span class="keyword">return</span> img</span><br><span class="line">&#125;.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">height</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//  打印结果是1，2，3，4，5 （width和height同理）</span></span><br></pre></td></tr></table></figure>
<p>PS：Promise实例中的代码如果不涉及费时的操作，它的.then()执行顺序是比setTimeout第二个参数的为0的代码要早的<br><strong>串联</strong><br>一般用于Ajax请求，这里图片做演示<br>多个Promise实例要串联的时候，<strong>需要在.then()中return 第二个实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src = <span class="string">&#x27;http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">loadImg</span>(src)</span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">&#x27;http://img1.qunarzz.com/sight/p0/1603/1c/1c67791edbe2677b90.img.jpg_250x250_8f1dcbbd.jpg&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="title function_">loadImg</span>(src2)</span><br><span class="line">result.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个图片加载完成&#x27;</span>, img.<span class="property">width</span>)</span><br><span class="line">  <span class="comment">// 如果这种多个.then()没有返回一个premise实例，那就还是用原来那个promise实例</span></span><br><span class="line">  <span class="keyword">return</span> result2</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">img2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个图片加载完成&#x27;</span>, img2.<span class="property">width</span>)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">appendChild</span>(img2)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Promise-all-Promise-race"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all() &amp; Promise.race()"></a>Promise.all() &amp; Promise.race()</h3><p>这两个方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。都接收一个promise对象的数组。all()是待全部完成之后，统一执行success，race()是只要有一个完成，就执行success</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src = <span class="string">&#x27;http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">loadImg</span>(src)</span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">&#x27;http://img1.qunarzz.com/sight/p0/1603/1.jpg0_8f1dcbbd.jpg&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="title function_">loadImg</span>(src2)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([result, result2]).<span class="title function_">then</span>(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all&#x27;</span>, datas[<span class="number">0</span>])</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all&#x27;</span>, datas[<span class="number">1</span>])</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([result, result2]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;race&#x27;</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行结果为：<br><img src="/img/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/promise.png"></p>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Generator 函数是一个状态机，封装了多个内部状态。形式上，有两个特征，一是，function关键字与函数名之间有一个<strong>星号</strong>；二是，函数体内部使用<strong>yield表达式</strong>，定义不同的内部状态。<strong>一定要return</strong>，否则返回的对象的value属性值为undefined<br>调用 Generator 函数，会返回一个内部指针，而不是返回结果<br>用next方法，会移动内部指针（即执行异步任务的第一段），指向下一个遇到的 yield 语句<br>每次调用 next 方法，会返回一个对象，表示当前阶段的信息。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>当**next()**传入参数的时候，会被当作上个阶段异步任务的返回结果，此阶段的value就等于这个参数（一般用于yield用完了的时候）<br>【next()本来就有打印的功能？】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="number">5</span>) <span class="comment">// &#123; value: 5, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错<br>在 Generator 函数里，yield表达式如果用在另一个表达式之中，必须放在圆括号里面 </p>
<p>虽然 Generator 函数将异步操作表示得很简洁，但是<strong>流程管理却不方便</strong>（即何时执行第一阶段、何时执行第二阶段）。所以有了以下两种方案：</p>
<h3 id="Thunk-函数-Generator方案"><a href="#Thunk-函数-Generator方案" class="headerlink" title="Thunk 函数 + Generator方案"></a>Thunk 函数 + Generator方案</h3><p>Thunk 函数是自动执行 Generator 函数的一种方法。是一个实现“传名调用”的临时函数，把这个临时函数作为参数传入真正的函数即可</p>
<p>JavaScript 语言是传值调用。JS中的Thunk替换的是多参数函数而不是表达式，将其替换成一个只接受<strong>回调函数作为参数</strong>的单参数函数。<br>单参数版本，就叫做 Thunk 函数</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Thunkify 模块</p>
<p><strong>Thunk 函数现在可以用于 Generator 函数的自动流程管理</strong></p>
<h3 id="co-函数库-Generator方案"><a href="#co-函数库-Generator方案" class="headerlink" title="co 函数库 + Generator方案"></a>co 函数库 + Generator方案</h3><p>co 模块用于 Generator 函数的自动执行。co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async &#x2F; await"></a>async &#x2F; await</h2><h3 id="与Generator比"><a href="#与Generator比" class="headerlink" title="与Generator比"></a>与Generator比</h3><p>异步编程的最高境界，就是根本不用关心它是不是异步。很多人认为Async就是异步操作的终极解决方案<br>如果认真看完两种自动化的 Generator 的方法 ，会有一种蛋疼的感觉（因为有这种感觉所以这两种方案没有仔细总结在博客里）。Generator 设计的初衷就是为了流程控制，而我们却给它加上了自动的流程机。还不如使用 promise.then()。Async 函数作为<strong>自带流程机的 Generator 语法糖</strong>，就完美得解决了这个矛盾</p>
<p><strong>async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已</strong><br>Generator版：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>async 函数版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="与Promise比"><a href="#与Promise比" class="headerlink" title="与Promise比"></a>与Promise比</h3><p>相比Promise，.then()只是将callback拆分了，实际代码的语义化，执行顺序仍旧不清晰。async&#x2F;await才是最直接的同步写法。解决JS单线程造成的编写的代码视觉顺序和实际执行顺序不同的问题</p>
<h3 id="async-await用法总结"><a href="#async-await用法总结" class="headerlink" title="async &#x2F; await用法总结"></a>async &#x2F; await用法总结</h3><p>例如可以把Promise章节的代码改写为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(img)</span><br><span class="line">    &#125;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    img.<span class="property">src</span> = src</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> src = <span class="string">&#x27;http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png&#x27;</span></span><br><span class="line"><span class="keyword">var</span> src2 = <span class="string">&#x27;http://img1.qunarzz.com/sight/p0/1603/1c/1c67791edbe2677b90.img.jpg_250x250_8f1dcbbd.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">loadImg</span>(src)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> <span class="title function_">loadImg</span>(src2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">load</span>()</span><br></pre></td></tr></table></figure>
<p><strong>async</strong>：</p>
<ul>
<li>用于定义异步函数，<strong>函数可以返回一个 Promise 对象</strong>（所以函数执行的时候可以使用 then 方法添加回调函数）</li>
<li>async函数执行的时候，<strong>一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句</strong></li>
<li>async函数中的forEach如果参数函数也是async函数的话，会报错，因为forEach内循环的async函数其实是并发的，而不是先后顺序的。正确的写法是采用 for 循环，再在里面写async函数。By the way，确实希望多个请求并发执行，可以使用 Promise.all 方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>await</strong>：</li>
<li>用于需要等待一段时间才能出结果的情况（eg. 将异步函数的执行结果赋值给变量），<strong>await后面必须跟一个Promise实例</strong>（或说异步函数）</li>
<li>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中（或更实用的写法，在后面直接加.catch()的写法）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>().<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>await 命令只能用在 async 函数中</strong>，如果用在普通函数中，就会报错。PS: 其实await也能作为某些异步函数的运行前缀，例如用puppteer做爬虫的时候可以写<code>await page.focus(&#39;#kw&#39;)</code>，但自己写的async函数似乎不可以，还没明白</li>
</ul>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = &#123;</span><br><span class="line">  <span class="attr">load</span>: <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">loadImg</span>(src)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> <span class="title function_">loadImg</span>(src2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">page.<span class="title function_">load</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 1, 3, 2, &lt;img xxx&gt;, &lt;img xxx&gt;, 4</span></span><br></pre></td></tr></table></figure>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/generator-async">ECMAScript6标准入门</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/04/generator.html">阮一峰博客-《深入掌握 ECMAScript 6 异步编程》系列文章</a><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/190.html">慕课网-揭秘一线互联网企业前端JavaScript高级面试</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/01/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" data-id="clmniym7u0042bb87fl012kf6" data-title="异步编程" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前后端交互&amp;跨域" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/31/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92&%E8%B7%A8%E5%9F%9F/" class="article-date">
  <time class="dt-published" datetime="2019-10-31T15:02:21.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/31/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92&%E8%B7%A8%E5%9F%9F/">前后端交互&amp;跨域</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前后端数据交互"><a href="#前后端数据交互" class="headerlink" title="前后端数据交互"></a>前后端数据交互</h1><h2 id="利用-Cookie"><a href="#利用-Cookie" class="headerlink" title="利用 Cookie"></a>利用 Cookie</h2><p>Cookie 是一些数据, 存储于电脑上的文本文件中,只要客户端 cookie 开放且有数据，每一次请求都会自动添加到 http 报文中，后台可以实时接收观察获取这些 Cookie 。</p>
<p>Cookie 的作用就是用于解决 “如何记录客户端的用户信息”:</p>
<ul>
<li>当用户访问 web 页面时，他的名字可以记录在 cookie 中。</li>
<li>在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。</li>
</ul>
<h2 id="利用-Session-对象"><a href="#利用-Session-对象" class="headerlink" title="利用 Session 对象"></a>利用 Session 对象</h2><p>session 对象表示特定会话 session 的用户数据。</p>
<p>客户第一次访问支持 session 的 JSP 网页，服务器会创建一个 session 对象记录客户的信息。当客户访问同一网站的不同网页时，仍处于同一个 session 中。</p>
<p>request.getSession().setAttribute();<br>request.getSession().getAttribute();<br>只要浏览器不关闭，就能使用。所以用户访问网站整个生命都会用到的数据一般都用 session 来存储，比如用户名、登录状态之类的</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>PS：相对有点老了，用 fetch 方便很多<br>Ajax &#x3D; 异步 JavaScript 和 XML。是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p>
<h3 id="XHR-对象"><a href="#XHR-对象" class="headerlink" title="XHR 对象"></a>XHR 对象</h3><p>XMLHttpRequest（XHR) 对象是 Ajax 的基础，用于在后台与服务器交换数据。用 var 变量名 &#x3D; new XMLHttpRequest(); 创建</p>
<h4 id="XHR-的方法"><a href="#XHR-的方法" class="headerlink" title="XHR 的方法"></a>XHR 的方法</h4><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的</p>
<ul>
<li>open(method, url, async)方法。第一个参数是’GET’&#x2F;‘POST’；第三个参数是一个布尔值，同步&#x2F;异步<br>eg. <code>request.open(&#39;GET&#39;, &#39;/api/categories&#39;，true);</code></li>
<li>send(string)方法。用于将请求及参数发送到服务器，有参数时仅用于 POST。对于一些没带参数的请求方法，可以写成 send(null)</li>
</ul>
<h4 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h4><p>需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。<br>eg. <code>document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;</code></p>
<h4 id="状态信息及监听"><a href="#状态信息及监听" class="headerlink" title="状态信息及监听"></a>状态信息及监听</h4><p><strong>readyState</strong>属性存有 XMLHttpRequest 的状态信息，有以下几个属性值：</p>
<ul>
<li>0: （未初始化）XHR 对象已创建，open()未调用</li>
<li>1: （载入）send()已调用，正在发送请求</li>
<li>2: （载入完成）send()方法执行完成，已经收到全部响应的内容</li>
<li>3: （交互）正在解析内容</li>
<li><strong>4</strong>: （完成）响应内容解析完成，可以在客户端使用了</li>
</ul>
<p>status 属性，该属性有两个属性值：200，404<br>当 readyState 改变时，就会触发 onreadystatechange 事件；此外 XHR 对象还提供了其他监听事件：process 事件，load 事件（加载完成），error 事件，abort 事件（加载终止）。可以用 addEventListener 来监听。<br>一般 open()并监听（监听后执行异步代码）后还会 send()，这才是一个完整的流程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  普通版</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https:www.baidu.com&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 onreadystatechange 部分也可以写成如下：</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Promise版</span></span><br><span class="line"><span class="keyword">const</span> myAjax = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readystate</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statustext</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handle</span><br><span class="line">    client.<span class="title function_">send</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myAjax</span>(<span class="string">&#x27;/url&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">cathch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="XHR-请求的缓存问题的处理方案"><a href="#XHR-请求的缓存问题的处理方案" class="headerlink" title="XHR 请求的缓存问题的处理方案"></a>XHR 请求的缓存问题的处理方案</h3><p>由于浏览器的缓存机制，当我们使用 XMLHttpRequest 发出请求的时候，浏览器会将请求的地址与缓存中的地址进行比较，如果存在相同记录则根据不向服务器发出请求而直接返回与上一次请求相同内容。但我们有时候其实希望每次都请求而不读缓存，解决方法如下：</p>
<h4 id="方法一：URL-加时间戳"><a href="#方法一：URL-加时间戳" class="headerlink" title="方法一：URL 加时间戳"></a>方法一：URL 加时间戳</h4><p>在每次请求的 url 后面加上 ‘?’ or ‘&amp;’ 再加当前时间的字符串或其他类似的不会重复的随机字符串，这样浏览器每次发出的是不同的 url，即会当做不同的请求来处理，而不会从缓存中读取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var oReq = new XMLHttpRequest();</span><br><span class="line">oReq.open(&quot;GET&quot;, url + ((/\?/).test(url) ? &quot;&amp;&quot; : &quot;?&quot;) + (new Date()).getTime());</span><br><span class="line">oReq.send(null);</span><br></pre></td></tr></table></figure>

<h4 id="方法二：HTTP-的缓存策略"><a href="#方法二：HTTP-的缓存策略" class="headerlink" title="方法二：HTTP 的缓存策略"></a>方法二：HTTP 的缓存策略</h4><p>可以把 Cache-ontrol: no-cache + If-Modified-Since: 0。写成 XHR 代码就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest.setRequestHeader(&quot;If-Modified-Since&quot;, &quot;0&quot;);</span><br><span class="line">XMLHttpRequest.setRequestHeader(&quot;Cache-ontrol&quot;, &quot;no-cache&quot;);</span><br><span class="line">XMLHttpRequest.send(null);</span><br></pre></td></tr></table></figure>

<h3 id="实现一个前端缓存模块"><a href="#实现一个前端缓存模块" class="headerlink" title="实现一个前端缓存模块"></a>实现一个前端缓存模块</h3><p>实现一个前端缓存模块，主要用于缓存 xhr 返回的结果，避免多余的网络请求浪费，要求：</p>
<ul>
<li>生命周期为一次页面打开</li>
<li>如果有相同的请求同时并行发起，要求其中一个能挂起并且等待另外一个请求返回并读取该缓存</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>参考了<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30114149/article/details/79419600">封装原生 ajax（缓存+xhr 单例）</a>，有所删改。还没完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">export class XAjaxRequester &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cacheUrl = &#123;&#125; // 缓存</span><br><span class="line">  &#125;</span><br><span class="line">  updataStatus(url, res) &#123;</span><br><span class="line">    this.cacheUrl[url] = res</span><br><span class="line">  &#125;</span><br><span class="line">  get(url, successCallBack) &#123;</span><br><span class="line">    let _self = this</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line">    // 发起请求但是没响应的时候标记为 1</span><br><span class="line">    _self.cacheUrl[url] = 1</span><br><span class="line">    if (!_self.cacheUrl[url]) &#123;</span><br><span class="line">      // 没缓存，正常执行</span><br><span class="line">      xhr.open(&#x27;get&#x27;, url, true)</span><br><span class="line">      xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if (this.readyState === 4) &#123;</span><br><span class="line">          if (</span><br><span class="line">            (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) ||</span><br><span class="line">            this.status === 304</span><br><span class="line">          ) &#123;</span><br><span class="line">            let res = this.responseText</span><br><span class="line">            if (typeof successCallBack === &#x27;function&#x27;) &#123;</span><br><span class="line">              successCallBack(res)</span><br><span class="line">              _self.updataStatus(url, res) // 更新缓存，发布消息给订阅者</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.send(null)</span><br><span class="line">    &#125; else if (_self.cacheUrl[url] === 1) &#123;</span><br><span class="line">      // 有url，但还没缓存资源。整一个发布订阅?</span><br><span class="line">      </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 有缓存，直接拿</span><br><span class="line">      data = _self.cacheUrl[url]</span><br><span class="line">      successCallBack(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  使用demo</span><br><span class="line">let cacheAjax = new XAjaxRequester()</span><br><span class="line">cacheAjax.get(&#x27;/url&#x27;, function(res) &#123;</span><br><span class="line">  /* 成功回调 */</span><br><span class="line">&#125;)</span><br><span class="line">cacheAjax.get(&#x27;/url&#x27;, function(res) &#123;</span><br><span class="line">  /* 成功回调 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="杂的知识点"><a href="#杂的知识点" class="headerlink" title="杂的知识点"></a>杂的知识点</h3><p>在ajax应用中，通常一个页面要同时发送多个请求，如果只有一个XMLHttpRequest对象，前面的请求还未完成，后面的就会把前面的覆盖 掉，如果每次都创建一个新的XMLHttpRequest对象，也会造成浪费。解决的办法就是创建一个XMLHttpRequset的对象池，如果池里有 空闲的对象，则使用此对象，否则将创建一个新的对象。见这篇<a href="ttps://blog.csdn.net/jiedushi/article/details/2531215">远古贴</a>。也有另一种方案是每次用完之后就delete这个变量再让变量 &#x3D; null</p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch 能实现以前 XHR 对象能做的事情。还提供了 全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。但是 fetch<strong>不是 ajax 的进一步封装，而是原生 js</strong>，没有使用 XMLHttpRequest 对象<br>简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">myJson</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myJson)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="fetch-url-init"><a href="#fetch-url-init" class="headerlink" title="fetch(url, init)"></a>fetch(url, init)</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>该方法第一个参数是 url&#x2F;一个 Request 对象，第二个参数（可选）是是用来自定义请求信息的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch">init 对象</a>，该对象有 method，headers（可以是一个 Headers 对象），body（可以是一个 Body 对象），cache 等可选的属性。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一个 Promise，resolve 时回传 Response 对象<br>例外：<br>AbortError：请求 abort 的情况<br>TypeError：请求的 url 有证书问题<br><strong>注意</strong>，最好使用符合<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives">内容安全策略 (CSP)</a>的链接而不是使用直接指向资源地址的方式来进行 Fetch 的请求</p>
<h3 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h3><p>可以通过 Headers() 构造函数来创建一个你自己的 headers 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Content-Length&#x27;</span>: content.<span class="property">length</span>.<span class="title function_">toString</span>(),</span><br><span class="line">  <span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;ProcessThisImmediately&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Headers.prototype.has(key 名)检测是否含有某个 key 名，返回布尔值；Header.prototype.get(key 名)&#x2F;getAll(key 名)获取 key 值</p>
<h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><p>Response 实例是在 fetch() 处理完 promises 之后返回的<br>PS：其实 Headers 和 Response 的 new 下都能接受两个参数，第一个参数是数据体，第二个参数（可选）是 init 对象</p>
<h4 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h4><ul>
<li>Response.status：返回的状态码</li>
<li>Response.statusText：返回的状态信息。eg，200 的时候是 OK</li>
<li>Response.ok：检查 response 的状态是否在 200-299(包括 200,299)这个范围内.该属性返回一个 Boolean 值。eg.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(response.<span class="property">ok</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Network response was not ok.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>请求和响应都能有一个 body 属性包含一个 Body 对象。body 也可以是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">很多种数据类型</a>，eg. <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData">FormData</a></p>
<blockquote>
<p>FormData 提供了一种表示<strong>表单数据</strong>的<strong>键值对</strong>的构造方式。有很多简单实用的方法。见下面例题</p>
</blockquote>
<h4 id="Body-的方法"><a href="#Body-的方法" class="headerlink" title="Body 的方法"></a>Body 的方法</h4><p><strong>这些方法都能被 Request 和 Response 使用，用来转变数据类型</strong></p>
<ul>
<li>Body.json()。接收一个 Response 流，并将其读取完成。它返回一个 <strong>Promise</strong>，Promise 的解析 resolve 结果是将文本体解析为 JSON</li>
<li>Body.formData()。将 Response 对象中的所承载的数据流读取并封装成为一个对象，该方法将返回一个 Promise 对象，该对象将产生一个 FormData 对象</li>
</ul>
<h3 id="兼容性检测"><a href="#兼容性检测" class="headerlink" title="兼容性检测"></a>兼容性检测</h3><p>可以通过检测 Headers, Request, Response 或 fetch()是否在 Window 或 Worker 域中。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.<span class="property">fetch</span>) &#123;</span><br><span class="line">  <span class="comment">// run my fetch request here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// do something with XMLHttpRequest?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>实现一个提交文件不刷新页面的方案，给出关键代码<br>看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">MDN</a>有更多实用例子（eg. 发送带凭据的请求，上传 JSON 数据，上传文件&#x2F;多个文件，检测请求是否成功，自定义请求对象）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;upload&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span> upload <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;upload-btn&#x27;</span>).<span class="property">onclick</span> = <span class="title function_">funcion</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  <span class="keyword">var</span> fileField = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, fileField.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/profile/avatar&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: formData</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Success:&#x27;</span>, response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">WebSocket</a></h2><p>Websocket 是一个全新的、独立的协议，基于 TCP 协议，与 http 协议兼容、却不会融入 http 协议。<br>由于HTTP通信只能由客户端发起，举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。要解决这种场景只能轮询，但是很浪费资源。<br>所以Websocket设计出来的目的就是要取代轮询（每隔一段时间浏览器对服务器发起请求，服务器返回新数据）和 Comet 技术。<br>WebSocket<strong>在单个 TCP 连接上进行全双工通讯的协议</strong>。WebSocket API 可在用户的浏览器和服务器之间进行双向通信。用户可以向服务器发送消息并接收事件驱动的响应，而无需轮询服务器。 它可以<strong>让多个用户连接到同一个实时服务器，并通过 API 进行通信并立即获得响应。</strong><br>它的最大特点就是，【<strong>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</strong>】</p>
<p>它<strong>允许用户和服务器之间的流连接，并允许即时信息交换</strong>。在聊天应用程序的示例中，通过套接字汇集消息，可以实时与一个或多个用户交换，具体取决于谁在服务器上“监听”（连接）。<br>WebSockets 适用于<strong>需要实时更新和即时信息交换</strong>的任何应用程序。一些示例包括但不限于：现场体育更新，股票行情，多人游戏，聊天应用，社交媒体等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket=<span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;/url&quot;</span>)；</span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">//  send() 方法来向服务器发送数据</span></span><br><span class="line">socket.<span class="property">onmessage</span>=<span class="keyword">function</span>(<span class="params">event</span>)&#123;  <span class="comment">// onmessage 事件来接收服务器返回的数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">readyState</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详见MDN及<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰</a></p>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p><strong>同源策略</strong>：当一个资源从与该资源本身所在服务器中不同域、协议、端口请求一个资源时，就是<strong>跨域</strong>。出于安全原因，浏览器限制从脚本内发起的跨域 HTTP 请求。XMLHttpRequest 和 Fetch 的请求都会失败（response.status &#x3D; 0）<br>引入这个同源策略主要是用来防止 CSRF 攻击（没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然同源策略并不能完全阻止 CSRF)）</p>
<p><strong>解决跨域方式</strong>如下：</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。<br>通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。此时使服务器返回的是一段代码就可以了，例如下面的代码服务端可以返回一段 <code>jsonp(&#39;I am data&#39;)</code> 去调用本来就写在<code>&lt;script&gt;</code>中的函数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点是操作方便，兼容性好<br>缺点：</p>
<ul>
<li>只限于 get 请求</li>
<li>url 限制了参数大小</li>
<li>错误处理机制不好，调用失败的时候不会返回各种 HTTP 状态码</li>
<li>安全性。假如提供 jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的，结果是所有调用这个 jsonp 的网站都会存在漏洞，于是无法把危险控制在用一个域名下</li>
</ul>
<h3 id="回调函数名同名的解决方案"><a href="#回调函数名同名的解决方案" class="headerlink" title="回调函数名同名的解决方案"></a>回调函数名同名的解决方案</h3><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, jsonpCallbackName, success</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.<span class="property">src</span> = url</span><br><span class="line">  script.<span class="property">async</span> = <span class="literal">true</span></span><br><span class="line">  script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">  <span class="variable language_">window</span>[jsonpCallbackName] = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    success &amp;&amp; <span class="title function_">success</span>(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonp</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;callback&#x27;</span>, <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">CORS</a></h2><ul>
<li>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</li>
<li>浏览器会自动进行 CORS 通信，实现 CORS 通信的<strong>关键是后端</strong>。只要后端实现了 CORS，就实现了跨域。</li>
<li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</li>
</ul>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求和预检请求</strong>。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>有一些条件，eg. method 是 GET, HEAD, POST。详情见 MDN<br>简单请求的时候，服务看请求的 Orgin 字段（请求网站的 URL），看自己的 Access-Control-Allow-Origin 字段（值为*，表示该资源可以被任意外域访问，也可以是某个具体域名），比较两者是否相符决定定要不要给资源了</p>
<h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），<strong>浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务器是否允许该跨域请求</strong></p>
<p><strong>服务器确认允许之后，才发起实际的 HTTP 请求</strong>。 在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 cookie 和 HTTP 认证相关数据）</p>
<p><strong>如果发起请求时设置 WithCredentials 标志设置为 true，从而向服务器发送 cookie</strong>，但是如果服务器的响应中未携带<strong>Access-Control-Allow-Credentials: true，浏览器将不会把响应内容返回给请求的发送者</strong></p>
<h3 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h3><p>Fetch 与 CORS 的一个有趣的特性是，可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证<br>服务器不得设置 Access-Control-Allow-Origin 的值为*，必须是某个具体的域名。<br>注意，简单 GET 请求不会被预检；如果此类带有身份凭证请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页</p>
<h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。<br>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;http://test.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>()</span><br><span class="line">mc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.<span class="property">origin</span> || event.<span class="property">originalEvent</span>.<span class="property">origin</span></span><br><span class="line">  <span class="keyword">if</span> (origin === <span class="string">&#x27;http://test.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;验证通过&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参考资料<br>W3School<br>MDN<br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanyueff/p/7771075.html">JSONP 原理及使用</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/31/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92&%E8%B7%A8%E5%9F%9F/" data-id="clmniym7m0039bb8787trc6ti" data-title="前后端交互&amp;跨域" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2019-10-29T13:30:21.000Z" itemprop="datePublished">2019-10-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><ul>
<li>接收到 HTML 文件，转化为 DOM 树（字节数据&#x3D;&gt;字符串&#x3D;&gt;Token（最小单位代码）&#x3D;&gt;Node&#x3D;&gt;DOM）<br>当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件（即遇到 script 标签会暂停 DOM 的构建）</li>
<li>将 CSS 文件转换为 CSSOM 树（字节数据&#x3D;&gt;字符串&#x3D;&gt;Token（最小单位代码）&#x3D;&gt;Node&#x3D;&gt;CSSOM）<br>在这一过程中，浏览器会确定下每一个节点的<strong>样式</strong>到底是什么，并且这一过程其实是<strong>很消耗资源</strong>的<br>eg. span 和 div &gt; a &gt; span，后者的解析成本会更高<br>我们应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong></li>
<li>将 DOM 树和 CSSOM 树组成成渲染树（Render Tree）<br>渲染树只会包括<strong>需要显示的</strong>节点和这些节点的样式信息，如果某个节点是<code>display: none</code>的，那么就不会在渲染树中显示</li>
<li>根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上</li>
</ul>
<h3 id="什么情况下会阻塞渲染"><a href="#什么情况下会阻塞渲染" class="headerlink" title="什么情况下会阻塞渲染"></a>什么情况下会阻塞渲染</h3><ul>
<li>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染<br>想渲染的越快，越应该<strong>降低一开始需要渲染的文件大小</strong>，并且做到<strong>HTML 扁平层级，优化 CSS 选择器</strong></li>
<li>然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始<br>所以，如果想首屏渲染的越快，就越<strong>不应该在首屏就加载 JS 文件</strong>，这也是都建议将 script 标签放在 body 标签底部的原因</li>
</ul>
<h3 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h3><p>见 CSS 知识点</p>
<h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><ul>
<li>缓存可以说是性能优化中<strong>简单高效</strong>的一种优化方式了，它可以<strong>显著减少网络传输所带来的损耗</strong>。</li>
<li>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</li>
</ul>
<h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。顺序是：</p>
<ol>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
<li>都找不到，就发起网络请求获取数据</li>
</ol>
<h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><ul>
<li>service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li>
<li>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</li>
</ul>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><ul>
<li>Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li>
<li>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</li>
</ul>
<blockquote>
<p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p>
</blockquote>
<ul>
<li>先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JS、HTML、CSS、图片等等</li>
<li>当然，我通过一些实践和猜测也得出了一些结论：<br>对于大文件来说，大概率是不存储在内存中的，反之优先当前系统内存使用率高的话，文件优先存储进硬盘</li>
</ul>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><ul>
<li>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</li>
<li>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据</li>
</ul>
<h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>Push Cache 是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放</p>
<h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><ul>
<li>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</li>
<li>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来讨论缓存策略这部分的内容</li>
</ul>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><blockquote>
<p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的</p>
</blockquote>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200<br><strong>Expires</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>: <span class="title class_">Wed</span>, <span class="number">22</span> <span class="title class_">Oct</span> <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Expires 是 HTTP&#x2F;1 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>
</blockquote>
<p><strong>Cache-control</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cache</span>-<span class="attr">control</span>: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Cache-Control 出现于 HTTP&#x2F;1.1，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求。<br>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令</p>
</blockquote>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><ul>
<li>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag</li>
<li>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期</li>
</ul>
<p><strong>Last-Modified 和 If-Modified-Since</strong></p>
<blockquote>
<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码</p>
</blockquote>
<p>但是 Last-Modified 存在一些弊端：</p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改</li>
<li>Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>
</ul>
<p><strong>ETag 和 If-None-Match</strong></p>
<blockquote>
<p>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</p>
</blockquote>
<h3 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h3><h4 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h4><p>对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>
<h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><blockquote>
<p>这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短</p>
</blockquote>
<p>一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 Cache-Control: max-age&#x3D;31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存</p>
<h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><h3 id="浏览器的存储方式"><a href="#浏览器的存储方式" class="headerlink" title="浏览器的存储方式"></a>浏览器的存储方式</h3><p>cookie，localStorage，sessionStorage，indexDB</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">cookie</th>
<th align="center">localStorage</th>
<th align="center">sessionStorage</th>
<th align="center">indexDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据生命周期</td>
<td align="center">一般由服务器生成，可以设置过期时间</td>
<td align="center">除非被清理，否则一直存在</td>
<td align="center">页面关闭就清理</td>
<td align="center">除非被清理，否则一直存在</td>
</tr>
<tr>
<td align="center">数据存储大小</td>
<td align="center">4K</td>
<td align="center">5M</td>
<td align="center">5M</td>
<td align="center">无限</td>
</tr>
<tr>
<td align="center">与服务端通信</td>
<td align="center">每次都会携带在 header 中，对于请求性能影响</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
<td align="center">不参与</td>
</tr>
</tbody></table>
<p>结论：如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储</p>
<h3 id="Service-Worker-1"><a href="#Service-Worker-1" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>（可以理解为是 Web Worker 的一种），一般用来实现缓存功能。<br>所以也和 Web Worker 一样不能访问 DOM，不能用 localStorage, XMLHttpRequest。<br>使用 Service Worker 的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ul>
<li>先注册 Service Worker</li>
<li>监听到 install 事件以后就可以缓存需要的文件</li>
<li>下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如在index.js里注册一个Service Worker</span></span><br><span class="line"><span class="keyword">if</span> (navigator.<span class="property">serviceWorker</span>) &#123;</span><br><span class="line">  navigator.<span class="property">serviceWorker</span></span><br><span class="line">    .<span class="title function_">register</span>(<span class="string">&quot;xx.js&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">registration</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;注册失败&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.js子线程文件</span></span><br><span class="line"><span class="comment">//监听install事件，注册后会缓存所指定的文件。</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;install&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">wiatUntil</span>(</span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="string">&quot;my-cache&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">cache</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">addAll</span>([<span class="string">&quot;./index.html&quot;</span>, <span class="string">&quot;./index.js&quot;</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听fetch事件进行请求拦截，如果缓存中已经有要请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;fetch&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">respondWith</span>(</span><br><span class="line">    cache.<span class="title function_">match</span>(e.<span class="property">request</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="comment">//1. 如果请求的资源已被缓存，则直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//2. 没有，则发起请求并缓存结果</span></span><br><span class="line">      <span class="keyword">let</span> requestClone = e.<span class="property">request</span>.<span class="title function_">clone</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(requestClone).<span class="title function_">then</span>(<span class="function"><span class="params">netRes</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!netRes || netRes.<span class="property">status</span> !== <span class="number">200</span>) <span class="keyword">return</span> netRes;</span><br><span class="line">        <span class="keyword">let</span> responseClone = netRes.<span class="title function_">clone</span>();</span><br><span class="line">        caches</span><br><span class="line">          .<span class="title function_">open</span>(cacheName)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function"><span class="params">cache</span> =&gt;</span> cache.<span class="title function_">put</span>(requestClone, responseClone));</span><br><span class="line">        <span class="keyword">return</span> netRes;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>参考资料<br>掘金小册-前端面试之道-浏览器渲染原理<br>极客时间-浏览器工作原理与实践<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bill-shooting/archive/2018/07/21/9347441.html">浏览器缓存和 Service Worker</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8/" data-id="clmniym8a0051bb878c7i5g49" data-title="浏览器" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web安全" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/27/Web%E5%AE%89%E5%85%A8/" class="article-date">
  <time class="dt-published" datetime="2019-10-27T13:30:21.000Z" itemprop="datePublished">2019-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/27/Web%E5%AE%89%E5%85%A8/">Web安全</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>跨站脚本攻击</strong>(Cross Site Scripting)，缩写为XSS（避免和CSS混淆就没缩写成CSS）。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的</p>
<h3 id="XSS攻击注入点"><a href="#XSS攻击注入点" class="headerlink" title="XSS攻击注入点"></a>XSS攻击注入点</h3><h4 id="HTML节点内容"><a href="#HTML节点内容" class="headerlink" title="HTML节点内容"></a>HTML节点内容</h4><p>节点中包含用户输入的内容。例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>#&#123;content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// content能被输入成包含一段脚本</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如，这个img的src的属性来自用户的输入或者是数据库存储的用户之前提交的</span></span><br><span class="line">&lt;img src=<span class="string">&quot;#&#123;img&#125;&quot;</span>/&gt;</span><br><span class="line"><span class="comment">// 如果用户输入的时候输入了 1&quot; onerror=&quot;alert(1) ，则能被执行成</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert(1)&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><p>跟之前的原理一样，某个属性是来自于用户的输入，用户可以通过输入引号的方式增加一些代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;#&#123;data&#125;&quot;</span></span><br><span class="line"><span class="comment">//  能被用户输入写成</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;hello&quot;</span>;<span class="title function_">alert</span>(<span class="number">1</span>);<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h4><p>写邮件的时候我们能定义字体的各种格式，提交的时候其实就是提交这一段的html。提交这么多一段html是有XSS攻击风险的。这种情况要用白名单防御方法</p>
<h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><ul>
<li><strong>反射型</strong>： 通过<strong>修改 URL 参数</strong>的方式加入攻击代码，诱导用户访问链接从而进行攻击<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt;</span></span><br><span class="line">&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;   </span><br></pre></td></tr></table></figure>
上述 URL 输入可能会将 HTML 改为<code>&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</code> ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击<br>还有另一个例子见<a target="_blank" rel="noopener" href="https://blog.csdn.net/ganyingxie123456/article/details/70230486">Web安全之XSS攻防</a></li>
<li><strong>存储型</strong>: 攻击的代码被服务端写入进数据库中。比如在一些论坛的评论中，写script标签加alert语句，如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到</li>
</ul>
<h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><h4 id="转义字符（普遍）"><a href="#转义字符（普遍）" class="headerlink" title="转义字符（普遍）"></a>转义字符（普遍）</h4><p>转义输入输出的内容，对于引号，尖括号，斜杠进行转义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">escape</span>(<span class="params">str</span>) &#123;</span><br><span class="line">	str = str.<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>);</span><br><span class="line">	str = str.<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>);</span><br><span class="line">	str = str.<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">	str = str.<span class="title function_">replace</span>(<span class="regexp">/&quot;/g</span>, <span class="string">&quot;&amp;quto;&quot;</span>);</span><br><span class="line">	str = str.<span class="title function_">replace</span>(<span class="regexp">/&#x27;/g</span>, <span class="string">&quot;&amp;##39;&quot;</span>);</span><br><span class="line">	str = str.<span class="title function_">replace</span>(<span class="regexp">/`/g</span>, <span class="string">&quot;&amp;##96;&quot;</span>);</span><br><span class="line">    str = str.<span class="title function_">replace</span>(<span class="regexp">/\//g</span>, <span class="string">&quot;&amp;##x2F;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过转义可以将攻击代码<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>变成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;##x2F;script&amp;gt;</span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="CSP白名单"><a href="#CSP白名单" class="headerlink" title="CSP白名单"></a>CSP白名单</h4><p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，明确告诉浏览器哪些外部资源可以加载和执行。<br>通过两种方式来开启 CSP：</p>
<ul>
<li>设置 HTTP Header 中的 Content-Security-Policy: ‘某某策略’<blockquote>
<p>写法以多个键值对的形式存在，键和值用空格隔开，不同对用分号分开。键的类型有限制全局default-src，资源类型的connect-src、mainfest-src、img-src、font-src、media-src、style-src、frame-src、script-src… ； 值可以写成 * ，或某个url</p>
</blockquote>
</li>
<li>设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;某某策略&quot;&gt;</code></li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="概念及攻击原理"><a href="#概念及攻击原理" class="headerlink" title="概念及攻击原理"></a>概念及攻击原理</h3><p><strong>跨站请求伪造</strong>（Cross-site request forgery）,<br>CSRF攻击的本质在于<strong>利用用户的身份，执行非本意的操作</strong>。重点在于：<strong>CSRF的请求是跨域且伪造的</strong><br>跨站请求伪造的攻击是攻击者通过一些技术手段欺骗用户的浏览器去访问用户曾经认证过的网站并执行一些操作（如发送邮件、发消息、甚至财产操作如转账和购买商品等。攻击者的网站借用用户身份向目标网站发送一些请求）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web登录身份认证的一个漏洞：<strong>简单的身份认证只能保证请求来自用户的浏览器，但不能识别请求是用户自愿发出的</strong></p>
<blockquote>
<p>假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;http://www.domain.com/xxx?comment=&#x27;attack&#x27;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h3><p>可以遵循以下几种规则：</p>
<ol>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie</li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 Token</li>
</ol>
<h4 id="对Cookie设置SameSite属性"><a href="#对Cookie设置SameSite属性" class="headerlink" title="对Cookie设置SameSite属性"></a>对Cookie设置SameSite属性</h4><p>该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容</p>
<h4 id="验证Referer"><a href="#验证Referer" class="headerlink" title="验证Referer"></a>验证Referer</h4><p>可以通过验证 Referer 来判断该请求是否为第三方网站发起的</p>
<h4 id="利用Token"><a href="#利用Token" class="headerlink" title="利用Token"></a>利用Token</h4><p>服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的安全策略"><a href="#Cookie的安全策略" class="headerlink" title="Cookie的安全策略"></a>Cookie的安全策略</h3><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td>
</tr>
<tr>
<td align="center">http-only</td>
<td align="center">不能通过 JS 访问 Cookie，减少 XSS 攻击</td>
</tr>
<tr>
<td align="center">secure</td>
<td align="center">只能在协议为 HTTPS 的请求中携带</td>
</tr>
<tr>
<td align="center">same-site</td>
<td align="center">规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td>
</tr>
</tbody></table>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><p><strong>设置HTTP头：X-FRAME-OPTIONS</strong><br>这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击<br>该响应头有三个值可选，分别是</p>
<ul>
<li>DENY，表示页面不允许通过 iframe 的方式展示</li>
<li>SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示</li>
<li>ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示</li>
</ul>
<h3 id="JS-防御"><a href="#JS-防御" class="headerlink" title="JS 防御"></a>JS 防御</h3><p>对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了<br>当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">id</span>=<span class="string">&quot;click-jack&quot;</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-tag">html</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">display</span>: none <span class="meta">!important</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span> (self == top) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;click-jack&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(style)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      top.<span class="property">location</span> = self.<span class="property">location</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息</p>
<h3 id="如何防范-1"><a href="#如何防范-1" class="headerlink" title="如何防范"></a>如何防范</h3><p>防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/104.html">慕课网-Web前后端漏洞分析与防御</a><br>《白帽子讲Web安全》<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ganyingxie123456/article/details/70230486">Web安全之XSS攻防</a><br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/27/Web%E5%AE%89%E5%85%A8/" data-id="clmniym7d002fbb874cgw7ob8" data-title="Web安全" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2019-10-26T14:30:21.000Z" itemprop="datePublished">2019-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>PS：一般单例模式和观察者模式问的最多。一般能说出5个设计模式就可以</p>
<h2 id="面向对象的JS"><a href="#面向对象的JS" class="headerlink" title="面向对象的JS"></a>面向对象的JS</h2><h3 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h3><p>静态类型语言在编译时便确定变量的类型，而动态类型语言要到程序运行的时候，待变量被赋予某个值之后，才会有某种类型。JS是典型的动态类型语言。同时JS也是弱类型语言，Java是强类型语言<br>强类型语言是一旦变量的类型被确定，就不能转化的语言。实际上所谓的貌似转化，都是通过中间变量来达到，原本的变量的类型肯定是没有变化的<br>弱类型语言则反之，一个变量的类型是由其应用上下文确定的。比如语言直接支持字符串和整数可以直接用 + 号搞定。当然，在支持运算符重载的强类型语言中也能通过外部实现的方式在形式上做到这一点，不过这个是完全不一样的内涵<br>通常的说，java&#x2F;python都算是强类型的，而VB&#x2F;Perl&#x2F;C都是弱类型的<br><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E5%9E%8B.png"></p>
<h3 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>ES6实现继承很方便了，不解释</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>数据的权限和保密（eg. 变量 or 对象）<br>封装的三个访问权限关键字：public 完全开放，protected 对子类开放，private 对自己开放。对三个关键字可以对是属性的一种描述。<br>但JS没有着这种关键字（有些语言有，eg. TypeScript，Java），只能通过作用域模拟出public ，private 两种封装性。<br><strong>封装的作用</strong>：</p>
<ul>
<li>减少耦合，不该外露的不外露</li>
<li>利于数据、接口的权限管理</li>
<li>ES6目前不支持，<strong>一般认为 _ 开头的属性是private</strong></li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>同一操作作用于不同的对象上，可以产生不同的解释和不同的执行结果。（eg. 继承自同一父后又自己写方法，这是两个继承自同一父的两个子类的同个方法可能执行结果不同）<br>作用：保持子类的开放性和灵活性；面向接口编程</p>
<h3 id="为何使用面向对象"><a href="#为何使用面向对象" class="headerlink" title="为何使用面向对象"></a>为何使用面向对象</h3><ul>
<li>因为计算机的程序执行：顺序、判断、循环 ——实现了结构化；</li>
<li>而使用面向对象编程能——数据结构化； </li>
<li>对于计算机，结构化的才是最简单的，所以编程应该 简单&amp;抽象。</li>
</ul>
<p>PS：jQuery其实是一个类</p>
<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>画UML类图帮助理解设计模式，也能帮助面对对象编程。可以去<a href="www.processon.com">processon</a>画<br><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/UML.png"></p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="何为设计"><a href="#何为设计" class="headerlink" title="何为设计"></a>何为设计</h3><p>按照哪一种思路或者标准来实现功能。功能相同，可以有不同的设计方案实现。伴随着需求增加，设计的作用才能体现出来</p>
<h3 id="《UNIX-LINUX设计哲学》"><a href="#《UNIX-LINUX设计哲学》" class="headerlink" title="《UNIX&#x2F;LINUX设计哲学》"></a>《UNIX&#x2F;LINUX设计哲学》</h3><ul>
<li>准则1：小即是美</li>
<li>准则2：让每个程序制作好一件事</li>
<li>准则3：快速建立原型（满足最基本需求）</li>
<li>准则4：舍弃高效率而取可移植性（可通用性）</li>
<li>准则5：采用纯文本来存储数据</li>
<li>准则6：充分利用软件的杠杆效应（软件复用）</li>
<li>准则7：使用shell脚本来提高杠杆效应和可移植性</li>
<li>准则8：避免强制性的用户界面</li>
<li>准则9：让每个程序成为过滤器</li>
<li>小准则<ul>
<li>允许用户定制环境</li>
<li>尽量使操作系统内核小而轻量化</li>
<li>使用小写字母并尽量简短</li>
<li>沉默是金</li>
<li>各部分之和大于整体</li>
<li>寻求90%的解决方案</li>
</ul>
</li>
</ul>
<h3 id="SOLID五大设计原则"><a href="#SOLID五大设计原则" class="headerlink" title="SOLID五大设计原则"></a>SOLID五大设计原则</h3><ul>
<li><strong>S：单一职责原则</strong>。每个程序（或函数&#x2F;函数的一部分）只做好一件事，如果功能过于复杂就拆分，每个部分保持独立</li>
<li><strong>O：开放封闭原则</strong>。对扩展开放，对修改封闭；增加需求时，扩展新代码，而非修改原来的代码。是软件设计的终极目标。</li>
<li>L：*李氏置换原则。子类能覆盖父类；父类能出现的地方子类都能出现；JS用的少（弱类型&amp;继承使用较少）</li>
<li>I：*接口独立原则。保持接口的单一独立，避免出现“胖接口”；JS中没有接口（typescript例外），使用较少</li>
<li>D：*依赖导致原则。面向接口编程，依赖于抽象而不依赖于具体；使用方只关注接口而不关注具体类的实现。JS使用少</li>
</ul>
<h3 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h3><ul>
<li>创建型<ul>
<li>工厂模式</li>
<li>单例模式</li>
<li>原型模式</li>
</ul>
</li>
<li>结构性<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>*桥接模式</li>
<li>*组合模式</li>
<li>*享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>*策略模式</li>
<li>*模板方法模式</li>
<li>观察者模式（发布-订阅）</li>
<li>迭代器模式</li>
<li>*职责连模式</li>
<li>*命令模式</li>
<li>*备忘录模式</li>
<li>状态模式</li>
<li>*访问者模式</li>
<li>*中介者模式</li>
<li>*解释器模式</li>
</ul>
</li>
</ul>
<p>学习目的：</p>
<ul>
<li>明白每个设计的道理和用意</li>
<li>通过经典应用体会它的真正的使用场景</li>
<li><strong>自己编码时多思考，尽量模仿</strong></li>
</ul>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p>打车时，可以打专车（每公里2元）或快车（1元）。任何车都有车牌号和名称。行程开始时，显示车辆信息；行程结束时，显示打车金额（假定行程5公里）。要求画出UML类图和用ES6语法写出该示例。<strong>先画UML类图再写代码</strong><br><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-8.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">num, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> = num</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FastCar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">num, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(num, name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialCar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">num, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(num, name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trip</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">car, long</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span> = car</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">long</span> = long</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`行程开始，名称：<span class="subst">$&#123;<span class="variable language_">this</span>.car.name&#125;</span>，车牌号：<span class="subst">$&#123;<span class="variable language_">this</span>.car.num&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">end</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`行程结束，价格：<span class="subst">$&#123;<span class="variable language_">this</span>.car.price * <span class="variable language_">this</span>.long&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">SpecialCar</span>(<span class="number">100</span>, <span class="string">&#x27;广州专车&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> trip = <span class="keyword">new</span> <span class="title class_">Trip</span>(car, <span class="number">5</span>)</span><br><span class="line">trip.<span class="title function_">start</span>()</span><br><span class="line">trip.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure>
<h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>某停车场，分为3层，每层100个车位，；每个车位都能监控到车辆的驶入和离开。车辆进入前，显示每层的空余车辆数；车辆进入时，摄像头可识别车牌号和时间；车辆出来时，出口显示器显示车牌号和停车时长。画UML类图<br><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-11.png"></p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>将new操作单独封装（初始化实例）；遇到new时，就要考虑是否用工厂模式<br>eg. 我们去饭店点了个一个菜，后面厨师会做实例化这个菜的各种复杂操作，但是提供给我们的却只有“点菜”这个接口</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>隐藏了创建实例的复杂度，只需要提供一个借口，简单清晰</p>
<h3 id="UML类图及实现代码"><a href="#UML类图及实现代码" class="headerlink" title="UML类图及实现代码"></a>UML类图及实现代码</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;init&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;fn1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line">  <span class="title function_">create</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> creator = <span class="keyword">new</span> <span class="title class_">Creator</span>()</span><br><span class="line"><span class="keyword">let</span> p = creator.<span class="title function_">create</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">p.<span class="title function_">init</span>()</span><br></pre></td></tr></table></figure>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>React.createElement</li>
<li>vue异步组件的创建<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponent</span> (</span><br><span class="line">  <span class="title class_">Ctor</span>: <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span> | <span class="keyword">void</span>,</span><br><span class="line">  <span class="attr">data</span>: ?<span class="title class_">VNodeData</span>,</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; | <span class="keyword">void</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逻辑处理...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上述代码中，我们可以看到我们只需要调用 createComponent 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能</p>
</blockquote>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>系统中被唯一使用，一个类只有一个实例<br>eg. 淘宝页面中，登录框、购物车只会有一个；全局缓存，全局状态管理等这些只需要一个对象，就可以使用单例函数</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*说明：单例模式要用到pravite关键字，但JS没有。我们只需要用一个变量确保实例只创建一次就行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleObject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SingleObject</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instnce</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instnce) &#123;</span><br><span class="line">      instnce = <span class="keyword">new</span> <span class="title class_">SingleObject</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instnce</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 下面这种把 instance 写成类的静态属性的方式也可以，更和TS中的写法一致</span></span><br><span class="line"><span class="comment">// 有些库的单例写法会把 instane 挂在 global 中 ，global.instance = xxx。当然这种写法建议用一个复杂一点的变量名，eg: CG_I18N_EMITER</span></span><br><span class="line"><span class="title class_">SingleObject</span>.<span class="property">instnce</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="title class_">SingleObject</span>.<span class="property">getInstance</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instnce</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instnce</span> = <span class="keyword">new</span> <span class="title class_">SingleObject</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instnce</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  一定要用自定义的getInstance方法来创建实例，不能用new</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="title class_">SingleObject</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">SingleObject</span>.<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//  用了new</span></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="keyword">new</span> <span class="title class_">SingleObject</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj3) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul>
<li>jQuery只有一个$</li>
<li>模拟登录框</li>
<li>Vuex源码，通过一个外部变量来控制只安装一次 Vuex<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Vue</span> <span class="comment">// bind on install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">install</span> (_Vue) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Vue</span> &amp;&amp; _Vue === <span class="title class_">Vue</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果发现 Vue 有值，就不重新创建实例了</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Vue</span> = _Vue</span><br><span class="line">  <span class="title function_">applyMixin</span>(<span class="title class_">Vue</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>旧接口格式和使用者不兼容，中间加一个适配转换接口<br>eg. 电源插口转换器；</p>
<h3 id="UML类图及实现代码-1"><a href="#UML类图及实现代码-1" class="headerlink" title="UML类图及实现代码"></a>UML类图及实现代码</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="title function_">specificRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;德国标准插头&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adaptee</span> = <span class="keyword">new</span> <span class="title class_">Adaptee</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> info = <span class="variable language_">this</span>.<span class="property">adaptee</span>.<span class="title function_">specificRequest</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;info&#125;</span>的转换器——中国标准插头`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> <span class="title class_">Target</span>()</span><br><span class="line"><span class="keyword">let</span> res = target.<span class="title function_">request</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">//  德国标准插头的转换器——中国标准插头</span></span><br></pre></td></tr></table></figure>
<h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ul>
<li>封装旧接口</li>
<li>Vue的计算属性<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>信息列表<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>信息：&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>逆序信息：&#123;&#123;newMessage&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">newMessage</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>不需要改变对象原有结构和功能（接口）的前提下，为对象添加新功能<br>eg.  就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能</p>
<h3 id="UML类图及实现代码-2"><a href="#UML类图及实现代码-2" class="headerlink" title="UML类图及实现代码"></a>UML类图及实现代码</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;画一个圆形&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">circle</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">circle</span> = circle</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">circle</span>.<span class="title function_">draw</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setRedBorder</span>(circle) <span class="comment">// 这里要传递“原来的功能”为参数，记得是“装饰”</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setRedBorder</span>(<span class="params">circle</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置红色边框&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>()</span><br><span class="line">circle.<span class="title function_">draw</span>() <span class="comment">// 画一个圆形</span></span><br><span class="line"><span class="keyword">let</span> dec = <span class="keyword">new</span> <span class="title class_">Decorator</span>(circle)</span><br><span class="line">dec.<span class="title function_">draw</span>()  <span class="comment">// 画一个圆形  // 设置红色边框</span></span><br></pre></td></tr></table></figure>
<h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>ES7装饰器语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@testDec <span class="comment">// 用这个@的语法对下面的类做装饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testDec</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  target.<span class="property">isDec</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Demo</span>.<span class="property">isDec</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  传递参数的情况</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testDec</span>(<span class="params">isDec</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    target.<span class="property">isDec</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@testDec</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Demo</span>.<span class="property">isDec</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>使用者无权访问目标对象，可以通过中间加代理的方法，通过代理做授权和控制<br>eg. 代购；明星和经纪人；事件代理</p>
<h3 id="UML类图及实现代码-3"><a href="#UML类图及实现代码-3" class="headerlink" title="UML类图及实现代码"></a>UML类图及实现代码</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealImg</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">filename</span> = filename</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">display</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`展示<span class="subst">$&#123;<span class="variable language_">this</span>.filename&#125;</span>图片`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyImg</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">realimg</span> = <span class="keyword">new</span> <span class="title class_">RealImg</span>(filename)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">display</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">realimg</span>.<span class="title function_">display</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyImg = <span class="keyword">new</span> <span class="title class_">ProxyImg</span>(<span class="string">&#x27;1.png&#x27;</span>)</span><br><span class="line">proxyImg.<span class="title function_">display</span>() <span class="comment">// 展示1.png图片</span></span><br></pre></td></tr></table></figure>
<h3 id="代理模式-vs-装饰器模式"><a href="#代理模式-vs-装饰器模式" class="headerlink" title="代理模式 vs 装饰器模式"></a>代理模式 vs 装饰器模式</h3><p>装饰器模式：扩展功能，原有功能不变且可以直接使用<br>代理模式：显示原有功能，但是经过限制或者阉割之后的（ES6的proxy也是如此）</p>
<h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><ul>
<li>ES6 proxy</li>
<li>网页事件代理<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ul&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为存在太多的 li，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点</p>
</blockquote>
</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知，即 发布 &amp; 订阅（发布给订阅者）<br>eg. 肯德基很多个人点餐完成，每准备好一个顾客的餐那个顾客就会收到通知；双11某商品降价通知</p>
<h3 id="UML类图及实现代码-4"><a href="#UML类图及实现代码-4" class="headerlink" title="UML类图及实现代码"></a>UML类图及实现代码</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题，保存状态，状态变化之后触发所有观察者对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  <span class="title function_">addOvservers</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifyAllObservers</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notifyAllObservers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, subject</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span> = subject</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span>.<span class="title function_">addOvservers</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.subject.name&#125;</span> updata, now state is <span class="subst">$&#123;<span class="variable language_">this</span>.subject.getState()&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Subject</span>(<span class="string">&#x27;subject1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;o1&#x27;</span>, s)</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;o2&#x27;</span>, s)</span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">2</span>) <span class="comment">// subject1 updata, now state is 2  // subject1 updata, now state is 2</span></span><br></pre></td></tr></table></figure>
<h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><ul>
<li>网页的addEventListener</li>
<li>Vue的双向数据绑定、父子传值$emit、生命周期触发、Vue的watch</li>
<li>Promise的 .then（监听promise的状态变化）</li>
<li>Node.js自定义事件EventEmitter（这个其实和Vue的$emit是一样的），http（其实底也是EventEmitter）</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>为子系统中的一组接口提供了一个高层接口，使用者使用这个高层接口</p>
<h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h3><p>实现一个兼容多种浏览器的添加事件方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addEvent</span>(<span class="params">elm, evType, fn, useCapture</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elm.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    elm.<span class="title function_">addEventListener</span>(evType, fn, useCapture)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elm.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r = elm.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + evType, fn)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    elm[<span class="string">&quot;on&quot;</span> + evType] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于不同的浏览器，添加事件的方式可能会存在兼容问题。如果每次都需要去这样写一遍的话肯定是不能接受的，所以我们将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 addEvent 即可</p>
</blockquote>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>顺序遍历有序集合（Array，NodeList，Set等，对象不算，不是有序），使用者无需知道集合的内部结构（被封装了，不知道它是数组还是NodeList还是啥的，也不知道它的长度）。（所以 Array.prototype.forEach(), for循环 这些都不算迭代模式）</p>
<h3 id="UML类图及实现代码-5"><a href="#UML类图及实现代码-5" class="headerlink" title="UML类图及实现代码"></a>UML类图及实现代码</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">conatiner</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = conatiner.<span class="property">list</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">index</span>++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hasNext</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">index</span> &gt;= <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">list</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = list</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="keyword">new</span> <span class="title class_">Container</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="keyword">let</span> iterator = container.<span class="title function_">getIterator</span>()</span><br><span class="line"><span class="keyword">while</span> (iterator.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h3><ul>
<li>jQuery each</li>
<li>ES6 Iterator</li>
</ul>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>一个对象有状态变化，每次状态变化都会触发一个逻辑，当状态有很多种的时候不能总是用 if…else 来控制<br>eg. 交通信号灯不同颜色的变化</p>
<h3 id="UML类图及实现代码-6"><a href="#UML类图及实现代码-6" class="headerlink" title="UML类图及实现代码"></a>UML类图及实现代码</h3><p><img src="/img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态（红灯、绿灯、黄灯）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handle</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`turn to <span class="subst">$&#123;<span class="variable language_">this</span>.color&#125;</span> light`</span>)</span><br><span class="line">    context.<span class="title function_">setState</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Context</span>()</span><br><span class="line"><span class="keyword">let</span> green = <span class="keyword">new</span> <span class="title class_">State</span>(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="keyword">new</span> <span class="title class_">State</span>(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> red = <span class="keyword">new</span> <span class="title class_">State</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment">// 绿灯亮了</span></span><br><span class="line">green.<span class="title function_">handle</span>(context)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="title function_">getState</span>()) <span class="comment">// 打印状态</span></span><br><span class="line"><span class="comment">// 黄灯亮了</span></span><br><span class="line">yellow.<span class="title function_">handle</span>(context)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="title function_">getState</span>()) <span class="comment">// 打印状态</span></span><br></pre></td></tr></table></figure>
<h3 id="场景-8"><a href="#场景-8" class="headerlink" title="场景"></a>场景</h3><ul>
<li>有限状态机</li>
<li>写一个简单的Promise</li>
</ul>
<h2 id="一些很不错的博客贴-小测"><a href="#一些很不错的博客贴-小测" class="headerlink" title="一些很不错的博客贴 &amp;&amp; 小测"></a>一些很不错的博客贴 &amp;&amp; 小测</h2><h3 id="如何消除层出不穷的-switch…case-————-开放封闭原则"><a href="#如何消除层出不穷的-switch…case-————-开放封闭原则" class="headerlink" title="如何消除层出不穷的 switch…case ———— 开放封闭原则"></a>如何消除层出不穷的 switch…case ———— 开放封闭原则</h3><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/7830562df8028398eec1b6ee3">核心稳定、易扩展——开放关闭原则</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FHbHhjtfJOc2NPfge6xw2Q">备用链接</a></p>
<h3 id="React设计模式与最佳实践"><a href="#React设计模式与最佳实践" class="headerlink" title="React设计模式与最佳实践"></a>React设计模式与最佳实践</h3><p>比较有历史的一本<a target="_blank" rel="noopener" href="https://juejin.im/book/6844733754326401038">小册</a></p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/255.html">慕课网-Javascript 设计模式系统讲解与应用</a><br><a target="_blank" rel="noopener" href="http://blog.poetries.top/FE-Interview-Questions/excellent/#_34-6-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F">poetries</a><br>《JavaScript设计模式与开发实践》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clmniym8m006dbb879tqs1geo" data-title="设计模式" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web Component" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/23/Web%20Component/" class="article-date">
  <time class="dt-published" datetime="2019-10-23T15:50:21.000Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/23/Web%20Component/">Web Component</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/08/web_components.html">http://www.ruanyifeng.com/blog/2019/08/web_components.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/23/Web%20Component/" data-id="clmniym7b0026bb87hkrtfelw" data-title="Web Component" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-框架入门及Vue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/22/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%8F%8AVue/" class="article-date">
  <time class="dt-published" datetime="2019-10-22T15:50:21.000Z" itemprop="datePublished">2019-10-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/22/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%8F%8AVue/">框架入门及Vue</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="框架入门及-Vue"><a href="#框架入门及-Vue" class="headerlink" title="框架入门及 Vue"></a>框架入门及 Vue</h1><h2 id="MVC、MVP-与-MVVM"><a href="#MVC、MVP-与-MVVM" class="headerlink" title="MVC、MVP 与 MVVM"></a>MVC、MVP 与 MVVM</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>M（Model）：数据保存<br>V（View）：用户页面<br>C（Controller）：业务逻辑<br>所有通信都是单向的。</p>
<ol>
<li>View 传指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><img src="/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/MVP.png"><br>传统前端开发过程使用的 MVP 设计模式（eg.jQuery）。Model 数据层，View 视图层（DOM 式，负责绘制 UI 元素、与用户进行交互），Presenter 呈现层（处理与用户交互的逻辑）。</p>
<ol>
<li>各部分之间的通信是双向的，View 与 Model 不发生联系，都通过 Presenter 传递，所以 P 是 MVP 模式的核心，P 里的业务逻辑是 M 和 V 之间的中转站。</li>
<li>在 MVP 设计模式中，M 层很远；在编写代码的时候其实都在写 P，而 P 中的代码大部分都是在操作 DOM。写大型项目的时候，其实 P 层中百分之七八十的代码都是在操作 DOM</li>
</ol>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><img src="/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/MVVM.png"><br>P 层变成了 VM 层，并且 VM 层不需要我们去编写（是 Vue 自带的）</p>
<ol>
<li>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上（VM 层一方面会监听数据的变化来改变视图，另一方面会监听 V 层的事件触发，然后帮我们调用我们写的逻辑代码来改变 M 层的数据）。用 MVVM 开发的时候，最重的一层其实是 M 层。所以可以这么理解，用 jQuery 开发的时候我们是面向 DOM 进行编程，而用 Vue 是面对数据进行开发，这样在编写大型项目的时候能节省很多代码。</li>
<li>ViewModel 通过<strong>双向数据绑定</strong>把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</li>
<li>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，<strong>而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</strong></li>
</ol>
<h2 id="多页面应用-and-单页面应用"><a href="#多页面应用-and-单页面应用" class="headerlink" title="多页面应用 and 单页面应用"></a>多页面应用 and 单页面应用</h2><ul>
<li>多页面应用：每一次页面跳转的时候，后台的服务器（后端）都会返回一个新的 html 文档。只经过一个 http 请求，速度快；搜索引擎排名效果好。但是每次切换页面都需要一次 http 请求，所以切换速度慢。</li>
<li>单页面应用：在 Vue 项目中， 实现页面跳转不用<code>&lt;a&gt;</code>，而是<code>&lt;router-link to=xxx&gt;</code>，页面跳转是通过 JS 感知 url 的变化，来先清除页面的组件，再渲染新组件实现的。SEO 只识别 html 的内容，所以 SEO 效果会比较差。但是仍有其他方法解决些缺点</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li>Vue 实例、模板（在项目中的 App.vue 是一个 Vue 实例，其他的页面和组件其实是模板。Vue 实例的属性可用 $+属性名 加以区分）</li>
<li>Vue 实例的数据用 data 属性保存，在 template 中可用插值表达式插入；时间用 v-on；方法用 method 属性保存</li>
<li>template 内不要放逻辑，可用计算属性 computed 代替；侦听某一个数据的变化并对此作出反应用侦听器 watch</li>
<li>v-if，v-show 用于数据的显示；v-for 用于数据做循环展示</li>
<li>样式绑定 v-bind（有多种语法，eg. 数组语法，对象语法）</li>
</ol>
<h3 id="watch-的用法"><a href="#watch-的用法" class="headerlink" title="watch 的用法"></a>watch 的用法</h3><h4 id="监听多个变量"><a href="#监听多个变量" class="headerlink" title="监听多个变量"></a>监听多个变量</h4><p>监听单个字符串或数字变量的话就直接写就可以了，如果是监听多个，要结合计算属性，把要监听的多个变量封装成一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// realName 和 idCard 是data中的两个变量</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">submitElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;realName, idCard&#125; = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      realName,</span><br><span class="line">      idCard</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">submitElement</span>: &#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val.<span class="property">realName</span>.<span class="title function_">trim</span>().<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">idCard</span>.<span class="title function_">trim</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isSubmit</span> = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isSubmit</span> = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="监听对象"><a href="#监听对象" class="headerlink" title="监听对象"></a>监听对象</h4><p>监听变量是字符串或数字的话就直接写就可以了，如果监听的是对象，要 计算属性 + 用 deep: true 实现对对象内部属性的监听，也见深度监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">  <span class="attr">childrens</span>:&#123;</span><br><span class="line">    <span class="attr">handler</span>:<span class="keyword">function</span>(<span class="params">val,oldval</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deep</span>:<span class="literal">true</span><span class="comment">//对象内部的属性监听，也叫深度监听</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;childrens.name&#x27;</span>:<span class="keyword">function</span>(<span class="params">val,oldval</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val+<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  &#125;,<span class="comment">//键路径必须加上引号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="watch-和-updated-的区别"><a href="#watch-和-updated-的区别" class="headerlink" title="watch 和 updated 的区别"></a>watch 和 updated 的区别</h4><ul>
<li>updated 是数据发生变化且界面更新完毕执行；不能监听路由数据；<strong>所有数据</strong>发生变化都会调用（耗费性能）</li>
<li>【网易雷火】所以想实现监听一个变量的变化并在这个变量变化导致的页面更新后做一些事情，只用 updated 是不够的。所以怎么实现到现在我仍旧不知道</li>
</ul>
<h3 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h3><p>Vue 实例从创建到销毁的过程，就是生命周期（有创建、初始化数据、挂载 Dom、渲染、更新销毁等一系列过程）。分为 8 个阶段：创建前&#x2F;后、载入前&#x2F;后、更新前&#x2F;后、销毁前&#x2F;销毁后。</p>
<ul>
<li>在 beforeCreate 阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。在 created 阶段，vue 实例的数据对象 data 有了，el 还没有</li>
<li>在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功<strong>渲染</strong>。</li>
<li>beforeUpdate：数据发生改变页面还没被重新渲染之前</li>
<li>销毁前&#x2F;后：执行 destory()</li>
</ul>
<p>它的生命周期有多个生命周期钩子，即是某一个时间点会自动执行的函数，借用这些钩子我们能在 Vue 实例的生命周期中写一些逻辑完善我们的需求</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p>子组件 export default 中写 name 属性；父组件用 import 并写 components 属性即可引用</p>
<h4 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h4><ul>
<li>父子组件间的传值<ul>
<li>父传给子：父绑定属性的方式传给子，子用 props 方法接收</li>
<li>子传给父：$emit 来传递自定义事件和参数，父通过监听这个自定义的事件接收</li>
</ul>
</li>
<li>非父子组件间的传值(兄弟组件传值)<ul>
<li>小型项目用 enentBus（发布订阅模式），就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。在 Vue.prototype.bus&#x3D;new Vue()。 在 Vue 的原型加一个 bus 属性，指向一个 Vue 实例。这样 Vue 实例都会有这个 bus 属性，而且指向的都是同一个实例。然后在一个组件的 bus 去$emit(), 另一个组件的 bus 的去 on 监听事件</li>
<li>大型项目用 Vuex</li>
</ul>
</li>
</ul>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p><strong>使用场景</strong>：<strong>父组件向子组件传递 DOM</strong>，可用插槽。即是在<strong>父组件中</strong>用某个子组件标签，标签之间就可以写插槽，可以写<strong>任何</strong>模板代码（可以是一点 html 代码，甚至可以引用另外一个组件）。然后在<strong>子组件中</strong>这部分内容就用<code>&lt;slot&gt;</code>代替</p>
<p><strong>具名插槽</strong>：父组件中写一个 slot 属性。子组件写成<code>&lt;slot name = &#39;该属性&#39;&gt;</code> 即可。就能实现传递多个插槽<br><strong>作用域插槽</strong>：子组件 v-for 一个<code>&lt;slot&gt;</code>，则这个插槽必须是作用域插槽。在父组件写法会有不同</p>
<h3 id="Vue-中操作-DOM"><a href="#Vue-中操作-DOM" class="headerlink" title="Vue 中操作 DOM"></a>Vue 中操作 DOM</h3><p>先在 DOM 元素节点&#x2F;组件上加 ref 属性和属性值，然后 Vue 实例中用 vm.$refs.属性值 就能引用这个 DOM 节点。</p>
<h3 id="Vue-中的动画"><a href="#Vue-中的动画" class="headerlink" title="Vue 中的动画"></a>Vue 中的动画</h3><p><strong>不太熟练</strong></p>
<h4 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h4><ul>
<li>transition</li>
<li>animation<ul>
<li>自定义</li>
<li>用 Animate.css 库。ink src 引入 css 库，在<tiansition>中写 enter-active-class&#x3D;类名，类名开头必须是 animated，然后再写具体哪个动画</li>
</ul>
</li>
</ul>
<h4 id="JS-动画：用-Velocity-js"><a href="#JS-动画：用-Velocity-js" class="headerlink" title="JS 动画：用 Velocity.js"></a>JS 动画：用 Velocity.js</h4><h2 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h2><p>在真实的 Vue 项目开发过程中，我们会借助 webpack 构建大型项目的开发目录，然后在开发完成之后进行打包，把代码打包生成一个线上可运行的最终代码。每个开发人员自己去配置 webpack 的开发环境是挺难的，所以有 Vue-cli 脚手架工具，用来快速构建 Vue 项目，这个脚手架自带了 webpack 的配置</p>
<h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><p>路由就是根据网址的不同，返回不同组件给用户。组件中的<code>&lt;router-view&gt;</code>显示的是当前路由地址所对应的内容。在 router&#x2F;index.js 中定义当用户访问某个路径 path 时候，给用户展示某个组件</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在 router&#x2F;index.js 中定义当用户访问某个路径 path 时候，给用户展示某个组件<br>在组件中用标签<code>&lt;router-link to=&quot;/&quot; tag=&quot;div&quot;&gt;</code></p>
<h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">动态路由匹配</a></h3><p>例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果。 把配置文件中的 path 写成<code>path: &#39;/user/:id&#39; // 动态路径参数 以冒号开头</code></p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/essentials/navigation.html">编程式导航</a></h3><p>页面跳转还可以用编程式导航。在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push(location, onComplete?, onAbort?)</p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>通过 name 来标识一个路由，而不是路径。在 index.js 配置中加 name 属性后，可用传对象访问<code>&lt;router-link ：to=&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot; tag=&quot;div&quot;&gt;</code></p>
<h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p>“重定向”的意思是，当用户访问 &#x2F;a 时，URL 将会被替换成 &#x2F;b，然后匹配路由为 &#x2F;b，在配置中加 redirect 属性即可<br>“别名”的意思是， &#x2F;a 的别名是 &#x2F;b，意味着，当用户访问 &#x2F;b 时，URL 会保持为 &#x2F;b，但是路由匹配则为 &#x2F;a，就像用户访问 &#x2F;a 一样。加 alias 属性即可</p>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">路由懒加载</a></h3><p>在组件中引用组件的时候，如果子组件很多，我们可以用懒加载实现按需加载。<br>在引用组件的时候写成<code>const Foo = () =&gt; import(&#39;./Foo.vue&#39;)</code>，router 的配置文件不用改</p>
<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">导航守卫</a></h3><p>导航守卫主要用来通过跳转或取消的方式守卫导航，其实是<strong>vue 路由的钩子函数</strong>，是写在 router 的配置文件中<br>首页可以控制导航跳转，beforeEach，afterEach 等，一般用于页面 title 的修改。一些需要登录才能调整页面的重定向功能。</p>
<ul>
<li>beforeEach 主要有 3 个参数 to，from，next。</li>
<li>to：route 即将进入的目标路由对象。</li>
<li>from：route 当前导航正要离开的路由。</li>
<li>next：function 一定要调用该方法 resolve 这个钩子。执行效果依赖 next 方法的调用参数。可以控制网页的跳转</li>
</ul>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>在<code>&lt;router-view&gt;</code>外包裹<code>&lt;keep-alive&gt;</code>，能实现路由的内容（几个组件）被加载过一次之后，就把路由中的内容放在内存之中，下次再进路由的时候不需要重新渲染组件，在内存中并显示就可以。<br>此外该标签可以加个 exclude&#x3D;”Detail”，就是进入 Detail 组件的时候 kepp-alive 不会生效</p>
<h2 id="Vuex（看到官方文档项目结构结束就差不多了）"><a href="#Vuex（看到官方文档项目结构结束就差不多了）" class="headerlink" title="Vuex（看到官方文档项目结构结束就差不多了）"></a><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/">Vuex</a>（看到官方文档项目结构结束就差不多了）</h2><p>Vuex 是 Vue 官方推荐的数据框架，能用于不同组件间的数据共享（一般用来非父子组件的数据共享）<br>可以理解为储存公用数据的仓库（store），各个组件都能一起共享数据。<br><img src="/img/%E6%A1%86%E6%9E%B6%E4%B8%8EVue/Vuex.png"></p>
<ul>
<li>actioin 是放异步操作</li>
<li>mutations 是放同步的对数据的改变</li>
<li>state 是驱动应用的数据源</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在&#x2F;src 目录下新建 store&#x2F;index.js（可以继续新建 mutations.js, state.js 导入 index.js 中），在 src&#x2F;main.js import 这个文件<br>此时在组件中可以不用绑定属性不用 props 了，直接用 Vuex 的 mapState，mapMutations 等简化写法<br>可以结合 localStorage 保存一些数据</p>
<ul>
<li>store.Vuex 使用单一状态树,即每个应用将仅仅包含一个 store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</li>
<li>mutations 定义的方法动态修改 Vuex 的 store 中的状态或数据</li>
<li>actions 可以理解为通过将 mutations 里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</li>
<li>getter.类似 vue 的计算属性，主要用来过滤一些数据</li>
<li>module.项目特别复杂的时候，可以让每一个模块拥有自己的 state、mutation、action、getters，使得结构非常清晰，方便管理</li>
</ul>
<h2 id="Mock-数据"><a href="#Mock-数据" class="headerlink" title="Mock 数据"></a>Mock 数据</h2><ul>
<li>static 目录建立 mock 文件夹（因为在整个工程里，只有 static 目录能被外部访问）</li>
<li>proxy 转发。让对 api&#x2F;xx.json 的请求转到 mock&#x2F;xx.json</li>
<li>Vue 是推荐用<strong>axios</strong>第三方模块来获取 Ajax 数据，安装之后就可以用 axios.get()方法（其实类似于 fetch）。写好方法后让方法在 mounted 的时候执行</li>
</ul>
<h1 id="一些功能的原理"><a href="#一些功能的原理" class="headerlink" title="一些功能的原理"></a>一些功能的原理</h1><h2 id="Vue-实现数据双向绑定的原理：Object-defineProperty"><a href="#Vue-实现数据双向绑定的原理：Object-defineProperty" class="headerlink" title="Vue 实现数据双向绑定的原理：Object.defineProperty()"></a>Vue 实现数据双向绑定的原理：Object.defineProperty()</h2><ul>
<li>vue 实现数据双向绑定主要是：采用数据劫持结合观察者模式的方式。Vue 会遍历数据对象的属性，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调</li>
<li>vue 的数据双向绑定 将 MVVM 作为数据绑定的入口，整合 Observer，Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，通过 Compile 来解析编译模板指令（vue 中是用来解析 插值表达式），最终利用 watcher 搭起 observer 和 Compile 之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据 model 变更双向绑定效果</li>
</ul>
<h3 id="手写实现双向数据绑定"><a href="#手写实现双向数据绑定" class="headerlink" title="手写实现双向数据绑定"></a>手写实现双向数据绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向数据绑定</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据劫持</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据更新&#x27;</span>)</span><br><span class="line">    input.<span class="property">value</span> = newVal <span class="comment">// 要双向绑定所以有这句</span></span><br><span class="line">    span.<span class="property">innerHTML</span> = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  obj.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>监听不到对象属性的增删、数组元素和长度的变化</li>
<li>同时会在 vue 初始化的时候把所有的观察者都建立好，才能观察到数据对象属性的变化</li>
</ul>
<h3 id="Vue3-0-的改进"><a href="#Vue3-0-的改进" class="headerlink" title="Vue3.0 的改进"></a>Vue3.0 的改进</h3><ul>
<li>采用了 ES2015 的 Proxy 来代替 Object.defineProperty，</li>
<li>可以做到监听对象属性的增删和数组元素和长度的修改，还可以监听 Map、Set、WeakSet、WeakMap，</li>
<li>同时还实现了惰性的监听，不会在初始化的时候创建所有的 Observer，而是会在用到的时候才去监听。</li>
<li>但是，虽然主流的浏览器都支持 Proxy，ie 系列却还是不兼容，所以对 ie 还是 Object.defineProperty()</li>
</ul>
<h2 id="v-for-的原理"><a href="#v-for-的原理" class="headerlink" title="v-for 的原理"></a>v-for 的原理</h2><h2 id="computed-的原理"><a href="#computed-的原理" class="headerlink" title="computed 的原理"></a>computed 的原理</h2><ul>
<li>初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。</li>
<li>初始化 computed, 遍历 computed 里的每个属性，<strong>每个 computed 属性都是一个 watch 实例</strong>。每个属性提供的函数作为属性的 - getter，使用 Object.defineProperty 转化。</li>
<li>Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。</li>
<li>若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集</li>
</ul>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><h3 id="v-if-与-v-show-的区别"><a href="#v-if-与-v-show-的区别" class="headerlink" title="v-if 与 v-show 的区别"></a>v-if 与 v-show 的区别</h3><p>v-if 按照条件是否渲染，v-show 是 display 的 block 或 none；</p>
<h3 id="v-el-作用"><a href="#v-el-作用" class="headerlink" title="v-el 作用"></a>v-el 作用</h3><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p>
<h3 id="vue-的优点是什么？"><a href="#vue-的优点是什么？" class="headerlink" title="vue 的优点是什么？"></a>vue 的优点是什么？</h3><ul>
<li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变</li>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写</li>
</ul>
<h3 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h3><p>每个组件都是 Vue 的实例。组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他</p>
<h3 id="为什么官方建议数据异步请求在-mounted-事件进行"><a href="#为什么官方建议数据异步请求在-mounted-事件进行" class="headerlink" title="为什么官方建议数据异步请求在 mounted 事件进行"></a>为什么官方建议数据异步请求在 mounted 事件进行</h3><p>请求是需要时间的，而且这个时间具有不稳定性，很可能 vue 的虚拟 DOM 准备好了，你的数据才请求到，然后又得更新一遍虚拟 DOM，再渲染，极大地延长了白屏时间，用户体验很不好。而在 mounted 事件请求数据呢，静态页面会先渲染好，等数据好了，再更新部分 DOM 即可</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a><br>Vue，Vue-cli，Vue-router，Vuex 的官方文档</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/22/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%8F%8AVue/" data-id="clmniym81004gbb87gzfg5ugu" data-title="框架入门及Vue" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-部分刷题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/21/%E9%83%A8%E5%88%86%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2019-10-21T15:50:21.000Z" itemprop="datePublished">2019-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/21/%E9%83%A8%E5%88%86%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">部分刷题记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="做题方法"><a href="#做题方法" class="headerlink" title="做题方法"></a>做题方法</h3><p>发现输入和输出的规律，寻找突破点<br>当给的例子太简单的时候可以自己多画一些复杂的例子<br>选择合适的数据结构和程序结构（算法）</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>if..else.. 比较简单的话可以简写成 ？ ：的形式<br>switch case 的写法<br>对数组用 forEach，参数函数用了 return false，这里似乎只是回跳出循环而不是整个 return false？ 用 while 语句就不会有这种问题。似乎是因为 forEach 不支持 return false，此外 forEach 也无法终止</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>557 反转字符串中的单词 III</strong><br>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br>示例  1:<br>输入: “Let’s take LeetCode contest”<br>输出: “s’teL ekat edoCteeL tsetnoc” <br>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。<br>思路 1：先用利用空格分割每个单词，单词变数组，再在每个数组内进行反转</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">    .<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">      item</span><br><span class="line">        .<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        .<span class="title function_">reverse</span>()</span><br><span class="line">        .<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路 2：先把每个字符都颠倒过来,tsetnoc edoCteeL ekat s’teL，之后按照空格分隔开， 重新排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">    .<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .<span class="title function_">reverse</span>()</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    .<span class="title function_">reverse</span>()</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>696 计数二进制子串</strong><br>给定一个字符串 s，计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。<br>重复出现的子串要计算它们出现的次数。<br>示例 1 :<br>输入: “00110011”<br>输出: 6<br>解释: 有 6 个子串具有相同数量的连续 1 和 0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路1:0011001 每次都起始字符开始检查，直到遇到非它的。比如说第一次，00截止，长度为2，那么看起始字符的开始段是不是满足0011；</span></span><br><span class="line"><span class="comment"> *      第二次，以第二个字符为起始字符，直到遇到非他的，同样操作...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = s =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="comment">//  定义检查函数</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">matches</span> = s =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> j = s.<span class="title function_">match</span>(<span class="regexp">/^(0+|1+)/</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> i = (j[<span class="number">0</span>] ^ <span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">repeat</span>(j.<span class="property">length</span>); <span class="comment">//  这里的^是按位异或，效果是能让0和1互相转化</span></span><br><span class="line">    <span class="keyword">let</span> all = j + i;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="title function_">startsWith</span>(all)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//  对字符串遍历检查</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="title function_">matches</span>(s.<span class="title function_">slice</span>(i));</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路2</span></span><br><span class="line"><span class="comment"> *   000111必定有三个子串</span></span><br><span class="line"><span class="comment"> *   00011必定有两个子串</span></span><br><span class="line"><span class="comment"> *   0111必定有1个子串</span></span><br><span class="line"><span class="comment"> *   以此类推, 每两组数据之间长度最短的值为子串的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = s =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>,</span><br><span class="line">    arr = s.<span class="title function_">match</span>(<span class="regexp">/(1+)|(0+)/g</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    n += <span class="title class_">Math</span>.<span class="title function_">min</span>(arr[i].<span class="property">length</span>, arr[i + <span class="number">1</span>].<span class="property">length</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>17 九宫格键盘的字母组合</strong><br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射(九宫格)。注意 1 不对应任何字母。<br>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路：递归</span></span><br><span class="line"><span class="comment"> *   会发现只有2个输入的时候是两个中的字母去组合；3个输入的时候，eg. “234”，是先把“23”结果算出来再与“4”结果得到结果，是一种递归。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = str =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果小于1返回空（LeetCode测试用例）</span></span><br><span class="line">  <span class="keyword">if</span> (str.<span class="property">length</span> &lt; <span class="number">1</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">//  建立电话号码键盘映射</span></span><br><span class="line">  <span class="keyword">let</span> map = [<span class="string">&quot;&quot;</span>, <span class="number">1</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>];</span><br><span class="line">  <span class="comment">// 如果只给了一个按键，直接把按键内容取出来并按单个字符分组就可以了（LeetCode测试用例）</span></span><br><span class="line">  <span class="keyword">if</span> (str.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> map[str].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="comment">//  把&#x27;234&#x27;变成[&#x27;abc&#x27;,&#x27;def&#x27;,&#x27;ghi&#x27;]</span></span><br><span class="line">  <span class="keyword">let</span> num = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> code = [];</span><br><span class="line">  num.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[item]) &#123;</span><br><span class="line">      code.<span class="title function_">push</span>(map[item]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//  对变好的数组进行组合运算</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">group</span> = arr =&gt; &#123;</span><br><span class="line">    <span class="comment">//  储存结果的数组</span></span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    <span class="comment">//  第一个for运算arr的第一项，第二个for运算arr的第二项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = arr[<span class="number">0</span>].<span class="property">length</span>; i &lt; il; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jl = arr[<span class="number">1</span>].<span class="property">length</span>; j &lt; jl; j++) &#123;</span><br><span class="line">        <span class="comment">// 这个写法使得arr的项无论是数组还是字符串都能实现拆分组合</span></span><br><span class="line">        tmp.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;arr[<span class="number">0</span>][i]&#125;</span><span class="subst">$&#123;arr[<span class="number">1</span>][j]&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">2</span>, tmp);</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">group</span>(arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">group</span>(code);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>914 卡牌分组</strong><br>给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有  X  张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;&#x3D; 2 时返回  true。<br>示例 1：<br>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]<br>示例 2：<br>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路：记录每种牌数量后，再比较每两种牌的最大公约数是否大于1（辗转相除法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="comment">//  存每种卡牌的总数</span></span><br><span class="line">  <span class="keyword">let</span> total = [];</span><br><span class="line">  <span class="comment">//  创建一个对象来记录每种卡牌的数目(用forEach（需要自己建对象）,reduce都可以)</span></span><br><span class="line">  <span class="keyword">let</span> num = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    item <span class="keyword">in</span> acc ? acc[item]++ : (acc[item] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> num) &#123;</span><br><span class="line">    total.<span class="title function_">push</span>(num[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  求两个数最大公约数的函数</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">eva</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">eva</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">while</span> (total.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = total.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">let</span> b = total.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">let</span> c = <span class="title function_">eva</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      total.<span class="title function_">unshift</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total.<span class="property">length</span> ? total[<span class="number">0</span>] &gt; <span class="number">1</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>605 种花问题</strong><br>种花的规则是花不能相邻。给定一个花坛（表示为一个数组包含 0 和 1，其中 0 表示没种植花，1 表示种植了花），和一个数  n 。能否在不打破种植规则的情况下种入  n  朵花？能则返回 True，不能则返回 False。<br>示例 1:<br>输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1<br>输出: True<br>示例 2:<br>输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2<br>输出: False</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">&#123; flowerbed, n &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//  给数组右边再补一个0,因为判断原来最后一位的时候其实可以默认这一位的虚拟后一位是0</span></span><br><span class="line">  flowerbed.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; flowerbed.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flowerbed[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (flowerbed[i + <span class="number">1</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">        result++;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result &gt;= n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>89 格雷编码</strong><br>输入: 2<br>输出: [0,1,3,2]<br>解释:<br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2<br><img src="/img/%E7%AE%97%E6%B3%95/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   首先理解这个题意就有点难了...</span></span><br><span class="line"><span class="comment"> *   如果你百度过1和3的格雷编码长什么样子，或许能找到规律。从直接外观看，规律如下：</span></span><br><span class="line"><span class="comment"> *   输入n之后，列数就是n，行数是2^n；第一列总是前一半是0，后一半是1；后面列你会发现，总体的上部分是n-1的输出结果复制粘贴，</span></span><br><span class="line"><span class="comment"> *   下部分是复制粘贴后上下颠倒。</span></span><br><span class="line"><span class="comment"> *   思路：由上述规律，想知道n的格雷编码序列，必须知道n-1的序列，是一个递归的思想</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = n =&gt; &#123;</span><br><span class="line">  <span class="comment">// 输入为0的时候</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> [<span class="string">&quot;0&quot;</span>];</span><br><span class="line">  <span class="comment">// 递归函数，用来算输入为n的格雷编码序列</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">getGrayCode</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pre = <span class="title function_">getGrayCode</span>(n - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 格雷编码的行数（长度）。由于我们输出是数组，index是长度-1</span></span><br><span class="line">      <span class="keyword">let</span> resultLength = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, n) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = pre.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        result[i] = <span class="string">`0<span class="subst">$&#123;pre[i]&#125;</span>`</span>;</span><br><span class="line">        result[resultLength - i] = <span class="string">`1<span class="subst">$&#123;pre[i]&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getGrayCode</span>(n).<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  把结果按二进制解析</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item, <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p><strong>459 重复的子字符串</strong><br>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过 10000。<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：正则表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = s =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/^(\w+)\1+$/</span>;</span><br><span class="line">  <span class="comment">//  这个字符串无论从前还是从后开始匹配，都满足是一个匹配项通过 + 得到的</span></span><br><span class="line">  <span class="keyword">return</span> reg.<span class="title function_">test</span>(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>10 实现一个简单的正则表达式（困难）</strong><br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 <em>。要求 p 看做是一个正则，能匹配整个 s<br>示例 1:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a</em>“<br>输出: true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">&#123; s, p &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">isMatch</span> = (<span class="params">s, p</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 边界情况，如果s和p都为空，说明处理结束了，返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (p.<span class="property">length</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> !s.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断p模式字符串的第一个字符和s字符串的第一个字符是不是匹配</span></span><br><span class="line">    <span class="keyword">let</span> match = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; (p[<span class="number">0</span>] === s[<span class="number">0</span>] || p[<span class="number">0</span>] === <span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">      match = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p有模式的</span></span><br><span class="line">    <span class="keyword">if</span> (p.<span class="property">length</span> &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] === <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 第一种情况：s*匹配0个字符</span></span><br><span class="line">      <span class="comment">// 第二种情况：s*匹配1个字符，递归下去，用来表示s*匹配多个s</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isMatch</span>(s, p.<span class="title function_">slice</span>(<span class="number">2</span>)) || (match &amp;&amp; <span class="title function_">isMatch</span>(s.<span class="title function_">slice</span>(<span class="number">1</span>), p));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> match &amp;&amp; <span class="title function_">isMatch</span>(s.<span class="title function_">slice</span>(<span class="number">1</span>), p.<span class="title function_">slice</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isMatch</span>(s, p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>93 复原 IP 地址</strong><br>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。（IP 地址有 4 个段，每一个段值为 0~255）<br>示例:<br>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 思路: IP三个点分成四部分 每部分0-255 每部分最多不超过3位</span></span><br><span class="line"><span class="comment"> *  示例 25525511135 第一部分可能是 2 25 255</span></span><br><span class="line"><span class="comment"> *  如果第一部分是2 那么 第二部分 5 55</span></span><br><span class="line"><span class="comment"> *  如果第二部分 5 那么 第三部分 剩下的超过6位 不满足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = s =&gt; &#123;</span><br><span class="line">  <span class="comment">// 保存所有符合条件的IP地址</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="comment">// 递归函数  上次处理结果，待处理字符串</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">search</span> = (<span class="params">curResult, sub</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 非法输入过滤，LeetCode测试用例(111111111111111111111111111111111111111111111111111111111111)</span></span><br><span class="line">    <span class="keyword">if</span> (sub.<span class="property">length</span> &gt; <span class="number">12</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 边界条件: 已经分为四部分且四部分长度相等</span></span><br><span class="line">    <span class="keyword">if</span> (curResult.<span class="property">length</span> === <span class="number">4</span> &amp;&amp; curResult.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) === s) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(curResult.<span class="title function_">join</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 正常的处理过程</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">3</span>, sub.<span class="property">length</span>), tmp; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 待处理子串，取 1位 2位 3位</span></span><br><span class="line">        tmp = sub.<span class="title function_">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">256</span>) &#123;</span><br><span class="line">          <span class="comment">// 转换下数据类型，如 01为1（LeetCode测试用例）</span></span><br><span class="line">          <span class="title function_">search</span>(curResult.<span class="title function_">concat</span>(tmp * <span class="number">1</span>), sub.<span class="title function_">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">search</span>([], s);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>30 串联所有单词的子串（困难）</strong><br>给定一个字符串  s  和一些长度相同的单词  words。找出 s 中恰好可以由  words 中所有单词串联形成的子串的起始位置。<br>注意子串要与  words 中的单词完全匹配，中间不能有其他字符，但不需要考虑  words  中单词串联的顺序。<br>示例 1：<br>输入：<br>s &#x3D; “barfoothefoobarman”,<br>words &#x3D; <code>[&quot;foo&quot;,&quot;bar&quot;]</code><br>输出：<code>[0,9]</code><br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, <code>[9,0]</code> 也是有效答案。<br>示例 2：<br>输入：<br>s &#x3D; “wordgoodgoodgoodbestword”,words &#x3D; <code>[&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</code><br>输出：[]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 思路:对words数组的item进行一个排列组合生成字符串数组，eg.words = [a,b,c]  </span></span><br><span class="line"><span class="comment">    递归排列组合[a]  第一位 b c中选一位放在第二位</span></span><br><span class="line"><span class="comment">    [b] 第一位 a c中选一位放在第二位</span></span><br><span class="line"><span class="comment">    [c] 第一位 a b中选一位放在第二位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">&#123; s, words &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 结果</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> num = words.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 生成递归的函数</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">range</span> = (<span class="params">curResult, wordsArr</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 边界，计算完毕</span></span><br><span class="line">    <span class="keyword">if</span> (curResult.<span class="property">length</span> === num) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(curResult);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wordsArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = [...wordsArr];</span><br><span class="line">        <span class="comment">// 丢出第一位，生成第二位待选数组</span></span><br><span class="line">        tmp.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">range</span>(curResult.<span class="title function_">concat</span>(item), tmp);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">range</span>([], words);</span><br><span class="line">  <span class="comment">// 子串获取完成，检查有没有匹配的子串</span></span><br><span class="line">  <span class="comment">// [0, 9, -1] filter 之后[0,9]</span></span><br><span class="line">  <span class="comment">// 同时最后的结果要数组去重（用reduce），LeetCode测试用例words是[&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;good&quot;]的时候，会</span></span><br><span class="line">  <span class="comment">// 以为这两个good是不同的而多排列组合一遍</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s.<span class="title function_">indexOf</span>(item.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== -<span class="number">1</span>)</span><br><span class="line">    .<span class="title function_">sort</span>()</span><br><span class="line">    .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (acc.<span class="title function_">indexOf</span>(curr) === -<span class="number">1</span>) &#123;</span><br><span class="line">        acc.<span class="title function_">push</span>(curr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有另一种解法，有点长，没写在这里，面试问到这种解法算我输好吧</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>sort()虽然好用，但底层是一次完整的遍历排序，耗性能，做排序算法题能不用就不用。如果题目中要用数组的最大值&#x2F;最小值，先想想能不能用冒泡&#x2F;选择 排序。</p>
<h4 id="用-sort-的简单排序"><a href="#用-sort-的简单排序" class="headerlink" title="用 sort()的简单排序"></a>用 sort()的简单排序</h4><p><strong>922 奇偶数欧西数组 II</strong><br>给定一个非负整数数组  A， A 中一半整数是奇数，一半整数是偶数。<br>对数组进行排序，以便当  A[i] 为奇数时，i  也是奇数；当  A[i]  为偶数时， i 也是偶数。<br>你可以返回任何满足上述条件的数组作为答案。<br>示例：<br>输入：[4,2,5,7]<br>输出：[4,5,2,7]<br>解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = arr =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="comment">//  声明两个变量来保存下标</span></span><br><span class="line">  <span class="keyword">let</span> odd = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> even = <span class="number">0</span>;</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      result[odd] = item;</span><br><span class="line">      odd += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result[even] = item;</span><br><span class="line">      even += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>164 最大间距（困难）</strong><br>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。<br>示例  1:<br>输入: <code>[3,6,9,1]</code><br>输出: 3<br>解释: 排序后的数组是 <code>[1,3,6,9]</code>, 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。<br>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路：这里的解法1用了一次sort了一次for，时间复杂度相当于是O（n2 + n）。但其实用冒泡排序的话，在排序的时候就已经</span></span><br><span class="line"><span class="comment"> *   能知道前一项跟后一项的差值了。故用冒泡能实现时间复杂度是O（n2）。</span></span><br><span class="line"><span class="comment"> *   具体操作是在每一轮冒泡排序结束后都保存一下目前冒泡终点和终点+1项的差值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 常规解法，时间复杂度不符合题目要求</span></span><br><span class="line"><span class="comment">// let exportFunction = (nums) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   if (nums.length &lt; 0) return 0</span></span><br><span class="line"><span class="comment">//   nums.sort((a, b) =&gt; a - b)</span></span><br><span class="line"><span class="comment">//   let max = 0</span></span><br><span class="line"><span class="comment">//   for (let i = 0; i &lt; nums.length - 1; i++) &#123;</span></span><br><span class="line"><span class="comment">//     let now = nums[i + 1] - nums[i]</span></span><br><span class="line"><span class="comment">//     if (now &gt; max) &#123;</span></span><br><span class="line"><span class="comment">//       max = now</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   return max</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = nums =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> len = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> space;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = nums[j];</span><br><span class="line">      <span class="keyword">if</span> (tmp &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是在每一轮冒泡排序结束后都保存一下目前冒泡终点和终点+1项的差值</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">      space = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">      <span class="keyword">if</span> (space &gt; max) &#123;</span><br><span class="line">        max = space;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(max, nums[<span class="number">1</span>] - nums[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>215 数组中的第 K 个最大元素</strong><br>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路：冒泡排序，当k比较小的时候只要几轮就能结束，性能好</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">&#123; nums, k &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//  当k刚好想让我们取最小值的时候，直接返回数组最小值</span></span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> === k) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, nums);</span><br><span class="line">  <span class="comment">//  其他情况就用冒泡排序节约性能</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = nums[j];</span><br><span class="line">      <span class="keyword">if</span> (tmp &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len - i + <span class="number">1</span> === k) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二：快排.基于数组的第k个数字来调整, 使得比第k个数字小的所有数字都位于数组的左边,比数组大的元素都位于数组的右边。这样调整后 , 位于数组中左边第k个数字就是第k大的元素</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> end = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="title function_">partition</span>(nums, start, end)</span><br><span class="line">  <span class="keyword">while</span>(index !== k - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">      index = <span class="title function_">partition</span>(nums, start, index - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">      index = <span class="title function_">partition</span>(nums, index + <span class="number">1</span>, end)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[k - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">nums, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> target = nums[start]</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[end] &lt;= target &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      end--</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = nums[end]</span><br><span class="line">    <span class="keyword">while</span> (nums[start] &gt; target &amp;&amp; start &lt; end) &#123;</span><br><span class="line">      start++</span><br><span class="line">    &#125;</span><br><span class="line">    nums[end] = nums[start]</span><br><span class="line">  &#125;</span><br><span class="line">  nums[start] = target</span><br><span class="line">  <span class="keyword">return</span> start <span class="comment">// 目标位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>41 缺失的第一个正数</strong><br>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。<br>示例  1:<br>输入: [1,2,0]<br>输出: 3<br>示例  2:<br>输入: [3,4,-1,1]<br>输出: 2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路：涉及到最小值的排序，用选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种算法,性能不是很好（用了一个sort和一个for）,这里的sort其实并不是很必要，没必要把所有的都排好</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="comment">//  过滤掉负数和0，排序</span></span><br><span class="line">  arr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">0</span>);</span><br><span class="line">  arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span> - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i + <span class="number">1</span>] - arr[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> arr[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  如果都是不符合，则是这种[1,2,3,4,5,6],应：</span></span><br><span class="line">      <span class="keyword">return</span> arr.<span class="title function_">pop</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  第二种算法，借用选择排序</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="comment">//  过滤掉负数</span></span><br><span class="line">  arr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//  借用选择排序，先找到第一个最小值，不是1则返回1；不是1则比相邻元素差值，直到找到答案就能停止遍历。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = min;</span><br><span class="line">        min = arr[j];</span><br><span class="line">        arr[j] = c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = min;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] - arr[i - <span class="number">1</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (min !== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span> ? arr.<span class="title function_">pop</span>() + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>75 颜色分类</strong><br>给定一个包含红色、白色和蓝色，一共  n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>示例:<br>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 栈</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**20 有效的括号**</span></span><br><span class="line"><span class="string">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27;  的字符串，判断字符串是否有效。</span></span><br><span class="line"><span class="string">有效字符串需满足：</span></span><br><span class="line"><span class="string">左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="string">左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="string">注意空字符串可被认为是有效字符串。</span></span><br><span class="line"><span class="string">示例 1:</span></span><br><span class="line"><span class="string">输入: &quot;()[]&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">输出: true</span></span><br><span class="line"><span class="string">示例 2:</span></span><br><span class="line"><span class="string">输入: &quot;(]&quot;</span></span><br><span class="line"><span class="string">输出: false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = s =&gt; &#123;</span><br><span class="line">  <span class="comment">// 建立映射</span></span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">&quot;(&quot;</span>: -<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;)&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span>: -<span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;[&quot;</span>: -<span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;]&quot;</span>: <span class="number">3</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>([s[i]]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.<span class="property">length</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>682 棒球比赛</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="comment">// 保存结果，实际是一个栈</span></span><br><span class="line">  <span class="keyword">let</span> result = [],</span><br><span class="line">    <span class="comment">//  建立两个变量储存上个结果和上上个结果</span></span><br><span class="line">    pre1,</span><br><span class="line">    pre2;</span><br><span class="line">  <span class="comment">//  遍历，实现操作</span></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (item) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        pre1 = result.<span class="title function_">pop</span>();</span><br><span class="line">        pre2 = result.<span class="title function_">pop</span>();</span><br><span class="line">        result.<span class="title function_">push</span>(pre2, pre1, pre1 + pre2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">        pre1 = result.<span class="title function_">pop</span>();</span><br><span class="line">        result.<span class="title function_">push</span>(pre1, pre1 * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">        result.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        result.<span class="title function_">push</span>(<span class="title class_">Number</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>85 最大矩形（困难）</strong><br>给定一个仅包含  0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br>示例:<br>输入:<br>[<br>[“1”,”0”,”1”,”0”,”0”],<br>[“1”,”0”,”1”,”1”,”1”],<br>[“1”,”1”,”1”,”1”,”1”],<br>[“1”,”0”,”0”,”1”,”0”]<br>]<br>输出: 6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 队列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[622 设计循环队列](https://jacleklm.github.io/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#more)</span></span><br><span class="line"><span class="string">**621 任务调度器**</span></span><br><span class="line"><span class="string">A - Z 字母表示的 26 种不同种类的任务(执行顺序不限),每个任务都可以在 1 个单位时间内执行完,CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。然而，两个相同种类的任务之间必须有长度为  n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。你需要计算完成所有任务所需要的最短时间。</span></span><br><span class="line"><span class="string">示例 1：</span></span><br><span class="line"><span class="string">输入: tasks = `</span>[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>]<span class="string">`, n = 2</span></span><br><span class="line"><span class="string">输出: 8</span></span><br><span class="line"><span class="string">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">/** 思路: LeetCode上的题解，其实不是特别理解</span></span><br><span class="line"><span class="comment"> * 最小长度 = （单个字母出现的最大次数 - 1）* （n + 1）+ 出现最大次数的字母总数</span></span><br><span class="line"><span class="comment">   最小长度 小于 任务长度时， 返回任务长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">&#123; tasks, n &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> tasks.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">    times[c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - <span class="string">&quot;A&quot;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxTimes = times[<span class="number">0</span>],</span><br><span class="line">    maxItems = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (times[i] == maxTimes) &#123;</span><br><span class="line">      maxItems.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (times[i] &gt; maxTimes) &#123;</span><br><span class="line">      maxTimes = times[i];</span><br><span class="line">      maxItems = [i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ans = (maxTimes - <span class="number">1</span>) * (n + <span class="number">1</span>) + maxItems.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(ans, tasks.<span class="property">length</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><strong>54 螺旋矩阵</strong><br>给定一个包含  m x n  个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>示例  1:<br>输入:<br>[<br>[ 1, 2, 3 ],<br>[ 4, 5, 6 ],<br>[ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 思路:用递归解决</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = matrix =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">spiral</span> = (<span class="params">arr, r</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">        r = r.<span class="title function_">concat</span>(arr[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === len - <span class="number">1</span>) &#123;</span><br><span class="line">        r = r.<span class="title function_">concat</span>(arr[i].<span class="title function_">reverse</span>());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i].<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="comment">// 增加边界检查（Leetcode测试用例）,防止只有两行的矩阵</span></span><br><span class="line">          r.<span class="title function_">push</span>(arr[i].<span class="title function_">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_">shift</span>();</span><br><span class="line">    arr.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = arr.<span class="property">length</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="comment">// 增加边界检查（Leetcode测试用例）,防止只有两行的矩阵</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j].<span class="property">length</span>) &#123;</span><br><span class="line">        r.<span class="title function_">push</span>(arr[j].<span class="title function_">shift</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">spiral</span>(arr, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spiral</span>(matrix, result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>48 旋转图像</strong><br>给定一个 n × n 的二维矩阵表示一个图像。<br>将图像顺时针旋转 90 度。<br>说明：<br>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。<br>示例:<br>给定 matrix &#x3D;<br>[<br>[1,2,3],<br>[4,5,6],<br>[7,8,9]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>[7,4,1],<br>[8,5,2],<br>[9,6,3]<br>]<br>思路： 旋转其实是两次翻转（一次横轴和一次对角线轴）；并且注意每次翻转并不用遍历全部，找到边界<br><img src="/img/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="comment">//  获取矩阵的维度</span></span><br><span class="line">  <span class="keyword">let</span> v = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">//  开始垂直翻转（其实是重写数组项）</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; v / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//  其实垂直翻转，在纵轴上遍历一半就可以了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, tmp; j &lt; v; j++) &#123;</span><br><span class="line">      tmp = arr[i][j];</span><br><span class="line">      arr[i][j] = arr[v - i - <span class="number">1</span>][j];</span><br><span class="line">      arr[v - i - <span class="number">1</span>][j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  开始斜轴翻转</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, tmp; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="comment">//  这里仔细观察，会发现横轴遍历到小于斜轴处就可以了</span></span><br><span class="line">      tmp = arr[i][j];</span><br><span class="line">      arr[i][j] = arr[j][i];</span><br><span class="line">      arr[j][i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>101 对称二叉树的判断</strong><br>给定一个二叉树，检查它是否是镜像对称的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>] 是对称的。</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">但是下面这个 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">3</span>] 则不是镜像对称的:</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   \   \</span><br><span class="line">   <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路：这里其实是【给一个数组构造出对应的二叉树】，并且这个二叉树有一个方法能判断本身是否是对称的</span></span><br><span class="line"><span class="comment"> *   (leetCode上只要写这个方法这部分代码就可以了)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">//  data是传进来的数组</span></span><br><span class="line">    <span class="comment">//  创建一个数组临时储存所有节点</span></span><br><span class="line">    <span class="keyword">let</span> nodeList = [];</span><br><span class="line">    <span class="comment">//  顶节点</span></span><br><span class="line">    <span class="keyword">let</span> root;</span><br><span class="line">    <span class="comment">//  开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(data[i]);</span><br><span class="line">      nodeList.<span class="title function_">push</span>(node);</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//  计算当前节点属于哪一层，sqrt是平方根</span></span><br><span class="line">        <span class="keyword">let</span> n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(i + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">//  计算当前层的起始点，pow() 方法可返回 x 的 y 次幂的值</span></span><br><span class="line">        <span class="keyword">let</span> q = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, n) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  计算上一层的起始点</span></span><br><span class="line">        <span class="keyword">let</span> p = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, n - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  找出当前层的父节点</span></span><br><span class="line">        <span class="keyword">let</span> parent = nodeList[p + <span class="title class_">Math</span>.<span class="title function_">floor</span>((i - q) / <span class="number">2</span>)];</span><br><span class="line">        <span class="comment">//  将当前节点和上一层的父节点做关联</span></span><br><span class="line">        <span class="keyword">if</span> (parent.<span class="property">left</span>) &#123;</span><br><span class="line">          parent.<span class="property">right</span> = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          parent.<span class="property">left</span> = node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root = nodeList.<span class="title function_">shift</span>();</span><br><span class="line">    nodeList.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  构造函数要返回最顶端的根节点,return后就【完成构建了】</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  在这课二叉树中定义了一个静态方法，用来验证该二叉树是否是对称二叉树（递归）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isSymmetry</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">walk</span> = (<span class="params">left, right</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//  判断终点</span></span><br><span class="line">      <span class="keyword">if</span> (!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//  判断不对称的情况</span></span><br><span class="line">      <span class="keyword">if</span> ((left &amp;&amp; !right) || (!left &amp;&amp; right) || left.<span class="property">val</span> !== right.<span class="property">val</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//  若无异常，则进入下一轮递归</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">walk</span>(left.<span class="property">left</span>, right.<span class="property">right</span>) &amp;&amp; <span class="title function_">walk</span>(left.<span class="property">right</span>, right.<span class="property">left</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">walk</span>(root.<span class="property">left</span>, root.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>98 验证二叉搜索树</strong><br>给定一个二叉树，判断其是否是一个有效的二叉搜索树</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>解释: 输入为: [5,1,4,null,null,3,6]。<br>  根节点的值为 5 ，但是其右子节点值为 4 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   思路：【给一个数组，构造出二叉搜索树】，并且这个二叉搜索树有一个方法来验证自身是否是二叉搜索树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">//  data是接收的数组</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">Node</span>(data.<span class="title function_">shift</span>());</span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insert</span>(root, item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  定义插入方法</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">node, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">val</span> &gt; data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        node.<span class="property">left</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insert</span>(node.<span class="property">left</span>, data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        node.<span class="property">right</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">insert</span>(node.<span class="property">right</span>, data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  定义验证方法,思路是遍历整个树，如果所有节点都满足node.left.val &lt; node.val &lt;node.right.val 即可</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">walk</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      (root.<span class="property">left</span> &amp;&amp; root.<span class="property">val</span> &lt; root.<span class="property">left</span>.<span class="property">val</span>) ||</span><br><span class="line">      (root.<span class="property">right</span> &amp;&amp; root.<span class="property">val</span> &gt; root.<span class="property">right</span>.<span class="property">val</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Tree</span>.<span class="title function_">walk</span>(root.<span class="property">left</span>) &amp;&amp; <span class="title class_">Tree</span>.<span class="title function_">walk</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>451 根据字符出现频率排序</strong>（堆排序）<br>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。<br>示例 1:<br>输入:<br>“tree”<br>输出:<br>“eert”<br>解释:<br>‘e’出现两次，’r’和’t’都只出现一次。<br>因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。<br>示例 2:<br>输入:<br>“cccaaa”<br>输出:<br>“cccaaa”<br>解释:<br>‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。<br>注意”cacaca”是不正确的，因为相同的字母必须放在一起。<br><strong>注意</strong>：如果没有时间度复杂度的要求的话，用 sort()和 reduce 应该可以做出来。如果要求时间复杂度用堆排序可以优化性能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 思路: 第一步统计；第二步排序；第三步输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 常规解法，不考虑时间复杂度度与空间复杂度</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = s =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> store = s</span><br><span class="line">    .<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .<span class="title function_">sort</span>()</span><br><span class="line">    .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> &#123;</span><br><span class="line">      curr <span class="keyword">in</span> acc ? acc[curr]++ : (acc[curr] = <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> store) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(i.<span class="title function_">repeat</span>(store[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.<span class="property">length</span> - a.<span class="property">length</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  用堆排序，时间复杂度优化。在我们原来的堆的代码中改constructor的代码（此时传入的是字符串）对字符串进行统计</span></span><br><span class="line"><span class="comment">//  新增一个toString方法，在这个方法里用我们的this.sort()进行堆排序后再输出</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (map.<span class="title function_">has</span>(item)) &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(item, map.<span class="title function_">get</span>(item) + <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(item, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span> = map;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = <span class="title class_">Array</span>.<span class="title function_">from</span>(map.<span class="title function_">values</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sort</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> iArr = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">let</span> n = iArr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> iArr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 构建最大堆从最后一个父节点开始循环</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(iArr, i, n);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">//  不断构建最大堆的过程</span></span><br><span class="line">        <span class="comment">//  因为每次构建都会扔掉一个，所以是n-1-j</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">swap</span>(iArr, <span class="number">0</span>, n - <span class="number">1</span> - j);</span><br><span class="line">        <span class="comment">//  每次交换位置扔完之后应该是从顶点开始，所以第二个参数是0</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(iArr, <span class="number">0</span>, n - <span class="number">1</span> - j - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> iArr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="variable language_">this</span>.<span class="title function_">sort</span>();</span><br><span class="line">    <span class="keyword">let</span> str = [];</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> top = arr.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">map</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v === top) &#123;</span><br><span class="line">          str.<span class="title function_">push</span>(k.<span class="title function_">repeat</span>(v));</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(k);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交换两个元素</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">swap</span>(<span class="params">arr, a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> c = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建最大堆的过程</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">maxHeapify</span>(<span class="params">Arr, i, size</span>) &#123;</span><br><span class="line">    <span class="comment">// i的左节点（索引），这是堆的固有规律</span></span><br><span class="line">    <span class="keyword">let</span> l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// i的右节点</span></span><br><span class="line">    <span class="keyword">let</span> r = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> largest = i;</span><br><span class="line">    <span class="comment">// 父节点i和左节点l做比较取最大</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= size &amp;&amp; <span class="title class_">Arr</span>[l] &gt; <span class="title class_">Arr</span>[largest]) &#123;</span><br><span class="line">      largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右节点和最大值比较</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt;= size &amp;&amp; <span class="title class_">Arr</span>[r] &gt; <span class="title class_">Arr</span>[largest]) &#123;</span><br><span class="line">      largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">      <span class="title class_">Heap</span>.<span class="title function_">swap</span>(<span class="title class_">Arr</span>, i, largest);</span><br><span class="line">      <span class="comment">//  交换完之后确保子树也是满足最大堆的条件</span></span><br><span class="line">      <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(<span class="title class_">Arr</span>, largest, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>313 超级丑数</strong>（堆查找）<br>编写一段程序来查找第 n 个超级丑数。<br>超级丑数是指其所有质因数都是长度为  k  的质数列表  primes  中的正整数。<br>示例:<br>输入: n &#x3D; 12, primes &#x3D; [2,7,13,19]<br>输出: 32<br>解释: 给定长度为 4 的质数列表 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 贪婪算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**122 买卖股票的最佳时机 II**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">/** 思路: 从最低点买入，到价格最高点卖出，不断买卖（在保证单词利益的基础上，实现多次交易）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = prices =&gt; &#123;</span><br><span class="line">  <span class="comment">// 用一个变量保存利润</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// i是买入的时间点，j是卖出的时间点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = prices.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prices[j + <span class="number">1</span>] &gt; prices[j]) &#123;</span><br><span class="line">        <span class="comment">//  发现有利可图，立刻把股票卖了。在j这一天又买入（i = j）</span></span><br><span class="line">        count += prices[j + <span class="number">1</span>] - prices[j];</span><br><span class="line">        i = j;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>860 柠檬水找零</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 思路: 贪心算法，每次找零优先把手头最大的钱扔出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = bills =&gt; &#123;</span><br><span class="line">  <span class="comment">//  钱箱，显示自己的零钱</span></span><br><span class="line">  <span class="keyword">let</span> hand = [];</span><br><span class="line">  <span class="keyword">while</span> (bills.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> money = bills.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (money === <span class="number">5</span>) &#123;</span><br><span class="line">      hand.<span class="title function_">push</span>(money);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hand.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">      <span class="keyword">let</span> change = money - <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = hand.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hand[i] &lt;= change) &#123;</span><br><span class="line">          change -= hand[i];</span><br><span class="line">          hand.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">          i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (change == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (change !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hand.<span class="title function_">push</span>(money);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>53 最大子序和</strong><br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释:  连续子数组  [4,-1,2,1] 的和最大，为  6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：动态规划，状态转移方程：sum[i] = max&#123;sum[i-1]+nums[i],nums[i]&#125; （(sum[i]记录以nums[i]为子序列末端的最大序子列连续和)）</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = nums =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      sum += nums[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>121 买卖股票的最佳时机</strong><br>给一个数组为各天股票价格，只有一次买入和一次卖出的机会，求利润最大值<br>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = prices =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt;= min) &#123;</span><br><span class="line">      min = <span class="title class_">Math</span>.<span class="title function_">min</span>(prices[i], min);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum = <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i] - min, sum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>找出 0 或 1 的字符串中 0 和 1 连续出现的最大次数</strong><br>示例：<br>输入：’0001111100’<br>输出： 5</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = str =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i] === str[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      sum++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>62 不同路径</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注意：机器人不会走一些钻牛角尖的路线。eg，m=2，n=3的话，它不会[0,0],[0,1],[1,1],[1,0],[2,0],[2,1]</span></span><br><span class="line"><span class="comment"> * 思路: 状态转移方程为 d[i][j] = d[i][j-1] + d[i-1][j]；因为机器人不会钻牛角尖，会认为 d[0][j]=1,d[i][0]=1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">&#123; m, n &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 构建矩阵肯定是先构建纵，这里认为纵为n。然后进行 1 的填充</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(m);</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">1</span>; l &lt; n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; m; k++) &#123;</span><br><span class="line">      dp[l][k] = dp[l][k - <span class="number">1</span>] + dp[l - <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><ul>
<li>要理解成链表是客观存在的，变量只是一个指针</li>
<li>链表边界如果老是处理不好，考虑下用数组储存。虽然浪费空间但是能跑起来就行</li>
</ul>
<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例 1: 输入: “abcabcbb”。输出: 3 （abc）<br>示例 3: 输入: “pwwkew”。输出: 3 （wke）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = s =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> store = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="title function_">indexOf</span>(s[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      store.<span class="title function_">push</span>(s[i]);</span><br><span class="line">      sum++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// store = [s[i]]</span></span><br><span class="line">      <span class="comment">// sum = 1</span></span><br><span class="line">      store = store.<span class="title function_">slice</span>(store.<span class="title function_">indexOf</span>(s[i]) + <span class="number">1</span>); <span class="comment">// 这一步比较精妙，使得字符串能舍弃同个部分后继承</span></span><br><span class="line">      store.<span class="title function_">push</span>(s[i]);</span><br><span class="line">      sum = store.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19 删除链表的倒数第 N 个节点"></a>19 删除链表的倒数第 N 个节点</h3><p>可以用双循环法，第一次循环得到链表长度，第二次循环删除节点。也可以借用数组，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leetcode的另一种方法，借用数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">head, n</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> store = [];</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    store.<span class="title function_">push</span>(curr);</span><br><span class="line">    curr = curr.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> pre = store[store.<span class="property">length</span> - n - <span class="number">1</span>]; <span class="comment">// 获取到需要删除的节点的【前一个】</span></span><br><span class="line">  pre ? (pre.<span class="property">next</span> = pre.<span class="property">next</span>.<span class="property">next</span>) : (head = head.<span class="property">next</span>); <span class="comment">//【删除操作】</span></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：合并两个有序链表，有点像归并排序的后半部分操作。所以类似的我们也新建一个链表储存合并的结果</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">l1, l2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 【利用js对象地址传递的方式动态更新范围链表的尾结点插入操作】</span></span><br><span class="line">  <span class="keyword">let</span> tmp = head;</span><br><span class="line">  <span class="keyword">while</span> (l1 !== <span class="literal">null</span> &amp;&amp; l2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.<span class="property">val</span> &lt; l2.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 这部分连接链表的操作</span></span><br><span class="line">      tmp.<span class="property">next</span> = l1;</span><br><span class="line">      l1 = l1.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp.<span class="property">next</span> = l2;</span><br><span class="line">      l2 = l2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = tmp.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 排完了，剩下的尾巴的第一个是谁就接上去</span></span><br><span class="line">  tmp.<span class="property">next</span> = l1 ? l1 : l2;</span><br><span class="line">  <span class="comment">// 返回哨兵结点的next即为所求</span></span><br><span class="line">  <span class="keyword">return</span> head.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59 螺旋矩阵 II"></a>59 螺旋矩阵 II</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 思路: 当输入的为4的时候，可以看出是先输入1234，再567，再8910，再1112，1314，15，16。所以步数数组是[4,3,3,2,2,1,1]</span></span><br><span class="line"><span class="comment"> *  再提出一个当前输入点的概念，用步数数组的index % 4 判断当前输入点的走向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = n =&gt; &#123;</span><br><span class="line">  <span class="comment">// 构建结果矩阵的空矩阵</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result[i] = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建步数数组</span></span><br><span class="line">  <span class="keyword">let</span> step = [];</span><br><span class="line">  step.<span class="title function_">push</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    step.<span class="title function_">push</span>(n - <span class="number">1</span>);</span><br><span class="line">    step.<span class="title function_">push</span>(n - <span class="number">1</span>);</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前输入点和当前输入值</span></span><br><span class="line">  <span class="keyword">let</span> currPoint = [<span class="number">0</span>, -<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; step.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> P = i % <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 当P=0时候，是从左往右输入;1是从上往下；2是从左往右；3是从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; step[i]; j++) &#123;</span><br><span class="line">      value++;</span><br><span class="line">      <span class="keyword">switch</span> (P) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          currPoint[<span class="number">1</span>] = currPoint[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          currPoint[<span class="number">0</span>] = currPoint[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          currPoint[<span class="number">1</span>] = currPoint[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          currPoint[<span class="number">0</span>] = currPoint[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result[currPoint[<span class="number">0</span>]][currPoint[<span class="number">1</span>]] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h3><p>给定一组不含重复元素的整数数组  nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br>示例:<br>输入: nums &#x3D; <code>[1,2,3]</code><br>输出:<br>[<br>[3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = nums =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [[]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = result.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(result[j].<span class="title function_">concat</span>([nums[i]]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层次遍历-剑指offer把二叉树打印成多行"><a href="#102-二叉树的层次遍历-剑指offer把二叉树打印成多行" class="headerlink" title="102. 二叉树的层次遍历 &#x3D;&#x3D;&#x3D; 剑指offer把二叉树打印成多行"></a>102. 二叉树的层次遍历 &#x3D;&#x3D;&#x3D; 剑指offer把二叉树打印成多行</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = root =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> que = [root];</span><br><span class="line">  <span class="keyword">while</span> (que.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 这一层的打印结果</span></span><br><span class="line">    <span class="keyword">let</span> thisResult = [];</span><br><span class="line">    <span class="comment">// 下一层的节点</span></span><br><span class="line">    <span class="keyword">let</span> nextque = [];</span><br><span class="line">    <span class="keyword">while</span> (que.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = que.<span class="title function_">shift</span>();</span><br><span class="line">      thisResult.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span>) nextque.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span>) nextque.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    que = nextque;</span><br><span class="line">    result.<span class="title function_">push</span>(thisResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">mergeTrees</span> = (<span class="params">&#123; t1, t2 &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (t1 === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2 === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    t1.<span class="property">val</span> = t1.<span class="property">val</span> + t2.<span class="property">val</span>;</span><br><span class="line">    t1.<span class="property">left</span> = <span class="title function_">mergeTrees</span>(t1.<span class="property">left</span>, t2.<span class="property">left</span>);</span><br><span class="line">    t1.<span class="property">right</span> = <span class="title function_">mergeTrees</span>(t1.<span class="property">right</span>, t2.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单链表冒泡排序"><a href="#单链表冒泡排序" class="headerlink" title="单链表冒泡排序"></a>单链表冒泡排序</h3><h1 id="剑指-offer"><a href="#剑指-offer" class="headerlink" title="剑指 offer"></a>剑指 offer</h1><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="整数中-1-出现的次数"><a href="#整数中-1-出现的次数" class="headerlink" title="整数中 1 出现的次数"></a>整数中 1 出现的次数</h3><p>考点是<strong>时间效率</strong><br>暴力低效法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NumberOf1Between1AndN_Solution</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    str += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === <span class="string">&quot;1&quot;</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h3><p>统计一个数字在<strong>排序数组</strong>中出现的次数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetNumberOfK</span>(<span class="params">data, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="title function_">indexOf</span>(k) == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = data.<span class="title function_">lastIndexOf</span>(k) - data.<span class="title function_">indexOf</span>(k) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组中只出现一次的数字（易）"><a href="#数组中只出现一次的数字（易）" class="headerlink" title="数组中只出现一次的数字（易）"></a>数组中只出现一次的数字（易）</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FindNumsAppearOnce</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  array.<span class="title function_">sort</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === array[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="两个栈来实现队列"><a href="#两个栈来实现队列" class="headerlink" title="两个栈来实现队列"></a>两个栈来实现队列</h3><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型(一种数据类型，用于定义整数类型变量的标识符)<br><strong>思路</strong>：stack2 反向接在 stack1 的前面，中间部分都是 stack 的头（画图理解）。stack1 为入队栈，stack2 为出队栈</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stack1 = [];</span><br><span class="line"><span class="keyword">let</span> stack2 = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (stack2.<span class="property">length</span>) &#123;</span><br><span class="line">    stack1.<span class="title function_">push</span>(stack2.<span class="title function_">pop</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  stack1.<span class="title function_">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (stack1.<span class="property">length</span>) &#123;</span><br><span class="line">    stack2.<span class="title function_">push</span>(stack1.<span class="title function_">pop</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack2.<span class="title function_">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈的压入和弹出序列"><a href="#栈的压入和弹出序列" class="headerlink" title="栈的压入和弹出序列"></a>栈的压入和弹出序列</h3><blockquote>
<p>注意这个知识点</p>
</blockquote>
<p>1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列（先入 1234 出 4，进 5，出 5321），但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。同理 4,3,5,1,2 可是返回 true（先入 1234 出 43，入 5 出 512）</p>
<p>思路：借助辅助栈，模拟压出弹出的过程。第一个希望被弹出的数字是 4,因此 4 需要先压入到辅助栈里面。压入栈的顺序由压栈序列确定了，也就是在把 4 压入进栈之前，数字 1、2、3 都需要先压入到栈里面。此时栈里包含 4 个数字，分别是 1、2、3、4,其中 4 于栈顶。把 4 弹出栈后，剩下的三个数字是 1、2 和 3。接下来希望被弹出的数字是 5，由 于它不是栈顶数字，因此我们接着在第一个序列中把 4 以后数字压入辅助栈 中，直到压入了数字 5。这个时候 5 位于栈顶，就可以被弹出来了。接下来希望被弹出的三个数字依次是 3、2 和 1。由于每次操作前它们都位于栈顶， 因此直接弹出即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsPopOrder</span>(<span class="params">pushV, popV</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pushV.<span class="property">length</span> == <span class="number">0</span> || popV.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pushV.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pushV[i] === popV[index]) &#123;</span><br><span class="line">      index++;</span><br><span class="line">      <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>] == popV[index]) &#123;</span><br><span class="line">        stack.<span class="title function_">pop</span>();</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(pushV[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxInWindows</span>(<span class="params">num, size</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!size || size &gt; num.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> curr = num.<span class="title function_">slice</span>(<span class="number">0</span>, size);</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  result.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, curr));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = size; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    curr.<span class="title function_">push</span>(num[i]);</span><br><span class="line">    curr.<span class="title function_">shift</span>();</span><br><span class="line">    result.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, curr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function RandomListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.label = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">    this.random = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Clone</span>(<span class="params">pHead</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pHead === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">RandomListNode</span>(pHead.<span class="property">label</span>);</span><br><span class="line">  node.<span class="property">random</span> = pHead.<span class="property">random</span>;</span><br><span class="line">  node.<span class="property">next</span> = <span class="title class_">Clone</span>(pHead.<span class="property">next</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树与双向链表（有点难）"><a href="#二叉搜索树与双向链表（有点难）" class="headerlink" title="二叉搜索树与双向链表（有点难）"></a>二叉搜索树与双向链表（有点难）</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向<br>思路：递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Convert</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="comment">// 递归的终点判断</span></span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="comment">//构建左子树为双向链表，返回链表头节点left</span></span><br><span class="line">  <span class="keyword">var</span> left = <span class="title class_">Convert</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">var</span> tmp = left;</span><br><span class="line">  <span class="comment">//若左子树存在，则用tmp定位到左双向链表最后一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (tmp &amp;&amp; tmp.<span class="property">right</span>) &#123;</span><br><span class="line">    tmp = tmp.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若左子树存在，将左双向链表最后一个节点和当前节点连接起来</span></span><br><span class="line">  <span class="comment">//注意这里，tmp与left的存在与否完全相同</span></span><br><span class="line">  <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">    tmp.<span class="property">right</span> = root;</span><br><span class="line">    root.<span class="property">left</span> = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构建右子树为双向链表，返回链表头结点right</span></span><br><span class="line">  <span class="keyword">var</span> right = <span class="title class_">Convert</span>(root.<span class="property">right</span>);</span><br><span class="line">  <span class="comment">//将右双向链表头节点和当前节点连接起来</span></span><br><span class="line">  <span class="keyword">if</span> (right) &#123;</span><br><span class="line">    right.<span class="property">left</span> = root;</span><br><span class="line">    root.<span class="property">right</span> = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若有左子树，返回的永远是最左边的叶子节点（也就是最小的节点），若无左子树，则根节点就是最小的节点</span></span><br><span class="line">  <span class="keyword">return</span> left ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除排序链表中的重复节点"><a href="#删除排序链表中的重复节点" class="headerlink" title="删除排序链表中的重复节点"></a>删除排序链表中的重复节点</h3><p>额外空间，双指针</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteDuplication</span>(<span class="params">pHead</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">  head.<span class="property">next</span> = pHead;</span><br><span class="line">  <span class="keyword">let</span> pre = head;</span><br><span class="line">  <span class="keyword">let</span> cur = head.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">next</span> !== <span class="literal">null</span> &amp;&amp; cur.<span class="property">val</span> === cur.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (cur.<span class="property">next</span> !== <span class="literal">null</span> &amp;&amp; cur.<span class="property">val</span> === cur.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      pre.<span class="property">next</span> = cur.<span class="property">next</span>;</span><br><span class="line">      cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = pre.<span class="property">next</span>;</span><br><span class="line">      cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeDepth</span>(<span class="params">pRoot</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!pRoot) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="title class_">TreeDepth</span>(pRoot.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">let</span> right = <span class="title class_">TreeDepth</span>(pRoot.<span class="property">right</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。eg. <code>[1,2,3,4,5,6,7]</code>是平衡的</p>
<blockquote>
<p>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树.如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}<br><strong>思路</strong>：寻找能把左右子树区分开的 index，结合递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reConstructBinaryTree</span>(<span class="params">pre, vin</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pre.<span class="property">length</span> == <span class="number">0</span> || vin.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//前序第一个为根节点 也是中序左右子树的分割点</span></span><br><span class="line">  <span class="keyword">var</span> index = vin.<span class="title function_">indexOf</span>(pre[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">var</span> left = vin.<span class="title function_">slice</span>(<span class="number">0</span>, index); <span class="comment">//中序左子树</span></span><br><span class="line">  <span class="keyword">var</span> right = vin.<span class="title function_">slice</span>(index + <span class="number">1</span>); <span class="comment">//中序右子树</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">val</span>: pre[<span class="number">0</span>],</span><br><span class="line">    <span class="comment">//递归左右子树的前序，中序</span></span><br><span class="line">    <span class="attr">left</span>: <span class="title function_">reConstructBinaryTree</span>(pre.<span class="title function_">slice</span>(<span class="number">1</span>, index + <span class="number">1</span>), left),</span><br><span class="line">    <span class="attr">right</span>: <span class="title function_">reConstructBinaryTree</span>(pre.<span class="title function_">slice</span>(index + <span class="number">1</span>), right)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历用于打印树的结构。先序遍历两个树，看结果是否包含</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HasSubtree</span>(<span class="params">pRoot1, pRoot2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!pRoot2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">preTraversal</span>(pRoot1).<span class="title function_">includes</span>(<span class="title function_">preTraversal</span>(pRoot2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">preTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="comment">// 【这种立刻执行的函数，上一句最后要有 ; 不然会有bug！】</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">pre</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">      <span class="title function_">pre</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="title function_">pre</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(root);</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的镜像操作"><a href="#二叉树的镜像操作" class="headerlink" title="二叉树的镜像操作"></a>二叉树的镜像操作</h3><p>递归版：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Mirror</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  [root.<span class="property">left</span>, root.<span class="property">right</span>] = [root.<span class="property">right</span>, root.<span class="property">left</span>];</span><br><span class="line">  <span class="title class_">Mirror</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title class_">Mirror</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归版，有点像层次遍历不过是用栈</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Mirror</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">    [node.<span class="property">left</span>, node.<span class="property">right</span>] = [node.<span class="property">right</span>, node.<span class="property">left</span>];</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否是对称二叉树"><a href="#判断是否是对称二叉树" class="headerlink" title="判断是否是对称二叉树"></a>判断是否是对称二叉树</h3><p>同 leetCode</p>
<h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes,否则输出 No。假设输入的数组的任意两个数字都互不相同<br>思路：后序遍历是 左-右-中，所以数组第一个是二叉树最小值，最后一个是 root。左子树所有节点都小于 root。<br>依次与数组最后一个值比较，一直小于最后一个数的是左子树的，计数，剩下的是右子树的，依次判断剩下的是否全部大于最后一个数，若否，则为 false。类似于二分法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">VerifySquenceOfBST</span>(<span class="params">sequence</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (sequence.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">judge</span>(<span class="params">sequence, sta, end</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sta &gt;= end) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// end是根节点</span></span><br><span class="line">    <span class="keyword">let</span> i = end;</span><br><span class="line">    <span class="comment">// 通过这个while能用i把左右子树区分开，并且右子树满足搜索树</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; sta &amp;&amp; sequence[i - <span class="number">1</span>] &gt; sequence[end]) &#123;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证左子树是否满足都小于根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= sta; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sequence[j] &gt; sequence[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">judge</span>(sequence, sta, i - <span class="number">1</span>) &amp;&amp; <span class="title function_">judge</span>(sequence, i + <span class="number">1</span>, end);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">judge</span>(sequence, <span class="number">0</span>, sequence.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的 list 中，数组长度大的数组靠前)<br><strong>思路：</strong></p>
<ol>
<li>前序遍历二叉树，每次更新当前路径的和 curtSum</li>
<li>判断当前结点是否是叶子结点，以及 curtSum 是否等于 expectNumber。如果是，把当前路径保存在 res 结果中</li>
<li>若不符合条件，则弹出此结点</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FindPath</span>(<span class="params">root, expectNumber</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="title function_">_find</span>(root, expectNumber, [], <span class="number">0</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_find</span>(<span class="params">root, expectNumber, path, currSum, result</span>) &#123;</span><br><span class="line">  currSum += root.<span class="property">val</span>;</span><br><span class="line">  path.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="keyword">if</span> (currSum === expectNumber &amp;&amp; root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>([...path]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">_find</span>(root.<span class="property">left</span>, expectNumber, path, currSum, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">_find</span>(root.<span class="property">right</span>, expectNumber, path, currSum, result);</span><br><span class="line">  &#125;</span><br><span class="line">  path.<span class="title function_">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针<br><strong>思路：</strong><br>（画一个4层的树容易理解）</p>
<ol>
<li>若该节点存在右子树：则下一个节点为右子树最左子节点</li>
<li>若该节点不存在右子树：这时分两种情况：</li>
</ol>
<ul>
<li>2.1 该节点为父节点的左子节点，则下一个节点为其父节点</li>
<li>2.2 该节点为父节点的右子节点，则沿着父节点向上遍历，直到找到一个节点的父节点的左子节点为该节点，则该节点的父节点下一个节点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetNext</span>(<span class="params">pNode</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!pNode) <span class="keyword">return</span> pNode</span><br><span class="line">  <span class="comment">// 1. 存在右子树的情况</span></span><br><span class="line">  <span class="keyword">if</span>(pNode.<span class="property">right</span>) &#123;</span><br><span class="line">    pNode = pNode.<span class="property">right</span></span><br><span class="line">    <span class="keyword">while</span>(pNode.<span class="property">left</span>) &#123;</span><br><span class="line">      pNode = pNode.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 不存在右子树</span></span><br><span class="line">  <span class="keyword">while</span>(pNode.<span class="property">next</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode === pNode.<span class="property">next</span>.<span class="property">left</span>) &#123;</span><br><span class="line">      <span class="comment">// 2.1</span></span><br><span class="line">      <span class="keyword">return</span> pNode.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    pNode = pNode.<span class="property">next</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找和排序"><a href="#查找和排序" class="headerlink" title="查找和排序"></a>查找和排序</h2><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, rotateArray);</span><br></pre></td></tr></table></figure>

<h3 id="最小的-k-个数"><a href="#最小的-k-个数" class="headerlink" title="最小的 k 个数"></a>最小的 k 个数</h3><p>输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4<br>思路：找最小的，显然是选择排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetLeastNumbers_Solution</span>(<span class="params">input, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">length</span> &lt; k) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = input[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; input.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (input[j] &lt; min) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = min;</span><br><span class="line">        min = input[j];</span><br><span class="line">        input[j] = c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    input[i] = min;</span><br><span class="line">    <span class="keyword">if</span> (i === k) <span class="keyword">return</span> input.<span class="title function_">slice</span>(<span class="number">0</span>, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归和循环"><a href="#递归和循环" class="headerlink" title="递归和循环"></a>递归和循环</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）</p>
<blockquote>
<p>斐波那契数列。满足如下的动态规划方程：F(1)&#x3D;1，F(2)&#x3D;1, F(n)&#x3D;F(n-1)+F(n-2)</p>
</blockquote>
<p>普通递归容易导致内存溢出而超时，尾递归能算出结果。动态规划解法最好<br>递归解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = n =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">exportFunction</span>(n - <span class="number">1</span>) + <span class="title function_">exportFunction</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尾递归：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tailFibonacci</span>(<span class="params">n, ac1, ac2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ac2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">tailFibonacci</span>(n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">tailFibonacci</span>(n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = n =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><p>同理动态规划</p>
<h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级<br><strong>思路</strong>：状态转移方程 F(n)&#x3D;F(n-1)+F(n-2)+…F(2)+F(1)+1; 由上式得 F(n)&#x3D;2F(n-1);F(1)&#x3D;1 ;可得到 Fn(n)&#x3D;2^(n-1)。<br>思路也可以是：由于可以 n 阶，每一跳可以跳 1,2,3….n 阶，但是每一跳不可以跳 0 阶，这就相当于是在 n(n&gt;1)个相同的球分堆（组），有多少种分类情况。转成一个排列组合问题，答案是 2^(n-1)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jumpFloorII</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt;= <span class="number">1</span>) <span class="keyword">return</span> number;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, number - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵覆盖"><a href="#矩阵覆盖" class="headerlink" title="矩阵覆盖"></a>矩阵覆盖</h3><p>用 n 个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？<br>可以发现依旧是斐波那契数列，用动态规划解答即可</p>
<h2 id="动态和贪心"><a href="#动态和贪心" class="headerlink" title="动态和贪心"></a>动态和贪心</h2><h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><p>给你一根长度为 n 的绳子，请把绳子剪成 m 段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为 k[0],k[1],…,k[m]。请问 k[0] x k[1] x … x k[m]可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18</p>
<p>动态规划思路：</p>
<p>当 n 大于等于 5 时，我们尽可能多的剪长度为 3 的绳子；当剩下的绳子长度为 4 时，把绳子剪成两段长度为 2 的绳子。 为什么选 2，3 为最小的子问题？因为 2，3 包含于各个问题中，<strong>如果再往下剪得话，乘积就会变小</strong>（所以是临界状态）。所以在 dp 数组中，dp[2]&#x3D;2，dp[3]&#x3D;3。<br>状态转移方程 父绳乘积最大值 &#x3D; 子绳 1 乘积最大值 * 子绳 2 乘积最大值（这个状态转移方程使得题目中剪成 m 段这个说法可以略去），然后做 for 循环，max &#x3D; Math.max(max, curr)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cutRope</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (number === <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> dp = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">4</span>; i &lt; number + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 用一个变量记录不同剪法乘积的最大值</span></span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="comment">// 父绳乘积最大值 = 子绳1乘积最大值 * 子绳2乘积最大值</span></span><br><span class="line">      <span class="keyword">let</span> curr = dp[j] * dp[i - j];</span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, curr);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = max;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[number];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心思路：由动态规划的思路，我们知道当绳子最小为 3 或 2 的时候就不能分了。那么绳子应该优先按 3 去分得到的乘积才是最大，剩下的尾巴再去 2 分（并且如果尾巴是 1 的话，说明最后一段是 4，那这段应该按 2 x 2 分）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cutRope</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (number === <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> timesOf3 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number / <span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 当最后尾巴为1时，说明最后一段是4，应分割成 2 x 2更好，因为2*2=4 &gt; 3=3*1</span></span><br><span class="line">  <span class="keyword">if</span> (number - timesOf3 * <span class="number">3</span> === <span class="number">1</span>) timesOf3--;</span><br><span class="line">  <span class="comment">// 3分完最后尾巴2分</span></span><br><span class="line">  timesOf2 = <span class="title class_">Math</span>.<span class="title function_">floor</span>((number - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, timesOf3) * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, timesOf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学题"><a href="#数学题" class="headerlink" title="数学题"></a>数学题</h2><h3 id="二进制中-1-的个数"><a href="#二进制中-1-的个数" class="headerlink" title="二进制中 1 的个数"></a>二进制中 1 的个数</h3><p>输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示<br><strong>牛客网大佬的思路：</strong>如果一个整数不为 0，那么这个整数至少有一位是 1。如果我们把这个整数减 1，那么原来处在整数最右边的 1 就会变为 0，原来在 1 后面的所有的 0 都会变成 1(如果最右边的 1 后面还有 0 的话)。其余所有位将不会受到影响。eg，二进制 1100，减去 1 会变成 1011。此时我们做与操作，1100&amp;1011 &#x3D; 1000。也就是说，把一个整数减去 1，再和原整数做与运算，会把该整数最右边一个 1 变成 0.那么一个整数的二进制有多少个 1，就可以进行多少次这样的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = n =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="和为-S-的连续正数序列"><a href="#和为-S-的连续正数序列" class="headerlink" title="和为 S 的连续正数序列"></a>和为 S 的连续正数序列</h3><p>输出所有和为 S 的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。每个子序列长度至少为 2</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h2><p>实现一个方法，用于比较两个版本号（version1、version2）,如果version1 &gt; version2，返回1；如果version1 &lt; version2，返回-1，其他情况返回0。版本号规则<code>x.y.z</code>，xyz均为大于等于0的整数，至少有x位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction1</span> = (<span class="params">&#123; curV, reqV &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (curV &amp;&amp; reqV) &#123;</span><br><span class="line">    <span class="comment">//将两个版本号拆成数字</span></span><br><span class="line">    <span class="keyword">var</span> arr1 = curV.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>),</span><br><span class="line">      arr2 = reqV.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> minLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(arr1.<span class="property">length</span>, arr2.<span class="property">length</span>),</span><br><span class="line">      position = <span class="number">0</span>,</span><br><span class="line">      diff = <span class="number">0</span></span><br><span class="line">    <span class="comment">//依次比较版本号每一位大</span></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      position &lt; minLength &amp;&amp;</span><br><span class="line">      (diff = <span class="built_in">parseInt</span>(arr1[position]) - <span class="built_in">parseInt</span>(arr2[position])) == <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      position++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(diff == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr1.<span class="property">length</span> - arr2.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> diff &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//输入为空</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;版本号不能为空&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机生成字符串"><a href="#随机生成字符串" class="headerlink" title="随机生成字符串"></a>随机生成字符串</h2><p>实现一个随机符串生成函数 randomStr()，要求如下：</p>
<ul>
<li>生成的随机的字符串应该以字母开头，并包含 <code>[a-z][0-9]</code> 这些字符。</li>
<li>生成的字符串长度为 8。</li>
<li>生成的字符串不能够在程序运行的生命周期中存在重复的情形</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一： 三十六进制实际上就是（0-9，a-z），十个数字加26个英文字母: &quot;0.ryv9e51n6s3u8adqksxscerk9&quot;  </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">randomStr</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解法2: 笨方法。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">randomStr1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> map = arr = [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">37</span>)</span><br><span class="line">    res = res + map[randomIndex]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/">LeetCode</a><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/315.html">慕课网</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/21/%E9%83%A8%E5%88%86%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" data-id="clmniym8l006cbb878rn3htqu" data-title="部分刷题记录" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构与算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2019-10-19T15:50:21.000Z" itemprop="datePublished">2019-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>吹爆这个博客：<a target="_blank" rel="noopener" href="http://www.conardli.top/docs/">awesome-coding-js</a>，强烈建议刷完这个博客</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>常用API：<br>操作方法。拼接concat(), 裁剪slice(), substr(), substring()，拆分变数组split()，repeat()（接收一个大于等于0的整数为参数，返回复制这个整数倍次数的字符串）<br>位置方法。indexof(), lastIndexof()<br>模式匹配方法。match()（接受一个正则做参数，返回匹配结果数组有）, search()(少用), replace()（第一个参数是正则或字符串，第二个是用来替换的字符串。要实现多次替换必须是用带g的正则）, startsWith()（用来检测字符串是否已制定的前缀开头，返回布尔值。接收一个或者两个参数，第一个是前缀，第二是开始查找的位置）</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>常用API：<br>includes()。判断一个数组是否包含一个指定的值（接收这个值为参数，返回布尔值）<br><strong>栈方法（先进后出）</strong>：push()，pop()（会删除最后一项并作为返回值）<br><strong>队列方法（先进先出）</strong>：shift()（会删除第一项并作为返回值），unshift()（在数组前端添加任意个项并返回新数组的长度）<br><strong>排序方法</strong>：reverse(), sort()（可以接收一个比较函数为参数，比较函数返回的值小于0，a会被排到b前面；没有传入比较函数，就只是单纯把数组toString()，然后用字符串的方法比较排序）<br><strong>操作方法</strong>：concat()（拼接。返回新数组。不影响原来数组），slice()（裁剪。返回新数组。不影响原来数组。一个参数时返回该位置到末尾的所有项；两个参数时返回两个位置之间的项，但不包含结束位置的项），splice()（可删除，替换，插入。会影响原始数组。始终会返回一个数组，该数组包含从原始数组中删除的项）<br><strong>位置方法</strong>：indexOf()，lastIndexOf()。找到的话将返回位置，没找到的话会返回-1</p>
<h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p><strong>不生成数组的迭代</strong><br>every()：测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。它的参数是一个返回值为布尔值的函数，所以用箭头函数表示很方便。<br>eg. <code>[12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false</code><br>some()：同理，不过只要一个元素能通过就会返回true。<br>**reduce()**：累加器（骚操作神器），一定要return。对数值数组可以求和，对字符串数组相当于join()。更强大的功能见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">MDN</a>的例子（累加对象里的键值；将二维数组转为一维；计算数组中每个元素出现的次数；按属性对Object分类；数组去重；绑定包含在对象数组中的数组）<br>eg. <code>[1, 2, 3, 4].reduce((accumulator, currentValue) =&gt; accumulator + currentValue;)  //将会得到10</code><br>reduceRight()：同理，不过是从右往左开始累加<br>forEach()。很好用不解释<br><strong>生成数组的迭代</strong><br>map()：和forEach类似。不过会返回新生成的数组（本来就是一个数组）保存操作结果<br>filter()：和every()类似，不过会生成新数组来包含这些通过测试的item</p>
<h5 id="借用apply"><a href="#借用apply" class="headerlink" title="借用apply"></a>借用apply</h5><p>获取数组中最小值的方法： Math.min.apply(null, arr)</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h5><p>Array.from() 将类似数组的对象转为数组（arguement，Nodelist），也能将普通对象的key值取出来生成一个数组</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/10/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more">正则</a></h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>说实话递归用的不溜</p>
<ul>
<li>一般是一个数组保存结果，写一个递归函数，让这个函数执行一下，返回保存的结果<br>递归函数都喜欢设置第一个参数为暂时的处理结果（可以是数组），第二个参数是要处理的东西。递归函数内部，喜欢用if来判断终点，else来处理正常情况。这个正常情况最后都会递归一下。</li>
<li>递归函数内进行一些操作之后，最后再是边界判断决定是要return递归还是return结果。最终return也可以是递归函数的执行结果</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>sort()虽然好用，但底层是一次完整的遍历排序，耗性能，做排序算法题能不用就不用。如果题目中要用数组的最大值&#x2F;最小值，先想想能不能用冒泡&#x2F;选择 排序。</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><strong>对于评述算法优劣术语的说明</strong><br><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；<br><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。对于一个算法来说，可能会计算出如下操作次数 aN +1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。空间复杂度表示算法的存储空间与数据规模之间的增长关系。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fun(n) &#123;</span><br><span class="line">  let a = [];</span><br><span class="line">  for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    a.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码我们可以清晰的看出代码执行的空间为 O(1+n) &#x3D; O(n)，即为 i 及数组 a 占用的储存空间<br><img src="/img/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F2.png"></p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><strong>一个排好序的数组，在其找item &#x3D;&#x3D;&#x3D; flag的item的index。要start，end，middle</strong><br>首先先找到长度中间位置，通过与中间位置的数比较，比中间值大在右边找，比中间值小在左边找。然后再在两边各自寻找中间值，持续进行，直到找到全部位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设arr已经排好序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, flag, start, end</span>) &#123;</span><br><span class="line">  start = start || <span class="number">0</span></span><br><span class="line">  end = end || arr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>((realStart + realEnd) / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> (arr[m] === flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag &lt; arr[m]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(arr, flag, start, m - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag &gt; arr[m]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(arr, flag, m + <span class="number">1</span>, end)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归的方法也写一个吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> end = arr.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">    start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>((start + end) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag === arr[m]) &#123;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; arr[m]) &#123;</span><br><span class="line">      start = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; arr[m]) &#123;</span><br><span class="line">      end = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序-两两比较，大者排后"><a href="#冒泡排序-两两比较，大者排后" class="headerlink" title="冒泡排序(两两比较，大者排后)"></a>冒泡排序(两两比较，大者排后)</h4><blockquote>
<p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置。实现代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (arr) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 冒泡排序</span></span><br><span class="line">  <span class="comment">// i是每一轮操作的终点，j是每一次操作的具体位置，tmp为被操作元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>, tmp; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      tmp = arr[j]</span><br><span class="line">      <span class="keyword">if</span> (tmp &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>怎么实现降序? 将内层循环的if条件语句改为小于号即可</p>
</blockquote>
<blockquote>
<p>该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + … + 1 ，去掉常数项以后得出时间复杂度是O(n * n)</p>
</blockquote>
<h4 id="选择排序（设置最小值索引）"><a href="#选择排序（设置最小值索引）" class="headerlink" title="选择排序（设置最小值索引）"></a>选择排序（设置最小值索引）</h4><blockquote>
<p>选择排序的原理如下。遍历数组，设置最小值的索引为遍历的起始位置，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作<br>口语化说法：遍历数组，找到最小值的元素放到数组的第一位；第二轮遍历，找到剩下的元素的最小值元素放到数组第二位；…（每次都能知道最小值）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (arr) &#123;</span><br><span class="line">  <span class="comment">//  两个for（第一个for是总遍历确定位置，第二个for是确定位置之后再遍历剩下的项），还需要一个变量储存最小，一个变量方便互换位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = arr[i]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = min</span><br><span class="line">        min = arr[j]</span><br><span class="line">        arr[j] = c</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>是利用二分查找对冒泡排序的改进，原理如下：随机选取一个数组中的值作为基准值，遍历数组把每项与基准值对比大小。比基准值小的放数组左边，大的放右边。然后将数组以基准值的位置分为两部分，继续递归以上操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//中间位置</span></span><br><span class="line">  <span class="keyword">let</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> flag = arr.<span class="title function_">splice</span>(middle, <span class="number">1</span>)[<span class="number">0</span>];<span class="comment">//取出中间元素</span></span><br><span class="line">  <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;<span class="comment">// 注意这里是arr.length</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; flag) &#123; <span class="comment">// 这个if也是导致快排不稳定的原因：两个相同的数，如果有一个被用来做flag，另一个很可能会被换位置</span></span><br><span class="line">      left.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>(flag, <span class="title function_">quickSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="插入排序（类似于摸扑克牌）"><a href="#插入排序（类似于摸扑克牌）" class="headerlink" title="插入排序（类似于摸扑克牌）"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_32290679/article/details/78619848">插入排序（类似于摸扑克牌）</a></h4><p>从第一个元素开始，该元素认为已经被排序了，取出下一个元素。在已经排序的元素序列中从后向前扫描，如果大于新元素，那么就把这个元素移动到下一个位置。直到找到已排序的元素小于或者等于新元素的位置，将新元素插入下一个位置。依次进行。（其实就是最开头的元素当作是有序数列，后面的元素是无序的，然后从第一个开始往前面插入）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">//插入排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[j];</span><br><span class="line">    i = j - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; arr[i] &gt; key) &#123;</span><br><span class="line">      arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>一种稳定排序方法，将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使序列段间有序。<br>其实也是二分的思想，只不过是在<strong>二分的基础上，先分段，段内再排，然后把每一段拼接起来</strong>。<br>这篇<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/33cffa1ce613">博客</a>里有非常仔细的图片分析。这个需要新申请一个数组来做，所以自然是O(n)的空间复杂度啦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 从上到下递归</span></span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, middle)</span><br><span class="line">  <span class="keyword">let</span> right = arr.<span class="title function_">slice</span>(middle)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span> &amp;&amp; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span>) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (right.<span class="property">length</span>) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>见后面堆数据结构</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一个线性结构，特点是只能在某一端添加或删除数据，遵循先进后出的原则。</p>
<blockquote>
<p>实现：可以把栈看成是数组的一个子集，所以这里使用数组来实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="title function_">getCount</span>() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getCount</span>() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则</p>
<blockquote>
<p>单链队列的实现：用数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enQueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">deQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getHeader</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getLength</span>() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了<strong>循环队列</strong>（也是LeetCode-622题目）。循环队列的出队操作平均是 O(1) 的时间复杂度。循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。<br>可以看视频加深理解，实现代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">k</span>) &#123;</span><br><span class="line">	<span class="comment">//  创建一个长度为k的数组</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = <span class="title class_">Array</span>(k)</span><br><span class="line">    <span class="comment">//  队头指针</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  队尾指针</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rear</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  队列长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = k</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enQueue</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isFull</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">rear</span>] = num <span class="comment">//  【在尾指针处入队，记得入队之后尾指针要后移一位】</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rear</span> = (<span class="variable language_">this</span>.<span class="property">rear</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">max</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">deQueue</span>(<span class="params"></span>) &#123; <span class="comment">//  【在头指针处入队，然后同样后移头指针】</span></span><br><span class="line">    <span class="keyword">let</span> v = <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> = (<span class="variable language_">this</span>.<span class="property">front</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">max</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123; <span class="comment">// Empty是头指针跟尾指针在同个位置，且这个位置是空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> === <span class="variable language_">this</span>.<span class="property">front</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isFull</span>(<span class="params"></span>) &#123; <span class="comment">// Full是头指针跟尾指针在同个位置，且这个位置不是空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> === <span class="variable language_">this</span>.<span class="property">front</span> &amp;&amp; !!<span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Front</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">front</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Rear</span>() &#123; <span class="comment">//  有可能上次入队操作使得尾指针移到了循环的开始位置</span></span><br><span class="line">    <span class="keyword">let</span> rear = <span class="variable language_">this</span>.<span class="property">rear</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[rear &lt; <span class="number">0</span> ? <span class="variable language_">this</span>.<span class="property">max</span> - <span class="number">1</span> : rear]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h4><ul>
<li>链表是链式的存储结构；数组是顺序的存储结构（ 链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储）</li>
<li>链表的插入删除元素相对数组较为简单，不需要移动元素，但是寻找某个元素较为困难；数组寻找某个元素较为简单，但插入与删除比较复杂， 都需要把其他元素向前或者向后</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>链表是一组由节点组成的集合，链表节点（也称数据元素的节点）又包含数据域（存数据）和指针域（指向下一个节点）。链表的尾元素指向一个null节点（为空）。eg. 可以简写为 Head-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</li>
<li>通常在在第一个节点前设置一个节点，称为头节点（不一定是必要元素，当是空表时可以是空）。其数据域可以无意义也可以存放链表长度等信息</li>
<li>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大</li>
</ul>
<h4 id="单向链表的实现"><a href="#单向链表的实现" class="headerlink" title="单向链表的实现"></a>单向链表的实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="comment">// Node类表示节点</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">v, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = v</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NodeList</span> &#123; <span class="comment">// LinkList类表示链表</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dummyNode</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">checkIndex</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Index error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">find</span>(<span class="params">header, index, currentIndex</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(header.<span class="property">next</span>, index, currentIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addNode</span>(<span class="params">v, index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index)</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>)</span><br><span class="line">    pre.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(v, pre.<span class="property">next</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>++</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="property">next</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">insertNode</span>(<span class="params">v, index</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addNode</span>(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addToFirst</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addNode</span>(v, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addToLast</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(v, <span class="variable language_">this</span>.<span class="property">size</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeNode</span>(<span class="params">index, isLast</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index)</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="variable language_">this</span>.<span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> node = prev.<span class="property">next</span></span><br><span class="line">    prev.<span class="property">next</span> = node.<span class="property">next</span></span><br><span class="line">    node.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>--</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeFirstNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removeLastNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeNode</span>(<span class="variable language_">this</span>.<span class="property">size</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getNode</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">checkIndex</span>(index)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">find</span>(<span class="variable language_">this</span>.<span class="property">dummyNode</span>, index, <span class="number">0</span>).<span class="property">next</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断是否是环形链表（LeetCode-141）"><a href="#判断是否是环形链表（LeetCode-141）" class="headerlink" title="判断是否是环形链表（LeetCode-141）"></a>判断是否是环形链表（LeetCode-141）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (head) =&gt; &#123;</span><br><span class="line">  <span class="comment">//  双指针法(快慢)</span></span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">    fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    slow = slow.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (fast === slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）"><a href="#反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）" class="headerlink" title="反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）"></a>反转链表（LeetCode-206），简单但是面试常问。可以画个图方便理解，需要三个变量（前，中，后）</h4><p>注意不要弄混 反转 和 遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">exportFunction</span> = (<span class="params">head</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">  <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head</span><br><span class="line">  <span class="comment">// 设置初始为空（因为反转后这里就是尾巴的null）</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> curr = head</span><br><span class="line">  <span class="keyword">let</span> next</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    next = curr.<span class="property">next</span></span><br><span class="line">    curr.<span class="property">next</span> = pre</span><br><span class="line">    pre = curr</span><br><span class="line">    curr = next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre <span class="comment">//  因为反转完成后curr在尾部的null，所以是返回pre</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>在leetCode中一般是用二维数组表示，螺旋矩阵是<strong>面试常考题</strong></p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树的定义：树由一组以边连接的节点组成。一些<strong>概念</strong>：根节点，左子树&#x2F;右子树，子节点&#x2F;父节点，叶子节点（最底部的节点），键值，从xx（节点）到xx的路径，树的层次（根节点是第0层），任何一层的节点都可以看做是子树的根<br>树的高度（从下往上）和深度（从上往下）。根节点的深度为1，叶子节点的高度为1<br>层数：根节点为第一层，往下一次递增</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>一种特殊的树，子节点不超过两个。新增概念：左节点和右节点。</p>
<h4 id="二叉搜索树（查找效率高）"><a href="#二叉搜索树（查找效率高）" class="headerlink" title="二叉搜索树（查找效率高）"></a>二叉搜索树（查找效率高）</h4><p>特殊的二叉树。 每个节点的值都比他的左子树的值大，比右子树的值小。<br>其实已经是一种排序了。 因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小（因为二叉搜索树就是由一堆数字经过函数之后构造的，所以一定满足这个定义）</p>
<h4 id="给定一个数组，创建对应的二叉树和二叉搜索树，见-常见算法题及剑指offer"><a href="#给定一个数组，创建对应的二叉树和二叉搜索树，见-常见算法题及剑指offer" class="headerlink" title="给定一个数组，创建对应的二叉树和二叉搜索树，见 常见算法题及剑指offer"></a>给定一个数组，创建对应的二叉树和二叉搜索树，见 <a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/10/21/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E5%8F%8A%E5%89%91%E6%8C%87offer/">常见算法题及剑指offer</a></h4><h4 id="二叉搜索树的实现及其他操作"><a href="#二叉搜索树的实现及其他操作" class="headerlink" title="二叉搜索树的实现及其他操作"></a>二叉搜索树的实现及其他操作</h4><ul>
<li>二叉搜索树的实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addNode</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  <span class="title function_">_addChild</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">      node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">left</span>, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">      node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_addChild</span>(node.<span class="property">right</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">树的遍历</a><blockquote>
<p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">breadthTraversal</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">root</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> q = []</span><br><span class="line">    <span class="comment">// 将根节点入队</span></span><br><span class="line">    q.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">    <span class="comment">// 循环判断队列是否为空，为空代表树遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">      <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">      <span class="keyword">let</span> n = q.<span class="title function_">shift</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">value</span>)</span><br><span class="line">      <span class="keyword">if</span> (n.<span class="property">left</span>) q.<span class="title function_">push</span>(n.<span class="property">left</span>)</span><br><span class="line">      <span class="keyword">if</span> (n.<span class="property">right</span>) q.<span class="title function_">push</span>(n.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getMin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(<span class="variable language_">this</span>.<span class="property">root</span>).<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_getMin</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.<span class="property">left</span>) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">left</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getMax</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMax</span>(<span class="variable language_">this</span>.<span class="property">root</span>).<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_getMax</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.<span class="property">right</span>) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最复杂的部分：删除节点。因为有三种情况：要删除的节点没有子树；有一条子树；两条子树<ul>
<li>简单的情况：删除最小&#x2F;最大的节点，下面以删除最小节点为例。对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">deleteMin</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_deleteMin</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">root</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_deleteMin</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="comment">//  一直递归找到最小节点</span></span><br><span class="line">  <span class="comment">//  找到的时候判断时候有右节点，有的话就return右节点把原来的节点给重写了</span></span><br><span class="line">  <span class="comment">//  没有右节点，也return右节点（null）重写原来节点，相当于删除了</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp;&amp; !node.<span class="property">left</span>) <span class="keyword">return</span> node.<span class="property">right</span></span><br><span class="line">  node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_deleteMin</span>(<span class="variable language_">this</span>.<span class="property">left</span>)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.<span class="property">size</span> = <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">left</span>) + <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">right</span>) + <span class="number">1</span></span><br><span class="line">  <span class="comment">//  返回根节点</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除任意节点。思路：取出被删除节点右子树中最小的节点来替换被传出的节点。<br>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">delect</span>(<span class="params">v</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">root</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(<span class="variable language_">this</span>.<span class="property">root</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">_delect</span>(<span class="params">node, v</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">value</span> &lt; v) &#123;</span><br><span class="line">    node.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(node.<span class="property">right</span>, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">value</span> &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">_delect</span>(node.<span class="property">left</span>, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">left</span>) <span class="keyword">return</span> node.<span class="property">right</span></span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">right</span>) <span class="keyword">return</span> node.<span class="property">left</span></span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="variable language_">this</span>.<span class="title function_">_getMin</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">_delectMin</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.<span class="property">left</span> = node.<span class="property">left</span></span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.<span class="property">size</span> = <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">left</span>) + <span class="variable language_">this</span>.<span class="title function_">_getSize</span>(node.<span class="property">right</span>) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>堆通常是一个可以被看做一棵树的数组对象（有索引），堆可以理解为有特殊特征的二叉树：必须是完全二叉树（n-1层必须是满二叉树），即除了最底层，其他层的节点都被元素填满；任一节点的值是其子树所有节点的最大值或最小值（称为最大堆&#x2F;最小堆）<br><img src="/img/%E7%AE%97%E6%B3%95/%E5%A0%86.png"></li>
<li>对任一索引为i的节点，其左子节点索引为 <code>2*i + 1</code>，右子节点为<code>2*i + 2</code>，父节点为<code>(i-1) / 2</code></li>
<li>构建最大堆。即把一个普通的二叉树排序好变成一个最大堆。将节点与父节点对比大小，如果比父节点大，就和父节点交换位置（maxHeapify）；遍历所有节点进行该操作之后就能构建一个最大堆。<strong>构建一次最大堆能选出一个最大值</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123; <span class="comment">//  data应该是一个数组（保存未排序的二叉树）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sort</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> iArr = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    <span class="keyword">let</span> n = iArr.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> iArr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// 构建最大堆从最后一个父节点开始循环</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(iArr, i, n)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//  不断构建最大堆的过程</span></span><br><span class="line">        <span class="comment">//  因为每次构建都会扔掉一个，所以是n-1-j</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">swap</span>(iArr, <span class="number">0</span>, n - <span class="number">1</span> - j) </span><br><span class="line">        <span class="comment">//  每次交换位置扔完之后应该是从顶点开始，所以第二个参数是0</span></span><br><span class="line">        <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(iArr, <span class="number">0</span>, n - <span class="number">1</span> - j - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> iArr</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交换两个元素</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">swap</span>(<span class="params">arr, a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> c = arr[a]</span><br><span class="line">    arr[a] = arr[b]</span><br><span class="line">    arr[b] = c</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构建最大堆的过程</span></span><br><span class="line">  <span class="comment">// 堆排序的时候需要把原来的根节点与最右的叶子节点互换位置后扔出数组，这里不是真的扔出去，而是引入了size，对索引大于size的item忽略不操作。</span></span><br><span class="line">  <span class="comment">//  所以整个构建最大堆的过程数组的长度不会变</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">maxHeapify</span>(<span class="params">Arr, i, size</span>) &#123;</span><br><span class="line">    <span class="comment">// i的左节点（索引），这是堆的固有规律</span></span><br><span class="line">    <span class="keyword">let</span> l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="comment">// i的右节点</span></span><br><span class="line">    <span class="keyword">let</span> r = i * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> largest = i</span><br><span class="line">    <span class="comment">// 父节点i和左节点l做比较取最大（此时只是比较并用largest变量保存最大的，并没有真正在数组中交换）</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= size &amp;&amp; <span class="title class_">Arr</span>[l] &gt; <span class="title class_">Arr</span>[largest]) &#123;</span><br><span class="line">      largest = l</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父节点i和右节点r做比较取最大（此时只是比较并用largest变量保存最大的，并没有真正在数组中交换）</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt;= size &amp;&amp; <span class="title class_">Arr</span>[r] &gt; <span class="title class_">Arr</span>[largest]) &#123;</span><br><span class="line">      largest = r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在数组中交换</span></span><br><span class="line">    <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">      <span class="title class_">Heap</span>.<span class="title function_">swap</span>(<span class="title class_">Arr</span>, i, largest)</span><br><span class="line">      <span class="comment">// 交换完之后确保子树也是满足最大堆的条件</span></span><br><span class="line">      <span class="title class_">Heap</span>.<span class="title function_">maxHeapify</span>(<span class="title class_">Arr</span>, largest, size)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>堆排序。在一次构建最大堆结束之后，把根节点与最右的叶子节<strong>互换位置</strong>（swap），然后移除现在这个叶子节点（原来的根节点）。再构建一次最大堆，<strong>即找到了第二大的值</strong> … 直到最后只剩下一个节点，就完成了堆排序。</li>
<li><em>堆查找</em>。见例题超级丑数。题意有点绕</li>
</ul>
<p>堆和堆栈的概念区别</p>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>贪心算法（又称贪婪算法，其实是一种思想）是指，在对问题求解时，总是做出在当<strong>前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>借助10级台阶有多少种走法（每次只能走一步或两步）的例子来理解。下面是重要概念：</p>
<ul>
<li>状态转移方程。F(10) &#x3D; F(9) + F(8)</li>
<li>最优子结构。F(10) &#x3D; F(9) + F(8)。称F(9)和F(8)是F(10)的最优子结构</li>
<li>边界。往前推导的时候，会发现到F(1)和F(2)的之后就无法继续推导了，称这两者是问题的边界</li>
</ul>
<p>总结：动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决<br><strong>解法</strong>：先观察题目写出状态转移方程，再判断问题的边界。特别<strong>善于解决不同路径和最短路径的问题</strong><br><strong>具体写法</strong>：构建数组(n+1) &#x2F; 矩阵，填满已知部分（边界）（填满的过程也可以用for循环 (n+1) ），然后for循环设定好状态转移方程，最后return结构。用这种做法更好，<strong>递归容易超时？</strong><br>见leetcode-62<br>自己的感想：<strong>见两道例题</strong></p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a><br>《数据结构与算法JS描述》<br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/315.html">慕课网</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" data-id="clmniym82004jbb87hvo76ohd" data-title="数据结构与算法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>