<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jacleklm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:type" content="website">
<meta property="og:title" content="Jacleklm">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Jacleklm">
<meta property="og:description" content="FullStack Engineer in Narwal. Focus on Frontend.">
<meta property="og:locale">
<meta property="article:author" content="Jacleklm">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jacleklm" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jacleklm</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-操作系统概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2019-10-18T15:02:21.000Z" itemprop="datePublished">2019-10-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="What-Why"><a href="#What-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h2><p>what：操作系统是管理计算机硬件和软件资源，提供用户交互界面的<strong>计算机程序</strong><br>Why：统一界面，操作硬件，简易地使用计算机</p>
<h2 id="操作系统的基本功能"><a href="#操作系统的基本功能" class="headerlink" title="操作系统的基本功能"></a>操作系统的基本功能</h2><ul>
<li>统一管理着计算机资源。eg. 处理器资源、IO 设备资源、存储器资源、文件资源</li>
<li>实现了对计算机资源的抽象。eg. 用户无需面向硬件接口编程； IO 设备管理软件，提供读写接口； 文件管理软件，提供操作文件接口</li>
<li>提供了用户与计算机之间的接口。eg. 图像窗口形式， 命令形式， 系统调用形式<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD.png"></li>
</ul>
<h2 id="操作系统的演进"><a href="#操作系统的演进" class="headerlink" title="操作系统的演进"></a>操作系统的演进</h2><p>无操作系统—批处理系统（有多道程序设计的概念）—分时系统（能及时调试程序）</p>
<blockquote>
<p><strong>多道程序设计</strong>：多道程序设计使得批处理系统<strong>可以一次处理多个任务</strong>，提升计算机资源的利用率。 是指在计算机内存中同时存放多个程序， 在计算机的管理程序之下相互穿插运行，对多道程序的管理是<strong>操作系统的重要功能</strong>，分为：<strong>进程管理</strong>，<strong>存储管理</strong>，<strong>作业管理</strong>，<strong>文件管理</strong>（文件存储空间的管理、目录管理、文件读写管理和保护等。），<strong>设备管理</strong>（完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
</blockquote>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p><strong>并行</strong>是指两个或多个事件可以在<strong>同一个时刻</strong>发生，表现为同一时刻可以处理多个指令。eg. 一个双处理器，一个处理器处理一个事件<br><strong>并发</strong>是指两个或多个事件可以在同一个时间间隔发生， 宏观上表现为在<strong>一段时间内</strong>能同时运行多个程序。eg. 一个单处理器，在极短的时间间隔内交替运行多道程序，可视为并发。<br>并行需要硬件支持，如多流水性、多核处理器或分布式计算系统；而操作系统通过引入进程和线程就能使得程序能都并发运行</p>
<h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>表现为操作系统中的资源可被多个并发的程序共同使用（资源共享）。eg. 主存中的资源<br>有两种共享方式：<strong>互斥共享</strong>（当资源被程序 A 占用时，其他程序想使用的话只能等待。eg. 打印机）和<strong>同时共享</strong>（某种资源在一段时间内并发地被多个程序访问，这种“同时”是宏观的）</p>
<h3 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h3><p>虚拟性表现为把一个物理实体转变为若干个逻辑实体（物理实体是真实存在的，逻辑实体是虚拟的）。<br>虚拟的技术主要有：</p>
<ul>
<li>时分复用技术。 资源在时间上进行复用，不同程序并发使用。其实现是借助了<strong>虚拟处理器技术</strong>（ 多个进程轮流占用处理器，每次只执行一小个时间片并快速切换）和<strong>虚拟设备技术</strong>（物理设备虚拟为多个逻辑设备，每个程序栈用一个逻辑设备，多个程序通过逻辑设备并发访问）</li>
<li>空分复用技术。 空分复用技术用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘（C、D、E 盘））、虚拟内存（ 在逻辑上扩大程序的存储容量， 使用比实际内存更大的容量）等。</li>
</ul>
<h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。（能实现多进程并发执行，因为有异步性进程能在使用资源前能等待）</p>
<h1 id="Further"><a href="#Further" class="headerlink" title="Further"></a>Further</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li><strong>进程是系统进行资源分配和调度的基本单位（一般一个程序对应一个进程）</strong>。 引入多道程序设计的概念后， 进程作为程序独立运行的载体保障程序正常执行， 进程的存在使得操作系统资源的利用率大幅提升</li>
<li><strong>线程是操作系统进行运算调度的最小单位</strong>。 一个进程中可以有多个线程，它们共享进程资源， 是进程中实际运行工作的单位。<strong>eg</strong>. QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。二者区别如下：</li>
</ul>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.png"></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程实体"><a href="#进程实体" class="headerlink" title="进程实体"></a>进程实体</h3><p><strong>主存中</strong>的进程形态表现为一段连续存储的空间，叫<strong>进程控制块</strong> (Process Control Block, PCB)。里面记录了很多信息（eg. 状态，标识符，优先级，内存指针…）。PCB 用于描述和控制进程运行的通用数据结构， 记录进程当前状态和控制进程运行的全部信息， <strong>PCB 的使得进程是能够独立运行的基本单位。</strong></p>
<h2 id="进程的五状态模型"><a href="#进程的五状态模型" class="headerlink" title="进程的五状态模型"></a>进程的五状态模型</h2><ul>
<li>就绪（ready）： 其他资源都准备好、只差 CPU 资源的状态为就绪状态。 在一个系统中多个处于就绪状态的进程通常排成一个队列，称为就绪队列</li>
<li>执行（running）： 进程获得 CPU，其程序正在执行称为执行状态（单处理的某个时候只能有一个进程是该状态）</li>
<li>阻塞（waiting）： 进程因某种原因（eg. 有设备未准备就绪，例如打印机的排队造成的阻塞）而放弃 CPU 的状态称为阻塞状态。同理有阻塞队列</li>
<li>*创建： 创建进程时拥有 PCB 但其他资源尚未就绪的状态称为创建状态</li>
<li>*终止： 进程结束由系统清理或者归还 PCB 的状态称为终止状态</li>
</ul>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>关于临界资源（临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源，要等这个进程用完并释放，下个进程才能用）的两个问题</p>
<ul>
<li>生产者-消费者问题</li>
<li>哲学家进餐问题</li>
</ul>
<p>两个问题的原因都是：彼此相互之间没有通信。应该对竞争资源在多进程间进行使用次序的协调，使得并发执行的多个进程之间可以有效使用资源和相互合作。这就是<strong>进程间的同步</strong></p>
<h3 id="进程间同步的原则"><a href="#进程间同步的原则" class="headerlink" title="进程间同步的原则"></a>进程间同步的原则</h3><ul>
<li>空闲让进：资源无占用，允许使用</li>
<li>忙则等待：资源有占用，请求进程等待</li>
<li>有限等待：保证有限等待时间能够使用资源</li>
<li>让权等待：等待时，进程需要让出 CPU</li>
</ul>
<p>进程同步的方法：消息队列；共享存储；信息量</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>由于进程内的线程共享进程资源，所以同理进程内多线程也需要同步。同步方法为：互斥量；读写锁；自旋锁；条件变量</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/355.html">慕课网</a><br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">CS-notes</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" data-id="clmniym7x0049bb8748o9dqry" data-title="操作系统" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2019-10-17T15:50:21.000Z" itemprop="datePublished">2019-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概述篇"><a href="#概述篇" class="headerlink" title="概述篇"></a>概述篇</h2><h3 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h3><ul>
<li>1946-1957，电子管计算机</li>
<li>1957-1964， 晶体管计算机</li>
<li>1964-1980， 集成电路计算机（计算机具备进入千家万户的条件；出现操作系统）</li>
<li>1980-至今， 超大规模集成电路计算机</li>
</ul>
<p>未来可能有：生物计算机， 量子计算机（腾讯量子实验室，阿里达摩院）<br>微型计算机的发展历史：从集成电路计算机开始，两个特点：受限于性能（单核到多核CPU）；摩尔定律（集成电路性能每18-24个月就提升一倍）</p>
<h3 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h3><ul>
<li>超级计算机，eg. 中大东校区的天河二号。 标记他们运算速度的单位是TFlop&#x2F;s</li>
<li>大型计算机。IBM占据很大的份额。阿里提出了“去I（IBM）O（Oracle）E（EMC）”行动，因为它们代表了高维护费用的存储系统，并且不够灵活。</li>
<li>迷你计算机。普通服务器。去IOE就是把大型机替换成普通服务器，eg. 阿里云</li>
<li>工作站。高端的通用微型计算机，类似于普通电脑但性能强劲</li>
<li>微型计算机，即个人计算机</li>
</ul>
<p>从构成的本质上来讲，个人计算机与前面的分类无异</p>
<h3 id="计算机的体系与结构"><a href="#计算机的体系与结构" class="headerlink" title="计算机的体系与结构"></a>计算机的体系与结构</h3><h4 id="冯诺伊曼体系"><a href="#冯诺伊曼体系" class="headerlink" title="冯诺伊曼体系"></a>冯诺伊曼体系</h4><ul>
<li>定义： 将程序指令和数据一起存储的计算机设计概念结构。结论： 存储程序指令，设计通用电路（因为早期计算机仅含固定用途程序，改变程序得更改结构、重新设计电路）</li>
<li>冯诺依曼体系建造的计算机一定要有： 存储器、 控制器、 运算器、 输入&#x2F;输出设备。如下图：<br><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.png"></li>
<li>瓶颈：CPU和存储器速率之间的问题无法调和（CPU处理速度很快，经常空转等待数据传输）</li>
</ul>
<h4 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h4><p>在冯诺依曼体系的基础上解决CPU与存储设备之间的性能差异问题<br><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png"></p>
<h3 id="计算机的层次与编程语言"><a href="#计算机的层次与编程语言" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h3><h4 id="程序翻译与程序解释"><a href="#程序翻译与程序解释" class="headerlink" title="程序翻译与程序解释"></a>程序翻译与程序解释</h4><p>程序翻译（编译）：使用编译器，把整个程序由高级语言L1（C++等）翻译成<strong>计算机语言</strong>L0（计算机能执行的，二进制等）<br>程序解释：把L1语言（Python，JS，PHP）的程序转变成使用L0语言实现另一个程序（翻译器），再L0解释器把目标程序执行。<br>Java是先编译再解释</p>
<h4 id="计算机的层次与编程语言-1"><a href="#计算机的层次与编程语言-1" class="headerlink" title="计算机的层次与编程语言"></a>计算机的层次与编程语言</h4><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B1%82%E6%AC%A1.png"></p>
<ul>
<li>硬件逻辑层： 门、触发器等逻辑电路组成。 属于电子工程的领域</li>
<li>微程序机器层： 编程语言是微指令集。 微指令所组成的微程序直接交由硬件执行</li>
<li>传统机器层： 编程语言是CPU指令集（机器指令）。编程语言和硬件是直接相关。<br>注： 一条机器指令对应一个微程序， 一个微程序对应一组微指令</li>
<li>操作系统层是在软件和硬件之间的适配层</li>
<li>汇编语言层。 编程语言是<strong>汇编语言</strong>（一种符号语言，其实可以理解为一种过渡态语言）。 汇编语言可以用汇编器翻译成可直接执行的机器语言</li>
<li>高级语言层。 <strong>高级语言</strong>（eg. Java等）</li>
</ul>
<h3 id="计算机的计算单位"><a href="#计算机的计算单位" class="headerlink" title="计算机的计算单位"></a>计算机的计算单位</h3><h4 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h4><p>用8个比特位bit（0或1）表示一个字节（Byte），后面就有kb，MB，GB，TB（都是1024倍关系）等。但是硬盘商是用1000做倍数关系，所以500G硬盘格式化后只有465G。</p>
<h4 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h4><ul>
<li>100M宽带，即是网络常用单位(Mbps)。 100M&#x2F;s &#x3D; 100Mbps &#x3D; 100Mbit&#x2F;s， 而 100Mbit&#x2F;s&#x3D;(100&#x2F;8)MB&#x2F;s&#x3D;12.5MB&#x2F;s。故100M宽带峰值下载速度只有12M&#x2F;s</li>
<li>CPU的速度一般体现为CPU的时钟频率（Hz）， 主流CPU是2GHz以上</li>
</ul>
<h3 id="计算机的字符与编码集"><a href="#计算机的字符与编码集" class="headerlink" title="计算机的字符与编码集"></a>计算机的字符与编码集</h3><h4 id="字符编码集的历史"><a href="#字符编码集的历史" class="headerlink" title="字符编码集的历史"></a>字符编码集的历史</h4><ul>
<li>ASCII码（读为 ask 2 码：用7个bits就可以完全表示ASCII码。包含了基本的字母，符号等</li>
<li>Extended ASCII码：改为8个bits。添加了常见的数学运算符，欧洲字符，表格符等，后来又有了国际化</li>
</ul>
<h4 id="中文编码集"><a href="#中文编码集" class="headerlink" title="中文编码集"></a>中文编码集</h4><ul>
<li>初始版：GB2312。收录了汉字和中文符号等。</li>
<li>GBK： 向下兼容GB2312，向上支持国际ISO标准。支持全部中日韩汉字。但是GBK和GB2312毕竟还是不能全球都用的。</li>
<li>兼容全球的字符集Unicode。 其定义了世界通用的符号集， 用UTF-*实现了编码。eg. UTF-8（编程推荐使用）以字节为单位对Unicode进行编码。</li>
</ul>
<h2 id="组成篇"><a href="#组成篇" class="headerlink" title="组成篇"></a>组成篇</h2><h3 id="计算机的总线"><a href="#计算机的总线" class="headerlink" title="计算机的总线"></a>计算机的总线</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>连接计算机不同设备的数据线。eg. 通用串行总线（USB）， PCI总线， ISA总线等<br><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF.png"></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>片内总线（芯片内部的总线）和系统总线（各设备之间的，分为 数据总线，地址总线和控制总线）</p>
<h4 id="总线的仲裁"><a href="#总线的仲裁" class="headerlink" title="总线的仲裁"></a>总线的仲裁</h4><p>原因：需要决定不同设备使用总线的优先顺序<br>方法：链式查询；计时器定时查询；独立请求（各有优缺点，详情略）</p>
<h3 id="计算机的输入输出设备（I-O设备）"><a href="#计算机的输入输出设备（I-O设备）" class="headerlink" title="计算机的输入输出设备（I&#x2F;O设备）"></a>计算机的输入输出设备（I&#x2F;O设备）</h3><h4 id="常见的输入输出设备"><a href="#常见的输入输出设备" class="headerlink" title="常见的输入输出设备"></a>常见的输入输出设备</h4><p>键盘，鼠标，扫描仪；显示器，打印机，投影仪</p>
<h4 id="输入输出接口的通用设计"><a href="#输入输出接口的通用设计" class="headerlink" title="输入输出接口的通用设计"></a>输入输出接口的通用设计</h4><p>数据线， 状态线， 命令线，设备选择线</p>
<h4 id="CPU与IO设备的通信"><a href="#CPU与IO设备的通信" class="headerlink" title="CPU与IO设备的通信"></a>CPU与IO设备的通信</h4><p>注意：CPU速度与IO设备速度不一致，CPU快得多<br>方式：程序中断； DMA（直接存储器访问）</p>
<h3 id="计算机存储器"><a href="#计算机存储器" class="headerlink" title="计算机存储器"></a>计算机存储器</h3><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB1.png"><br><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB2.png"></p>
<h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><p>读写速度（eg. 5400转）和存储容量（eg.1T）都会影响存储器的价格，所有有每比特位置价格的概念<br>存储器的层次结构：</p>
<ul>
<li>缓存。速度快价格高， 解决主存速度不足的问题。是在CPU与驻村之间增加一层速度快（容量小）的Cache。 局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</li>
<li>主存。中等，eg. 内存条</li>
<li>辅存。速度慢价格低， 解决主存容量不足的问题。eg. 硬盘</li>
</ul>
<p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8.png"></p>
<h4 id="计算机的主存储器"><a href="#计算机的主存储器" class="headerlink" title="计算机的主存储器"></a>计算机的主存储器</h4><p>计算机断电，内存数据丢失。这是因为内存条是用RAM，通过电容存储数据，必须隔一段时间刷新一次（有电才能刷新）<br>对32位系统，地址总线有32位，支持的内存最大为2^32&#x3D;4 * 2^30 &#x3D; 4GB ; 64为则大大提高，为2^34 GB<br>PS：硬盘有固态硬盘（SSD 盘，新式硬盘）、机械硬盘（HDD 传统硬盘）、混合硬盘（HHD 一块基于传统机械硬盘诞生出来的新硬盘）。SSD采用闪存颗粒来存储，HDD采用磁性碟片来存储，混合硬盘(HHD: Hybrid Hard Disk)是把磁性硬盘和闪存集成到一起的一种硬盘</p>
<h4 id="计算机的辅助存储器"><a href="#计算机的辅助存储器" class="headerlink" title="计算机的辅助存储器"></a>计算机的辅助存储器</h4><p>计算机断电， 磁盘数据不会丢失。因为磁盘是盘片（ 表面是可磁化的硬磁特性材料）和读写磁头组成（ 移动磁头径向运动读取磁道信息）。磁盘的读取算法忽略没记</p>
<h4 id="计算机的高速缓存"><a href="#计算机的高速缓存" class="headerlink" title="计算机的高速缓存"></a>计算机的高速缓存</h4><p>对于主存，有：</p>
<ul>
<li>字： 是指存放在一个存储单元中的二进制代码组合（一个字有32位就是一个字占32个bit的意思）。字的地址包含两个部分： 前m位指定字块的地址（块地址）； 后b位指定字在字块中的地址（块内地址），如下图。字块是由字构成的（eg. 一个字块共B个字）</li>
<li>字块： 存储在连续的存储单元中而被看作是一个单元的一组字。主存是由字块构成的（eg. 主存共M个字块）。主存内的总字数为B*M<br><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%97.png"> 有2^m &#x3D; M ; 2^b &#x3D; B</li>
</ul>
<p>问题：假设主存用户空间容量为4G，字块大小为4M，字长为32位，则对于字<br>地址中的块地址m和块内地址b的位数，至少应该是多少？<br><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%A2%98.png"></p>
<h5 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h5><p>对于高速缓存，原理类似于主存<br>衡量高速缓存性能：命中率、访问效率和平均访问时间。具体算法略（大概就是CPU要的数据刚好就在高速缓存中，而不需要高速缓存区主存拿）</p>
<h5 id="高速缓存的替换策略"><a href="#高速缓存的替换策略" class="headerlink" title="高速缓存的替换策略"></a>高速缓存的替换策略</h5><p>高速缓存的替换时机，怎么使得CPU要的数据尽可能在高速缓存中，用了几种算法，详情略</p>
<h3 id="计算机的指令系统"><a href="#计算机的指令系统" class="headerlink" title="计算机的指令系统"></a>计算机的指令系统</h3><h4 id="机器指令的形式"><a href="#机器指令的形式" class="headerlink" title="机器指令的形式"></a>机器指令的形式</h4><p>机器指令主要由两部分组成：</p>
<ul>
<li>操作码： 操作码指明指令所要完成的操作； 操作码的位数反映了机器的操作种类（eg. 8位则是2^8 &#x3D; 256 种操作）</li>
<li>地址码： 地址码直接给出操作数或者操作数的地址。 分三地址指令、二地址指令和一地址指令</li>
</ul>
<h4 id="机器指令的操作类型"><a href="#机器指令的操作类型" class="headerlink" title="机器指令的操作类型"></a>机器指令的操作类型</h4><p>数据传输类型： 存在与寄存器之间、寄存器与存储单元、存储单元之间传送。 数据读写、交换地址数据、清零置一等操作<br>算术逻辑操作： 操作数之间的加减乘除、位运算等<br>移位操作： 完成数据在算术逻辑单元的必要操作<br>控制指令： 等待指令、停机指令、空操作指令、中断指令等</p>
<h4 id="机器指令的寻址方式"><a href="#机器指令的寻址方式" class="headerlink" title="机器指令的寻址方式"></a>机器指令的寻址方式</h4><p>指令寻址：顺序寻址，跳跃寻址<br>数据寻址：立即寻址，直接寻址，间接寻址</p>
<h3 id="计算机的控制器和运算器"><a href="#计算机的控制器和运算器" class="headerlink" title="计算机的控制器和运算器"></a>计算机的控制器和运算器</h3><p>CPU由控制器，运算器，高速缓存等组成。<br>控制器是协调和控制计算机运行的。由程序计数器，时序发生器，指令译码器，各种类型的寄存器，总线所组成<br>运算器是用来进行数据运算加工的。由数据缓冲器，ALU，通用寄存器，状态寄存器，总线所组成</p>
<h4 id="计算机指令的执行过程"><a href="#计算机指令的执行过程" class="headerlink" title="计算机指令的执行过程"></a>计算机指令的执行过程</h4><ol>
<li>取指令： 从缓存取指令； 送到指令寄存器</li>
<li>分析指令： 指令译码器译码； 发出控制信号； 程序计数器+1</li>
<li>执行指令： 装载数据到寄存器； ALU处理数据； 记录运算状态； 送出运算结果</li>
</ol>
<h4 id="CPU的流水线设计"><a href="#CPU的流水线设计" class="headerlink" title="CPU的流水线设计"></a>CPU的流水线设计</h4><p>即可以同时对多条指令进行流水处理，而不是串行处理<br><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU.png"></p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://coding.imooc.com/class/355.html">慕课网</a><br>《计算机科学导论》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" data-id="clmniym8f005ibb87dmfddl2y" data-title="计算机组成原理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-正则表达式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2019-10-16T08:50:21.000Z" itemprop="datePublished">2019-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic-knowledge/">Basic knowledge</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>&#x2F;pattern&#x2F;flags</p>
<h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><ul>
<li><strong>g</strong>：全局匹配;找到所有匹配，而不是在第一个匹配后停止</li>
<li>i：忽略大小写</li>
<li>m：多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处</li>
<li>…</li>
</ul>
<h4 id="常用字符类别"><a href="#常用字符类别" class="headerlink" title="常用字符类别"></a>常用字符类别</h4><ul>
<li>. ：匹配任意单个字符。例如，&#x2F;.y&#x2F; 匹配 “yes make my day” 中的 “my” 和 “ay”，但是不匹配 “yes”</li>
<li>\d ：匹配任意阿拉伯数字。等价于<code>[0-9]</code>。例如，<code>/\d/</code> 或 <code>/[0-9]/</code> 匹配 “B2 is the suite number.” 中的 ‘2’</li>
<li>\D ：匹配任意一个不是阿拉伯数字的字符。等价于<code>[^0-9]</code>。例如，<code>/\D/</code> 或 <code>/[^0-9]/</code> 匹配 “B2 is the suite number.” 中的 ‘B’</li>
<li>\w ：匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。例如，&#x2F;\w&#x2F; 匹配 “apple” 中的 ‘a’，”$5.28” 中的 ‘5’ 和 “3D” 中的 ‘3’</li>
<li>\W ：匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。例如，&#x2F;\W&#x2F; 匹配 “50%” 中的 ‘%’</li>
<li>\s ：匹配一个空白符，包括空格、制表符、换页符、换行符</li>
<li>\S ：匹配一个非空白符</li>
<li>\ ：按照字面意义解释。例如，* 是一个特殊字符，表示匹配某个字符 0 或多次，如 <code>/a*/</code> 意味着 0 或多个 “a”。 为了匹配字面意义上的 * ，在它前面加上一个反斜杠，例如，<code>/a\*/</code>匹配 ‘a*’</li>
</ul>
<h4 id="字符集合"><a href="#字符集合" class="headerlink" title="字符集合"></a>字符集合</h4><ul>
<li><code>[xyz]</code> : 字符集合，匹配集合中的任意一个字符（可以理解为多个 | 连用）。例如，<code>[abcd]</code> 等价于 <code>[a-d]</code>，匹配”brisket”中的’b’和”chop”中的’c’.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想匹配字符串&quot;Let&#x27;s take LeetCode contest&quot; 中的 &quot; Let&#x27;s &quot;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Let&#x27;s take LeetCode contest&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/\w+/</span>)[<span class="number">0</span>])  <span class="comment">// Let</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/[\w&#x27;]+/</span>)[<span class="number">0</span>])  <span class="comment">// Let&#x27;s </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/(\w|&#x27;)+/</span>)[<span class="number">0</span>])  <span class="comment">// Let&#x27;s </span></span><br></pre></td></tr></table></figure></li>
<li><code>[^xyz]</code> : 反字符集合</li>
</ul>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><ul>
<li>^ : 匹配输入开始。例如，&#x2F;^A&#x2F; 不匹配 “an A” 中的 “A”，但匹配 “An A” 中的 “A”</li>
<li>$ : 匹配输入结尾。例如，&#x2F;t$&#x2F; 不匹配 “eater” 中的 “t”，但匹配 “eat” 中的 “t”</li>
<li>\b : 匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。例如，&#x2F;\bno&#x2F; 匹配 “at noon” 中的 “no”，&#x2F;ly\b&#x2F; 匹配 “possibly yesterday.” 中的 “ly”</li>
<li>\B : 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间.例如，&#x2F;\Bon&#x2F; 匹配 “at noon” 中的 “on”，&#x2F;ye\B&#x2F; 匹配 “possibly yesterday.” 中的 “ye”</li>
</ul>
<h4 id="分组和反向引用（重要）"><a href="#分组和反向引用（重要）" class="headerlink" title="分组和反向引用（重要）"></a>分组和反向引用（重要）</h4><ul>
<li>(x) ：捕获括号，匹配 x 并且捕获匹配项，可以说有<strong>捕获</strong>的功能也有<strong>“边界”</strong>的功能。例如，<code>/(foo)/</code> 匹配且捕获 “foo bar.” 中的 “foo”。被匹配的子字符串可以在结果数组的元素 <code>[1], ..., [n]</code> 中找到，或在被定义的 RegExp 对象的属性 <code>$1, ..., $9</code> 中找到，这种$的语法一般只在replace中用.<br><strong>PS</strong>：注意是从$1开始的，而不是$0<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;John Smith&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = re.<span class="title function_">exec</span>(str)</span><br><span class="line"><span class="keyword">var</span> newstr = str.<span class="title function_">replace</span>(re, <span class="string">&quot;$2, $1&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">0</span>]);  <span class="comment">// John Smith</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newstr);  <span class="comment">// Smith, John</span></span><br></pre></td></tr></table></figure></li>
<li>\n ：n是一个正整数。反向引用，向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串，<strong>个人理解</strong>（1）是用在有捕获括号的时候，定义$是指向哪个捕获项，就算不写\1也会默认$1是捕获的第一项；（2）可以用这个\1代表第一个捕获项，做一些事，eg. \1+<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;abcabcabcabc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\w+)\1+$/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(s))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><code>(?:x)</code> ：匹配 x 不会捕获匹配项。这被称为非捕获括号（non-capturing parentheses）。匹配项不能够从结果数组的元素 <code>[1], ..., [n]</code> 或已被定义的 RegExp 对象的属性 <code>$1, ..., $9</code> 再次访问到。</li>
</ul>
<h4 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h4><ul>
<li>x* ：匹配前面的模式 x 0 或多次。例如，&#x2F;bo*&#x2F; 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”</li>
<li>x+ ：匹配前面的模式 x 1 或多次</li>
<li><code>x*?</code> ：像上面的 * 和 + 一样匹配前面的模式 x，然而匹配是<strong>最小可能匹配</strong>。例如，&#x2F;“.*?”&#x2F; 匹配 ‘“foo” “bar”‘ 中的 ‘“foo”‘，而 * 后面没有 ? 时匹配 ‘“foo” “bar”</li>
<li>x? : 匹配前面的模式 x 0 或 1 次。例如，&#x2F;e?le?&#x2F; 匹配 “angel” 中的 “el”，”angle” 中的 “le”</li>
<li>x(?&#x3D;y) ：只有当 x 后面紧跟着 y 时，才匹配 x。 例如，&#x2F;Jack(?&#x3D;Sprat)&#x2F; 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 时，才会匹配它。&#x2F;Jack(?&#x3D;Sprat|Frost)&#x2F; 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 或 ‘Frost’ 时，才会匹配它。然而，’Sprat’ 或 ‘Frost’ 都不是匹配结果的一部分</li>
<li>x(?!y) ：只有当 x 后面不是紧跟着 y 时，才匹配 x</li>
<li>x|y ：匹配x或y</li>
</ul>
<h4 id="在线正则表达式测试"><a href="#在线正则表达式测试" class="headerlink" title="在线正则表达式测试"></a><a target="_blank" rel="noopener" href="http://tool.oschina.net/regex/">在线正则表达式测试</a></h4><h4 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h4><ul>
<li>对RegExp的方法<ul>
<li>exec()  一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。语法是 <em>regexp</em>.exec(<em>string</em>)</li>
<li>test()  一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。用于只想知道目标字符串与某个模式是否匹配而不想知文本内容。语法是 <em>regexp</em>.test(<em>string</em>)</li>
</ul>
</li>
<li>对String的方法<ul>
<li>match()  和exex()其实一毛一样，但语法是<em>string</em>.test(<em>regexp</em>)。一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null</li>
<li>matchAll  一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）</li>
<li>search	一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1</li>
<li>replace	一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串</li>
<li>split	一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法</li>
</ul>
</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="clmniym88004ubb870k8vatlm" data-title="正则表达式" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JS功能与原理的实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/15/JS%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2019-10-15T08:50:21.000Z" itemprop="datePublished">2019-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/15/JS%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/">JS功能与原理的实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="JS-原理的实现"><a href="#JS-原理的实现" class="headerlink" title="JS 原理的实现"></a>JS 原理的实现</h2><h3 id="实现一个-Promise"><a href="#实现一个-Promise" class="headerlink" title="实现一个 Promise()"></a>实现一个 Promise()</h3><p>Promise 的特点：</p>
<ul>
<li>new Promise 时需要传递一个函数 fn 作为执行器（执行器会立刻执行）</li>
<li>执行器中传递了两个参数：resolve 成功的函数、reject 失败的函数（他们调用时可以接受任何值的参数 value）</li>
<li>promise 状态只能从 pending 态转到 resolved 或者 rejected，<strong>如果状态发生改变执行相应缓存队列中的任务</strong></li>
<li>promise 实例,每个实例都有一个 then 方法，这个方法传递两个参数，一个是成功回调 onfulfilled,另一个是失败回调 onrejected</li>
<li>promise 实例调用 then 时，会判断当前状态，如果 pending，就…；如果 resolved，就让 onfulfilled 执行；如果 rejectd，就 onrejected 执行</li>
<li>promise 中可以同一个实例 then 多次,如果状态是 pengding 需要将函数存放起来 等待状态确定后 在依次将对应的函数执行 (发布订阅)</li>
</ul>
<p>基于上述特点，实现的 Promise 如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// value 变量用于保存 resolve 或者 reject 中传入的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  <span class="comment">// 用于保存 then 中的回调（可能有多个所以是数组），因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">resolvedAry</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">rejectedAry</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先两个函数都得判断当前状态是否为等待中</span></span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      that.<span class="property">status</span> === <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">      that.<span class="property">value</span> = value;</span><br><span class="line">      <span class="comment">// 遍历回调数组并执行</span></span><br><span class="line">      that.<span class="property">resolvedAry</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      that.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      that.<span class="property">value</span> = value;</span><br><span class="line">      that.<span class="property">rejectedAry</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">value</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后我们来实现较为复杂的 then 函数。接收两个回调函数为参数</span></span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onfulfilled, onrejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断两个参数是否为函数类型</span></span><br><span class="line">  onfulfilled = <span class="keyword">typeof</span> onfulfilled === <span class="string">&quot;function&quot;</span> ? onfulfilled : <span class="function"><span class="params">f</span> =&gt;</span> f;</span><br><span class="line">  onrejected =</span><br><span class="line">    <span class="keyword">typeof</span> onrejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onrejected</span><br><span class="line">      : <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolvedAry</span>.<span class="title function_">push</span>(onfulfilled);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectedAry</span>.<span class="title function_">push</span>(onrejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">onfulfilled</span>(that.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">onrejected</span>(that.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all()"></a>实现Promise.all()</h3><p>Promise.all 接收一个 promise 对象的数组作为参数，当这个数组里的所有 promise 对象全部变为resolve或 有 reject 状态出现的时候，它才会去调用 .then 方法,它们是并发执行的。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p1 = Promise.resolve(1),</span><br><span class="line">    p2 = Promise.resolve(2),</span><br><span class="line">    p3 = Promise.resolve(3); // 若任一 Promise 状态是reject，则无法执行 .then</span><br><span class="line">Promise.all([p1, p2, p3]).then(function (results) &#123;</span><br><span class="line">    console.log(results);  // [1, 2, 3]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>总结 promise.all 的特点</p>
<ul>
<li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象</li>
<li>如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</li>
<li>如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</li>
<li>只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象</li>
</ul>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function promiseAll(promises) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    if (!isArray(promises)) &#123;</span><br><span class="line">      return reject(new TypeError(&#x27;arguments must be an array&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">    var resolvedCounter = 0;</span><br><span class="line">    var promiseNum = promises.length;</span><br><span class="line">    var resolvedValues = new Array(promiseNum);</span><br><span class="line">    for (var i = 0; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      (function(i) &#123;</span><br><span class="line">        Promise.resolve(promises[i]).then(function(value) &#123;</span><br><span class="line">          resolvedCounter++</span><br><span class="line">          resolvedValues[i] = value</span><br><span class="line">          if (resolvedCounter == promiseNum) &#123;</span><br><span class="line">            return resolve(resolvedValues)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, function(reason) &#123;</span><br><span class="line">          return reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手写实现-call-apply-bind"><a href="#手写实现-call-apply-bind" class="headerlink" title="手写实现 call(), apply(), bind()"></a>手写实现 call(), apply(), bind()</h3><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><ul>
<li>首先 context 为可选参数，如果不传的话默认上下文为 window</li>
<li>接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数</li>
<li>因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li>
<li>然后调用函数并将对象上的函数删除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>类似，区别在于对参数的处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 处理参数和 call 有区别</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式</p>
<ul>
<li>对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code></li>
<li>通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this。（似乎这种 new 的用法很少见）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">_this</span>(...args, ...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接调用的情况</span></span><br><span class="line">    <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 可以正确的判断对象的类型，其内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。实现原理如下：</p>
<ul>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">muInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  left = left.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (prototype === left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    left = left.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手写实现-new"><a href="#手写实现-new" class="headerlink" title="手写实现 new"></a>手写实现 new</h3><p>在调用 new 的过程中会发生四件事情:</p>
<ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this(使用构造函数的 this)</li>
<li>返回新对象（原始类型的话忽略，如果是引用类型的话就返回这个对象）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">myNew</span>() = <span class="keyword">function</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// func是new后面的那个构造函数</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  obj.<span class="property">_proto_</span> = func.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">let</span> result = func.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="手写实现-Object-create"><a href="#手写实现-Object-create" class="headerlink" title="手写实现 Object.create()"></a>手写实现 Object.create()</h3><p>Object.create()方法创建一个新对象，使用参数对象（而不是参数对象.prtototype）来提供新创建的对象的<code>__proto__</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mycreate</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 +0.2 !&#x3D;&#x3D; 0.3"></a>0.1 +0.2 !&#x3D;&#x3D; 0.3</h3><p>对于纯小数来说，十进制的 0.375 会被存储为： 0.011 其代表 (1&#x2F;2)^2 + (1&#x2F;2)^3 &#x3D; 1&#x2F;4 + 1&#x2F;8 &#x3D; 0.375<br>但是对 0.1 这种数值来说，算下来是 0.000110011… 由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。JS 采用 IEEE 754 双精度版本（64 位）浮点数标准，也是只能取得一个近似值。除了那些能表示成 (x&#x2F;2)^n 的数可以被精确表示以外，其余小数都是以近似值得方式存在的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1000000000000001</span>);</span><br><span class="line"><span class="comment">// 0.1000000000000001 (中间14个0，会打印出它本身)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.10000000000000001</span>);</span><br><span class="line"><span class="comment">// 0.1 (中间15个0，js会认为这两个值足够接近，所以会显示0.1)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.100000000000000002</span> === <span class="number">0.1</span>; <span class="comment">// true （16个0）</span></span><br><span class="line"><span class="number">0.200000000000000002</span> === <span class="number">0.2</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.30000000000000004</span>; <span class="comment">// true。此时对于JS来说，其不够近似于0.3，于是就出现了0.1 + 0.2 != 0.3 这个现象</span></span><br></pre></td></tr></table></figure>

<p><strong>解决：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).<span class="title function_">toFixed</span>(<span class="number">10</span>)) === <span class="number">0.3</span>; <span class="comment">// true  toFixed()将数值格式化为字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="双向数据绑定实现原理"><a href="#双向数据绑定实现原理" class="headerlink" title="双向数据绑定实现原理"></a>双向数据绑定实现原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向数据绑定</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;span&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据劫持</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;text&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取数据&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据更新&quot;</span>);</span><br><span class="line">    input.<span class="property">value</span> = newVal; <span class="comment">// 要双向绑定所以有这句</span></span><br><span class="line">    span.<span class="property">innerHTML</span> = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  obj.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="JS-功能的实现"><a href="#JS-功能的实现" class="headerlink" title="JS 功能的实现"></a>JS 功能的实现</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">100</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>sort() + reduce</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">sort</span>().<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (acc.<span class="property">length</span> === <span class="number">0</span> || curr !== acc[acc.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">    acc.<span class="title function_">push</span>(curr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<ul>
<li>Array.from(new Set(arr))</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br></pre></td></tr></table></figure>

<ul>
<li>for…of + Object (性能最优）。利用对象的属性不会重复这一特性，校验数组元素是否重复</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line">obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj[i]) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(i);</span><br><span class="line">    obj[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = (arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, , <span class="string">&quot;tset&quot;</span>]]], <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>Array.prototype.flat()。参数是要提取的嵌套数组的深度（数字），默认值是 1；也可以直接写 Infinity 作为参数。但是会移除数组中的空项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>); <span class="comment">// [1, 2, 3, 4, 5, &quot;tset&quot;, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>reduce 写一个递归函数。似乎也会移除空项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFlat</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(curr) ? <span class="title function_">myFlat</span>(curr) : curr),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, &quot;tset&quot;, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>扩展运算符 + Array.prototype.some() 这里的 isArray 用法稍微有点特殊。并且空项不会被移除，会保留为<code>undefined</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="title class_">Array</span>.<span class="property">isArray</span>)) &#123;</span><br><span class="line">  arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数的-arguement-怎么转数组"><a href="#函数的-arguement-怎么转数组" class="headerlink" title="函数的 arguement 怎么转数组"></a>函数的 arguement 怎么转数组</h3><p>Array.from(), 扩展运算符</p>
<h3 id="for…in-for…of-forEach"><a href="#for…in-for…of-forEach" class="headerlink" title="for…in, for…of, forEach()"></a>for…in, for…of, forEach()</h3><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p>一般用来遍历对象。有几个缺点：</p>
<ul>
<li>for…in 会遍历手动添加的原型链上的键。比如你自己写个<code>Object.prototype.test = function &#123; xxx &#125;</code>，是能遍历到这个<code>test</code>属性的</li>
<li>用来遍历数组的时候是遍历数组的键名（index），并且这个 index 是字符串</li>
<li>某些情况下，for…in 循环会以任意顺序遍历键名</li>
</ul>
<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><ul>
<li>遍历数组得到数组的 value</li>
<li><code>for (let [k, v] of Object.entries(obj)) &#123; &#125;</code> 用来遍历对象，能获取对象的键和键值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jacle&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;student&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;jacle&quot;</span>, <span class="number">22</span>, <span class="string">&quot;student&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&quot;:&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>遍历数组，问题是无法用 break，return 跳出循环<br>如何中断 forEach 循环：</p>
<ul>
<li>使用 try 监视代码块，在需要中断的地方抛出异常</li>
<li>官方推荐方法（替换方法）：用 every 和 some 替代 forEach 函数。every 在碰到 return false 的时候，中止循环。some 在碰到 return ture 的时候，中止循环</li>
</ul>
<h3 id="数组中是否包含某个值"><a href="#数组中是否包含某个值" class="headerlink" title="数组中是否包含某个值"></a>数组中是否包含某个值</h3><ul>
<li><code>Array.prototype.indexOf(值)</code>。返回 index 或 -1 。该方法也可用于 String</li>
<li><code>Array.prototype.includes(值)</code>。返回布尔值。该方法也可用于 String</li>
<li><code>Array.prototype.find(callback[,thisVal])</code>。返回数组中满足条件的<strong>第一个元素的值</strong>，如果没有，返回 undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">100</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.findeIndex(callback[,thisArg])</code>。返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1]</li>
</ul>
<h3 id="对象按规则排序"><a href="#对象按规则排序" class="headerlink" title="对象按规则排序"></a>对象按规则排序</h3><p>有一个数组，里面都是对象，现在要针对对象中的某一个 key 进行排序，顺序是已给定的数组。<br>比如原数组为<code>[&#123;a:&#39;ww&#39;&#125;,&#123;a:&#39;ff&#39;&#125;,&#123;a:&#39;pe&#39;&#125;]</code>，<br>顺序是<code>[&#123;ww:1&#125;,&#123;pe:3&#125;,&#123;hf:2&#125;,&#123;oo:4&#125;,&#123;ff:5&#125;]</code><br>那么输出是 <code>[&#123;a:&#39;ww&#39;&#125;,&#123;a:&#39;pe&#39;&#125;,&#123;a:&#39;ff&#39;&#125;]</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objarr = [&#123; <span class="attr">a</span>: <span class="string">&quot;ww&quot;</span> &#125;, &#123; <span class="attr">a</span>: <span class="string">&quot;ff&quot;</span> &#125;, &#123; <span class="attr">a</span>: <span class="string">&quot;pe&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> rulearr = [&#123; <span class="attr">ww</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">pe</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">hf</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">oo</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">ff</span>: <span class="number">5</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力解决</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortByRule</span>(<span class="params">objarr, key, rulearr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">ResultArr</span> = [];</span><br><span class="line">  rulearr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前的value和规则的位次</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(item)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> order = item[value];</span><br><span class="line">    <span class="comment">//找到对应的obj放入对应位次的位置</span></span><br><span class="line">    <span class="title class_">ResultArr</span>[order] = objarr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item[key] === value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//去掉那些为空的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ResultArr</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="n-到-m-范围的随机整数数"><a href="#n-到-m-范围的随机整数数" class="headerlink" title="n 到 m 范围的随机整数数"></a>n 到 m 范围的随机整数数</h3><ul>
<li>Math.random()生成[0, 1)的数，所以</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>() * m; <span class="comment">// 生成&#123;0,m)的数；</span></span><br></pre></td></tr></table></figure>

<ul>
<li>要整数有向下取整 Math.floor()，向上 Math.ceil()。所以[1, m]的数是</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m); <span class="comment">// [1, m]的数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m) + <span class="number">1</span>; <span class="comment">// [1, m]的数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m); <span class="comment">// [0, m-1]的数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所以希望生成[n, m]的随机数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>) + min);</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝与浅拷贝的实现"><a href="#深拷贝与浅拷贝的实现" class="headerlink" title="深拷贝与浅拷贝的实现"></a>深拷贝与浅拷贝的实现</h3><h4 id="赋值（-），浅拷贝与深拷贝的区别"><a href="#赋值（-），浅拷贝与深拷贝的区别" class="headerlink" title="赋值（&#x3D;），浅拷贝与深拷贝的区别"></a>赋值（&#x3D;），浅拷贝与深拷贝的区别</h4><p><img src="/img/JS%E5%92%8CES6/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.png">  </p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据</p>
<ul>
<li>Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，是浅拷贝</li>
</ul>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。Object.assign(target, source)。直接用 Object.assign(target, source) 这种用法就能更新target对象。当然也能用来赋值新对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a);</span><br><span class="line">a.<span class="property">age</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>展开运算符 …</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;;</span><br><span class="line">a.<span class="property">age</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数据的浅拷贝还有 <code>let arr2 = [].concat(arr1)</code> 和 <code>let arr2 = arr1.slice()</code></li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>对对象以及对象的所有子对象进行拷贝<br>通过 JSON.parse(JSON.stringify(object))来实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">jobs</span>: &#123;</span><br><span class="line">    <span class="attr">first</span>: <span class="string">&quot;FE&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a));</span><br><span class="line">a.<span class="property">jobs</span>.<span class="property">first</span> = <span class="string">&quot;native&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">jobs</span>.<span class="property">first</span>); <span class="comment">// FE</span></span><br></pre></td></tr></table></figure>

<p>局限性 ：会忽略 undefined；会忽略 symbol；不能序列化函数；不能解决循环引用的对象<br>自己实现一个深拷贝的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断传进来的obj是否是引用类型</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isObj</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> o === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> o === <span class="string">&quot;function&quot;</span>) &amp; (o !== <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断传进来的obj这个引用类型是对象还是数组，按正确的方式浅拷贝一次</span></span><br><span class="line">  <span class="keyword">let</span> newobj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [...obj] : &#123; ...obj &#125;;</span><br><span class="line">  <span class="comment">//  对新对象的key遍历，原来obj的key是基本类型还是引用类型，基本类型就直接复制，引用类型就深拷贝一次</span></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(newobj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newobj[key] = <span class="title function_">isObj</span>(obj[key]) ? <span class="title function_">deepClone</span>(obj[key]) : obj[key];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间戳的获取"><a href="#时间戳的获取" class="headerlink" title="时间戳的获取"></a>时间戳的获取</h4><p>时间戳是指格林威治时间1970年01月01日00时00分00秒起至当下的总秒数。JS中拿到时间戳：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一种方法：</span><br><span class="line">var timestamp = Date.parse(new Date());</span><br><span class="line"></span><br><span class="line">第二种方法：</span><br><span class="line">var timestamp = (new Date()).valueOf();</span><br><span class="line"></span><br><span class="line">第三种方法：</span><br><span class="line">var timestamp = new Date().getTime()；</span><br><span class="line"> </span><br><span class="line">第四种方法：</span><br><span class="line">var timestamp = Date.now();</span><br></pre></td></tr></table></figure>

<p>参考资料<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010765655">实现 JavaScript 异步方法 Promise.all</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/15/JS%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-id="clmniym6w000xbb8762b2157l" data-title="JS功能与原理的实现" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-场景实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/15/%E5%9C%BA%E6%99%AF%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2019-10-15T08:50:21.000Z" itemprop="datePublished">2019-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/15/%E5%9C%BA%E6%99%AF%E5%AE%9E%E7%8E%B0/">场景实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h1><h2 id="高度始终是宽度的-50-的盒子"><a href="#高度始终是宽度的-50-的盒子" class="headerlink" title="高度始终是宽度的 50%的盒子"></a>高度始终是宽度的 50%的盒子</h2><p>一个 div 垂直居中；其距离屏幕左右两边各 10px；其高度始终是宽度的 50%<br>div 中有文本’A’；其 font—size:20px；文本水平垂直居中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">width</span>: <span class="title function_">calc</span>(100vw - 20px);</span><br><span class="line"><span class="attr">height</span>: <span class="title function_">calc</span>(50vw - 10px);</span><br></pre></td></tr></table></figure>

<h2 id="上中下的-flex-布局，上下定高中间自适应"><a href="#上中下的-flex-布局，上下定高中间自适应" class="headerlink" title="上中下的 flex 布局，上下定高中间自适应"></a>上中下的 flex 布局，上下定高中间自适应</h2><ul>
<li>父盒子写 display:flex; flex-direction: colum; 子盒子写 flex: 1</li>
<li>父盒子写 height: calc(100vh - xx px) 或直接 100vh</li>
</ul>
<h2 id="实现一个图片容器"><a href="#实现一个图片容器" class="headerlink" title="实现一个图片容器"></a>实现一个图片容器</h2><p>要求：</p>
<ul>
<li>图片宽度大于等于容器宽度时，要按容器宽度等比缩放图片，并垂直居中显示</li>
<li>图片高度大于等于容器高度时，要按容器高度等比缩放图片，并水平居中显示</li>
<li>图片宽高均小于等于容器宽高时，要按图片宽高显示并水平和垂直居中</li>
</ul>
<h3 id="不完美的方法一"><a href="#不完美的方法一" class="headerlink" title="不完美的方法一"></a>不完美的方法一</h3><p>利用 background 可以实现前两个要求，但是无法实现第三个要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.div &#123;</span><br><span class="line">  height: 400px;</span><br><span class="line">  width: 700px;</span><br><span class="line">  border: 1px solid black;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: contain;</span><br><span class="line">  background-position: center;</span><br><span class="line">  background-image: url(&#x27;https://cdn.segmentfault.com/v-5e7dd7fe/global/img/user-64.png&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完美实现的方法二"><a href="#完美实现的方法二" class="headerlink" title="完美实现的方法二"></a>完美实现的方法二</h3><p>flex布局实现垂直水平居中，图片设置 max-width 和 max-height 为 100% …好容易…</p>
<h2 id="CSS-实现九宫格布局"><a href="#CSS-实现九宫格布局" class="headerlink" title="CSS 实现九宫格布局"></a>CSS 实现九宫格布局</h2><p>要求：骰子的一面。hover 的时候数字的边框变红</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.num</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: blue solid <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* border不重叠 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: -<span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.num</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-color</span>: red;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 由于设置了负边距，得相对定位才能在hover时显示完整边框 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="做一个-todolist"><a href="#做一个-todolist" class="headerlink" title="做一个 todolist"></a>做一个 todolist</h2><p>要求：回车键后能把内容添加到 list 中；list 中点 x 能删除</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>TodoList<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;list&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    input.<span class="title function_">addEventListener</span>(<span class="string">&quot;keydown&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// keyCode 一定得区分大小写。添加部分</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (e.<span class="property">keyCode</span> === <span class="number">13</span> &amp;&amp; input.<span class="property">value</span> !== <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        ul.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">        li.<span class="property">innerHTML</span> = <span class="string">`&lt;span class=&quot;item&quot;&gt;<span class="subst">$&#123;input.value&#125;</span>&lt;/span&gt;&lt;span id=&quot;x&quot;&gt;x&lt;/span&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">        input.<span class="property">value</span> = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 移除部分</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> x = li.<span class="property">children</span>[<span class="number">1</span>];</span></span><br><span class="line"><span class="language-javascript">        x.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          li.<span class="title function_">remove</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="上传文件不用刷新页面的-JS-代码"><a href="#上传文件不用刷新页面的-JS-代码" class="headerlink" title="上传文件不用刷新页面的 JS 代码"></a>上传文件不用刷新页面的 JS 代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> file = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 用formdata</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">      formdata.<span class="title function_">append</span>(<span class="string">&quot;flie&quot;</span>, file.<span class="property">files</span>[<span class="number">0</span>]);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">fetch</span>(<span class="string">&quot;/&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">body</span>: formdata</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Success:&quot;</span>, data);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error:&quot;</span>, err);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="上传文件读取文件名、大小、内容"><a href="#上传文件读取文件名、大小、内容" class="headerlink" title="上传文件读取文件名、大小、内容"></a>上传文件读取文件名、大小、内容</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> file = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="comment">// 选择文件后触发</span></span><br><span class="line">file.<span class="property">onchange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>).<span class="property">innerHTML</span> = file.<span class="property">files</span>[<span class="number">0</span>].<span class="property">name</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;size&quot;</span>).<span class="property">innerHTML</span> = file.<span class="property">files</span>[<span class="number">0</span>].<span class="property">size</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;type&quot;</span>).<span class="property">innerHTML</span> = file.<span class="property">files</span>[<span class="number">0</span>].<span class="property">type</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 读取的过程就相当于 加载过程，读取完会触发onload事件</span></span><br><span class="line">    reader.<span class="property">onload</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 读取结果 base64位数据  表示图片</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#img&quot;</span>).<span class="property">src</span> = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实现鼠标拖拽-DOM"><a href="#实现鼠标拖拽-DOM" class="headerlink" title="实现鼠标拖拽 DOM"></a>实现鼠标拖拽 DOM</h2><p>见另一篇博客</p>
<h2 id="实现轮播"><a href="#实现轮播" class="headerlink" title="实现轮播"></a>实现轮播</h2><p>这篇<a target="_blank" rel="noopener" href="https://www.cnblogs.com/linqb/p/9375197.html">博文</a>总结的不错<br>需求：</p>
<ol>
<li>鼠标移入轮播图时左右两边显示上一页下一页按钮，移出时隐藏</li>
<li>鼠标点击箭头，图片发生轮播</li>
<li>点击号码，切换到指定图片</li>
<li>鼠标移出，图片每隔一定时间自动轮播</li>
<li>当图片轮播到最后或最前一张的时候，图片无缝循环切换</li>
</ol>
<p>思路：</p>
<ul>
<li>DOM：div.screen&gt;ul&gt;li*5&gt;img 放图片，ol&gt;li 显示下标，div&gt;span 显示箭头</li>
<li>样式：让 li 标签 float 实现并排效果，div.screen 要设好宽高并 overflow:hidden 只显示出一张图，轮播的原理就是设置 ul.style.left 的值<code>ul.style.left = -index * screen.offsetWidth + &#39;px&#39;</code> （变量 index 记录当前需要展示的图片的索引, screen 是外层那个 div）</li>
<li>逻辑：<ul>
<li>一个全局变量 index 记录当前需要展示的图片的索引</li>
<li>无限滚动的实现：复制第一张图放到原本图片集的最后。然后当是最后一张还向右滚动的话，就立刻改变 ul 的位置到第一张（index&#x3D;0，ul.style.left &#x3D; ….）；同理第一向左滚动</li>
<li>鼠标移入移出事件：鼠标移入，显示左右切换按钮，清除 setInterval 自动滚动；移出时隐藏按钮，新建 setInterval 自动滚动</li>
<li>点击按钮</li>
<li>封装一个滚动动画的函数，一个向右滚动函数 scroll，一个在滚动时能设置号码牌样式的函数 indexShow</li>
</ul>
</li>
</ul>
<h2 id="写一个动画让一个div在水平的两个点之间来回运动"><a href="#写一个动画让一个div在水平的两个点之间来回运动" class="headerlink" title="写一个动画让一个div在水平的两个点之间来回运动"></a>写一个动画让一个div在水平的两个点之间来回运动</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: myanimation <span class="number">3s</span> infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> myanimation &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>);&#125;</span><br><span class="line">  <span class="number">50%</span> &#123;<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">800px</span>, <span class="number">0px</span>);&#125;</span><br><span class="line">  <span class="number">100%</span> &#123;<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0px</span>, <span class="number">0px</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现一个前端缓存模块"><a href="#实现一个前端缓存模块" class="headerlink" title="实现一个前端缓存模块"></a>实现一个前端缓存模块</h2><p>实现一个前端缓存模块，主要用于缓存 xhr 返回的结果，避免多余的网络请求浪费，要求：</p>
<ul>
<li>生命周期为一次页面打开</li>
<li>如果有相同的请求同时并行发起，要求其中一个能挂起并且等待另外一个请求返回并读取该缓存</li>
</ul>
<p>见<a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/10/31/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92&%E8%B7%A8%E5%9F%9F/">前后端交互&amp;跨域</a></p>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="定时器正确输出"><a href="#定时器正确输出" class="headerlink" title="定时器正确输出"></a>定时器正确输出</h2><p>改正代码 输出 0123401234</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">i</span> = i;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">i</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>解答：上面这种方式，i 是全局变量；for 循环产生 5 个定时器，拿到全局 i 的时候已经 i&#x3D;5 了（外层这个 function 和里面的 this 是来干扰的，去掉也无妨）。解决方法就是让变量 i 有块级作用域：let；闭包。<br>可改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">i</span> = i;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">i</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>也可以是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">i</span> = i;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">i</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p>readline()用于行的读取，最好是在一开始就读取完<br>print()用于输出结果</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/15/%E5%9C%BA%E6%99%AF%E5%AE%9E%E7%8E%B0/" data-id="clmniym7t003zbb878af651pl" data-title="场景实现" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ES6小结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/14/ES6%E5%B0%8F%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2019-10-14T08:50:21.000Z" itemprop="datePublished">2019-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/14/ES6%E5%B0%8F%E7%BB%93/">ES6小结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="变量提升与var、let及const"><a href="#变量提升与var、let及const" class="headerlink" title="变量提升与var、let及const"></a>变量提升与var、let及const</h3><ul>
<li>函数提升优先于变量提升（var），函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li>
<li>var 存在变量提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用</li>
<li><strong>var 在全局作用域下声明变量会导致变量挂载在 window 上（变成window的属性），其他两者不会</strong></li>
<li>let 和 const 作用基本一致，但是后者声明的变量不能再次赋值</li>
</ul>
<h5 id="var、let及const的区别"><a href="#var、let及const的区别" class="headerlink" title="var、let及const的区别"></a>var、let及const的区别</h5><ul>
<li>let（建议用let取代var）<ul>
<li>作用域是<strong>块级作用域</strong>（之前只有函数作用域和全局作用域）（并且for循环的括号和{}是在两个不同的作用域，可以独立声明同名变量并使用）</li>
<li><strong>不存在变量声明提前 （在let之前使用，会报错（因为暂时性死区）</strong> is not defined）</li>
<li><strong>不可以重复定义</strong> （var可以，不会报错，但是let 会说has already been declared)</li>
<li>存在存在暂时性死区<br>在块级作用域内存在let&#x2F;const，它所声明的变量就“绑定”了这个区域。在这个代码块（块级作用域）内，使用let&#x2F;const命令声明变量之前，该变量都是不可用。意义：标准化代码，将所有的变量声明放在最前面</li>
</ul>
</li>
<li>const（所有的函数都应该用const）<ul>
<li>一般用来声明常量，不允许修改</li>
<li>一旦声明变量，就必须立即赋值</li>
<li>和let一样，都是块级作用域，存在暂时性死区，没有变量声明提前，不允许重复定义</li>
</ul>
</li>
<li>var<ul>
<li>var的作用域是函数作用域，在一个函数内部利用var声明一个变量，则这个变量只在函数内有效</li>
<li>存在变量声明提前（但是赋值并没有提前，提前访问会返回undefined)</li>
</ul>
</li>
</ul>
<h3 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h3><p>如下所述</p>
<ul>
<li>数组的解构赋值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 可以一次性为三个变量赋值</span></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];  <span class="comment">// third为&#x27;baz</span></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure></li>
<li>对象的解构赋值。eg. let { foo, bar } &#x3D; { foo: ‘aaa’, bar: ‘bbb’ };   变量必须与属性同名，才能取到正确的值</li>
<li>字符串的解构赋值。eg. const [a, b, c, d, e] &#x3D; ‘hello’;</li>
<li>函数参数也可以用解构赋值。可以实现：函数的参数表面上是一个数组&#x2F;对象，但在传入参数的那一刻，<strong>数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y</strong></li>
<li><strong>… 就是让数组把item全部铺开的意思</strong></li>
</ul>
<p>此外还可以设置默认值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><strong>应用</strong>：使用数组成员对变量赋值；函数的参数如果是对象的成员，优先使用解构赋值；如果函数返回多个值，优先使用对象的解构赋值；使用扩展运算符（…）拷贝数组，eg.拷贝item数组： <code>const itemsCopy = [...items]; </code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFullName</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstName = user.<span class="property">firstName</span>;</span><br><span class="line">  <span class="keyword">const</span> lastName = user.<span class="property">lastName</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用的扩展方法"><a href="#常用的扩展方法" class="headerlink" title="常用的扩展方法"></a>常用的扩展方法</h3><ul>
<li>Array.from() 将类似数组的对象转为数组（arguement，Nodelist），也能将普通对象的key值取出来生成一个数组。</li>
</ul>
<h3 id="Symbol，Set和Map"><a href="#Symbol，Set和Map" class="headerlink" title="Symbol，Set和Map"></a>Symbol，Set和Map</h3><ul>
<li>新的原始数据类型Symbol，表示独一无二的值。可以作为对象的属性名使用，但此时Symbol为名属性，不会出现在for…in和for…if循环中也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名，生成一个数组。</li>
<li>新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值</li>
<li>新的数据结构 Map。类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键</li>
</ul>
<h3 id="Promise-Generator-async函数"><a href="#Promise-Generator-async函数" class="headerlink" title="Promise, Generator, async函数"></a>Promise, Generator, async函数</h3><p>见我写的另一篇文章：<a target="_blank" rel="noopener" href="https://jacleklm.github.io/2019/11/01/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/#more">《异步编程》</a></p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>参考资料<br><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">ECMAScript6标准入门</a><br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/14/ES6%E5%B0%8F%E7%BB%93/" data-id="clmniym6h000dbb87h0p05aze" data-title="ES6小结" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JS基础知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2019-10-12T15:50:21.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">JS基础知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h5 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h5><p>ES 中有 6 种基本数据类型：undefined（未声明），null（空对象指针，可以说一个变量想用来保存对象，未保存之前最好使其等于 null），boolean，number，string，symbol（fromES6））；一种复杂数据类型：Object<br>引用类型有：Object，Array，Function，Date，RegExp</p>
<h5 id="基本类型与引用类型区别"><a href="#基本类型与引用类型区别" class="headerlink" title="基本类型与引用类型区别"></a>基本类型与引用类型区别</h5><p>引用类型（对象类型）和基本类型（原始类型）不同的是，基本类型存储的是值，引用类型存储的是地址（指针）。<br>当创建了一个引用类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。</p>
<h5 id="typeof-vs-instanceof"><a href="#typeof-vs-instanceof" class="headerlink" title="typeof vs instanceof"></a>typeof vs instanceof</h5><p>typeof 对于基本类型来说，除 null 会显示成 object（null 不是 object，这是 JS 一个古老的 bug），其余都可以显示正确的类型；<br>typeof 对于引用类型来说，除了函数（会显示 function）都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span>; <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们想判断一个引用类型的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的；但是 instanceof 不能用来判断基本类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">str <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="如何判断一个引用类型是数组"><a href="#如何判断一个引用类型是数组" class="headerlink" title="如何判断一个引用类型是数组"></a>如何判断一个引用类型是数组</h5><ul>
<li>根据构造函数来判断 xxx instanceof Array</li>
<li>直接用 Array.isArray() 判断</li>
<li>根据 class 属性判断 <code>Object.prototype.toString.call(obj) === &#39;[object Array]&#39;</code></li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在 JS 中类型转换只有三种情况，分别是：转换为布尔值；数字；字符串</p>
<h5 id="转-Boolean"><a href="#转-Boolean" class="headerlink" title="转 Boolean"></a>转 Boolean</h5><p>用 Boolean()进行转换。在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象。<br>eg. <code>if([])&#123;console.log(3)&#125;</code>是能输出<code>3</code>的</p>
<h5 id="对象转原始类型"><a href="#对象转原始类型" class="headerlink" title="对象转原始类型"></a>对象转原始类型</h5><p>对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：</p>
<ul>
<li>如果已经是原始类型了，那就不需要转换了</li>
<li>如果需要转字符串类型就调用 x.toString()，转换为基础类型的话就返回转换的值。不是字符串类型的话就先调用 valueOf，结果不是基础类型的话再调用 toString</li>
<li>调用 x.valueOf()，如果转换为基础类型，就返回转换的值</li>
<li>如果都没有返回原始类型，就会报错</li>
</ul>
<p>当然可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1</span> + a; <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<h5 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h5><p>加法运算符不同于其他几个运算符，它有以下几个特点：</p>
<ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&quot;1&quot;</span>; <span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> +</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + <span class="comment">// &quot;41,2,3&quot;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">017</span>) + <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="comment">// 0</span></span><br><span class="line">  <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>如果你对于答案有疑问的话，请看解析：</p>
<ul>
<li>对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 ‘11’</li>
<li>对于第二行代码来说，触发特点二，所以将 true 转为数字 1</li>
<li>对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3</li>
<li>对于第四行。new Array(017)，里面 017 是八进制，相当于 15，所以是创建了长度为 15 但内容都是空的数组。<strong>单独的 + 会使其转 Number</strong>。<strong>对数组而言</strong>，转 Number 时候数组长度大于等于 2 时都为 NaN。数组长度为 0 时是 0，为 1 的时候对数组第一项用 Number()。</li>
</ul>
<p>另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span> + +<span class="string">&quot;b&quot;</span>; <span class="comment">// -&gt; &quot;aNaN&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”。<br>对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">&quot;3&quot;</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * []; <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>运算符前置和后置的区别</p>
<ul>
<li>如果该运算符作为后置操作符，则返回它递减之前的值。</li>
<li>如果该运算符作为前置操作符，则返回它递减之后的值。</li>
</ul>
<p>后置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> a = i--;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//输出4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//输出5</span></span><br></pre></td></tr></table></figure>

<p>前置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = --j;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">//输出4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//输出4</span></span><br></pre></td></tr></table></figure>

<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>注意：+ 的优先级高于 三目运算符 ? : ; + 的优先级高于比较运算符 &gt;</p>
<p>1、如果是对象，就通过 toPrimitive 转换对象<br>2、如果是字符串，就通过 unicode 字符索引来比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a &gt; -<span class="number">1</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。</p>
<h5 id="比较"><a href="#比较" class="headerlink" title="&#x3D;&#x3D;比较"></a>&#x3D;&#x3D;比较</h5><ul>
<li>Boolean，number，string 三类比较的时候把值转换成<strong>数字</strong>，在看转换结果是否相等。证明：（’1’&#x3D;&#x3D;true) 是真 （’abc’&#x3D;&#x3D;true）是假。</li>
<li>undefined 参与比较，换成了 NaN,所以其他三个类型跟它比较都是 false，跟 null 类型比较的时候是 true。（NaN&#x3D;&#x3D;NaN)是假</li>
<li>null 参与比较，被当成对象，因为 null 没有 valueof 和 toString，除了 undefined 谁跟他比较都是 false。</li>
<li>值类型与对象比较：先调用对象 valueof 如果仍返回对象，调用 tostring，如果还是没有就不等。**{}转数字是 NaN，[]转数字是 0**</li>
</ul>
<h5 id="与"><a href="#与" class="headerlink" title="&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</h5><p>对于 &#x3D;&#x3D; 来说，如果对比双方的类型不一样的话，就会进行类型转换。<br>假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程：</p>
<ol>
<li>首先会判断两者类型是否相同。相同的话就是比大小了</li>
<li>类型不相同的话，那么就会进行类型转换</li>
<li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li>
<li>判断两者类型是否是 string 和 number，是的话就会将字符串转换为 number</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">      ↓</span><br><span class="line"><span class="number">1</span> ==  <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span></span><br><span class="line">        ↓</span><br><span class="line"><span class="string">&#x27;1&#x27;</span> ==  <span class="number">1</span></span><br><span class="line">        ↓</span><br><span class="line"> <span class="number">1</span>  ==  <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>判断其中一方是否 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == &#123; <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span> &#125;</span><br><span class="line">        ↓</span><br><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="string">&#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在来想想[]&#x3D;&#x3D;![]输出什么？<br>首先先执行的是![]，它会得到 false。<br>然后[]&#x3D;&#x3D;false，返回 true。<br>那么[]&#x3D;&#x3D;[],{}&#x3D;&#x3D;{}又输出什么呢？<br>类型一致，它们是引用类型，地址是不一样的，所以为 false!<br>对于 &#x3D;&#x3D;&#x3D; 来说就简单多了，就是判断两者类型和值是否相同。</p>
<h3 id="各种运算符和操作符"><a href="#各种运算符和操作符" class="headerlink" title="各种运算符和操作符"></a>各种运算符和操作符</h3><h5 id="逻辑运算符-或运算，左假看右；与运算，左真看右"><a href="#逻辑运算符-或运算，左假看右；与运算，左真看右" class="headerlink" title="逻辑运算符 (或运算，左假看右；与运算，左真看右)"></a>逻辑运算符 (或运算，左假看右；与运算，左真看右)</h5><ul>
<li>只要 || 前面为 false,不管 || 后面是 true 还是 false，都返回 || 后面的值。</li>
<li>只要 || 前面为 true,不管 || 后面是 true 还是 false，都返回 || 前面的值。</li>
<li>只要 &amp;&amp; 前面是 false，无论 &amp;&amp; 后面是 true 还是 false，结果都将返 &amp;&amp; 前面的值;</li>
<li>只要 &amp;&amp; 前面是 true，无论 &amp;&amp; 后面是 true 还是 false，结果都将返 &amp;&amp; 后面的值;</li>
</ul>
<h5 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h5><p>内存中是用 32 位的二进制来表示数值，没用到的位用 0 填充。负数是用二进制补码表示（绝对值的二进制，再反码，再+1）</p>
<ul>
<li>按位非。用 ~ 表示，返回数值的反码</li>
<li>按位与 &amp; 。将两个数值每一位对齐，对相同位置上的两个数进行对比。只有两个都是 1 时才返回 1，否则都是 0。</li>
<li>按位或 | 。同理，但是是只有两个都是 0 是才返回 0。</li>
<li>按位异或 ^ 。 同理，只有一个是 1 时候才返回 1。</li>
<li>左移 &lt;&lt; 。 二进制中左移几位</li>
<li>有符号的右移 &gt;&gt; 。 同理 保留符号位</li>
<li>无符号的右移 &gt;&gt;&gt; 。 以 0 来填充右移产生的空位（新的符号位），所以正数无影响，负数变化很大</li>
</ul>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaohuochai/p/5735901.html">更详细的解释</a><br>严格模式下禁止 this 关键字指向全局对象</p>
<h5 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h5><ul>
<li>全局环境，默认绑定到 window</li>
<li>函数独立调用的时候，this 默认绑定到 window</li>
<li>被嵌套的函数独立调用时，this 默认绑定到 window</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然test()函数被嵌套在obj.foo()函数中，但test()函数是独立调用，而不是方法调用。所以this默认绑定到window</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">test</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行的函数 this 是 window</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//  这串代码本质上和上个例子的代码是一样的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>闭包的 this 默认绑定到 window</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>()(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h5 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h5><p>被直接对象所包含的函数调用时，也称为方法调用，this 隐式绑定到该直接对象</p>
<h5 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h5><p>通过 call()、apply()、bind()方法把对象绑定到 this 上，叫做显式绑定。对于被调用的函数来说，叫做间接调用</p>
<h5 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h5><p>如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用。对于 this 绑定来说，称为 new 绑定</p>
<h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p><strong>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变</strong><br>实例与解析<br>先来看几个函数调用的场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">  <span class="attr">foo2</span>: <span class="title function_">foo2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br><span class="line">obj.<span class="title function_">foo2</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>接下来一个个分析上面几个场景</p>
<ul>
<li>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</li>
<li>对于 obj.foo() 来说，我们只需要记住，<strong>谁调用了函数</strong>，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象。但是如果是 foo2 的情况，this 是指向 window 的</li>
<li>对于 new 的方式来说，<strong>this 被永远绑定在了 c 上面，不会被任何方式改变 this</strong> (在构造函数中 this 指向函数名)</li>
</ul>
<p>说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了。<br>下面让我们看看箭头函数中的 this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>()()());</span><br></pre></td></tr></table></figure>

<p>首先箭头函数其实是没有 this 的，<strong>箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this</strong>。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外<strong>对箭头函数使用 bind 这类函数是无效的</strong>。<br>最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。<br>那么说到 bind，<strong>如果对一个函数进行多次 bind，那么上下文会是什么</strong>呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fn.<span class="title function_">bind</span>().<span class="title function_">bind</span>(a)(); <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>如果认为输出结果是 a，那么就错了。<br>其实可以把上述代码转换成另一种形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等价于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>();</span><br><span class="line">  &#125;.<span class="title function_">apply</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>

<p>可以从上述代码中发现，<strong>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定</strong>，所以结果永远是 window。这个特性可以用来创建绑定了固定 this 的函数（见 MDN）</p>
<h3 id="闭包与作用域链"><a href="#闭包与作用域链" class="headerlink" title="闭包与作用域链"></a>闭包与作用域链</h3><p>更详细的解析见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html">深入理解 javascript 原型和闭包（完结）</a></p>
<h5 id="执行环境（（执行）上下文环境）"><a href="#执行环境（（执行）上下文环境）" class="headerlink" title="执行环境（（执行）上下文环境）"></a>执行环境（（执行）上下文环境）</h5><p>execution context。红宝书的说法：定义了变量或函数有权访问其他数据，决定了它们各自的行为。<br>全局执行环境是 window 对象，即<strong>全局变量和函数都是作为 window 对象的属性和方法创建的</strong>，每个函数都有自己的执行环境（理解为函数的执行环境就是函数的归属者？）<br>From 博客的理解：</p>
<ul>
<li>通俗定义：在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空，即是一种代码执行前的准备工作。eg1. 在全局代码段中，“准备工作”包括：知道有函数声明并赋值；知道有 this 并赋值；知道有变量，赋值为 undefined。eg2. 在函数体内的代码段中，“准备工作”包括了全部工作的那部分之外，还有知道有参数和 argument<strong>并赋值</strong>，确定了函数体内部自由变量的作用域。**(预编译)**</li>
<li>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？答案是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangfupeng1988/p/3989357.html">执行环境栈</a>。即当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境，<strong>处于活动状态的执行上下文环境只有一个</strong>。所以其实是一个进栈和出栈的过程，活动状态的执行环境就是栈尾的环境。</li>
</ul>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>scope。一段程序代码中所用到的名字并不总是有效&#x2F;可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</p>
<ul>
<li>JS 没有块级作用域。“块”就是大括号“{}”中间的语句。其实就是 if 和 for 的{}中声明的变量在其{}之外的地方也能访问</li>
<li><strong>除了全局作用域之外，只有函数可以创建作用域。所以某函数的{}中就可以看做是该函数的作用域</strong>。函数有嵌套关系的时候，他们的作用域就有上下级关系。作用域在函数定义时就已经确定了。而不是在函数调用时确定。</li>
<li>作用域、执行环境、执行环境栈的关系，**详情见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangfupeng1988/p/3991995.html">这里</a>**。总结为：作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。</li>
</ul>
<h5 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h5><p>每个执行环境都有一个与之相关的变量对象，执行环境中定义的所有变量和函数都会保存在这个对象中</p>
<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><ul>
<li><strong>代码执行过程中会创建变量对象的一个作用域链，作用域链的前端是当前执行环境的变量对象（某函数的作用域），末端是全局执行环境的变量对象（全局作用域）</strong>。</li>
<li>作用域链的作用是，保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问不行</li>
<li>自由变量：在 A 作用域中使用的变量 x，却没有在 A 作用域中声明（即在其他作用域中声明的），对于 A 作用域来说，x 就是一个自由变量。自由变量跨作用域取值时，<strong>要去创建这个函数的作用域取值（去创建这个函数的作用域沿作用域链找），而不是“父作用域”</strong>（eg. 闭包（函数作为参数例子）有时会出现这种情况）</li>
<li><strong>变量查找过程：先在自己的作用域中找，如果找不到就沿着作用域链往上找。</strong></li>
<li>延长作用域链：执行环境类型一般只有全局和局部函数两种 try-catch 语句的 catch 块和 with 语句会在作用域链的前端增加一个变量对象（with 现在已经少用了）</li>
</ul>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangfupeng1988/p/3994065.html">闭包</a></h5><ul>
<li>定义：<strong>闭包就是能够读取其他函数内部变量的函数，其实就是利用了作用域链向上查找的特点。创建闭包的方式：函数作为返回值；函数作为参数</strong></li>
<li>作用：读取函数内部变量，让这些变量的值一直保持在内存中。但是会增加内容开销，记得及时销毁。</li>
<li>核心内容：函数调用完成之后，其执行上下文环境不一定会接着被销毁，这种不被销毁的情况就是闭包（函数作为返回值的情况下）。eg. fn1 中 return fn2; 外部有 var test &#x3D; fn1(); 这里 fn1 执行之后其执行环境不会被销毁，因为 test 被赋值成函数，函数的特别之处在于可以创建一个独立的作用域。这里只有再执行一个 test()，那 fn1 和 fn2 的执行环境才会被销毁，否则会一直存在，所以说闭包会增加内容开销。</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>JS 的对象有两种属性值：数据属性 访问器属性</p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>包含一个数据值的位置（就是我们常用的属性类型）</p>
<h6 id="数据属性有四个特性"><a href="#数据属性有四个特性" class="headerlink" title="数据属性有四个特性"></a>数据属性有四个特性</h6><p>Configurable 表示能否通过 delete 删除属性从而重新定义属性，默认为 true<br>Enumerable 表示能否通过 for-in 循环返回属性，默认为 true<br>Writable 表示能否修改属性的值，默认为 true<br>Value 包含这个属性的数据值 默认为 undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字面量创建对象，前三个属性默认值为true，value为指定的值</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改属性默认特性用 Object.defineProperty(obj,attr,{})</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&#x27;name&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">wirtable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">false</span>;<span class="comment">//一旦被设置为false，不可以更改</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span>=<span class="string">&#x27;xx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);<span class="comment">//xxxx ，严格模式下会报错</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">name</span><span class="comment">//无效 严格模式下会报错</span></span><br></pre></td></tr></table></figure>

<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>访问器属性不包含数据值。但是包含 getter 和 setter 函数，定义读取和写入访问器属性的时候调用的函数（类似 Vue，或者 Vue 说就是借助访问器属性）</p>
<h6 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h6><p>Configuable 表示能否通过 delete 删除属性从而重新定义属性，默认是 true<br>enumerable 表示能否通过 for-in 循环返回属性，默认是 true<br>get 读取属性时调用函数，默认 undefined<br>ste 写入属性时调用函数，默认 undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">_age</span>: <span class="number">20</span>, <span class="comment">//下划线写法表示只能通过对象方法访问的属性</span></span><br><span class="line">  <span class="attr">state</span>: <span class="string">&quot;young&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal &gt; <span class="number">50</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_age</span> = newVal;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">stae</span> = <span class="string">&quot;old&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_age</span> = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>定义多个属性（数据属性和访问器属性都可以用），使用 Object.defineProperties();</p>
<h5 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h5><p>使用 Object.getOwnPropertyDescriptor()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(person,&#123;</span><br><span class="line">    <span class="attr">_age</span>:&#123;</span><br><span class="line">        <span class="attr">values</span>:<span class="number">20</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>:&#123;</span><br><span class="line">        <span class="attr">get</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>:<span class="keyword">function</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newVal&gt;<span class="number">50</span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_age</span>=newVal;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">stae</span>=<span class="string">&#x27;old&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="variable language_">this</span>.<span class="property">_age</span>=newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor=<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person,<span class="string">&#x27;_age&#x27;</span>);</span><br><span class="line">descriptor.<span class="property">value</span><span class="comment">//20</span></span><br><span class="line">descriptor.<span class="property">configurable</span><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor=<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person,<span class="string">&#x27;age&#x27;</span>);</span><br><span class="line">descriptor.<span class="property">value</span><span class="comment">//undefined</span></span><br><span class="line">descriptor.<span class="property">configurable</span><span class="comment">//false</span></span><br><span class="line"><span class="keyword">typeof</span> descriptor <span class="comment">//function</span></span><br></pre></td></tr></table></figure>

<h5 id="函数与对象的关系"><a href="#函数与对象的关系" class="headerlink" title="函数与对象的关系"></a>函数与对象的关系</h5><p>js 中的内部对象包括 Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String 以及各种错误类对象，包括 Error、EvalError、RangeError、ReferenceError、SyntaxError 和 TypeError。<br>其中 Global 和 Math 这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。<br><strong>一切（引用类型）都是对象，对象是属性的集合</strong><br>eg. 构造函数可以用 this.的方式说明函数也是可以用 . 的方式来写属性的，其实是因为函数就是对象的一种。同理数组也是可以的，不过写属性方式可能不同，因为数组就像是对象的一个子集一样。但是函数和对象之间的关系比较复杂：</p>
<ul>
<li>对象都是通过函数创建的。（就算是字面量创建对象，其实也是构造函数法的一种语法糖（简单写法））</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var obj = &#123; a: 10, b: 20 &#125;;</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line">obj.<span class="property">b</span> = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Object</span>); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<ul>
<li>每个对象都有一个<code>__proto__</code>属性，指向创建该对象的函数的 prototype（即 Object.prototype）。但是 Object.prototype 是一个特例，它的<code>__proto__</code>指向的是 null。同理每个函数的<code>__proto__</code>追溯到祖先都是 Function.prototype。总结关系如下：<br><img src="/img/JS%E5%92%8CES6/%E5%8E%9F%E5%9E%8B.png"></li>
</ul>
<h3 id="继承及原型链"><a href="#继承及原型链" class="headerlink" title="继承及原型链"></a>继承及原型链</h3><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>在 js 中，每个函数都有 prototype 属性，这个属性值是一个对象（同时这个对象带有 constructor 属性，指向函数本身）<br>通过 new 可以创建一个函数的实例，每个实例都有<em>proto</em>属性，指向构造函数的 prototype 对象。<br>当我们在一个对象上（或方法）找某个属性的时候，会先查找实例上是否存在这个属性，如果没有的话，沿着原型链向上查找<br><img src="/img/JS%E5%92%8CES6/%E5%8E%9F%E5%9E%8B%E9%93%BE.png"></p>
<h6 id="怎么判断一个属性是对象上的属性还是其原型对象上的属性"><a href="#怎么判断一个属性是对象上的属性还是其原型对象上的属性" class="headerlink" title="怎么判断一个属性是对象上的属性还是其原型对象上的属性"></a>怎么判断一个属性是对象上的属性还是其原型对象上的属性</h6><p>使用 hasOwnProperty()返回 true，说明是这个对象上的；如果返回 false，但是属性 in 这个对象返回了 true，说明是原型对象上的属性。如果都是 false，那么不存在这个属性<br><strong>创建对象采用构造函数和原型模式组合的方式</strong>。构造函数用来定义实例属性，原型模式用来定义方法和共享属性</p>
<h5 id="继承的原理"><a href="#继承的原理" class="headerlink" title="继承的原理"></a>继承的原理</h5><p><strong>还是跟原型链有关。每个函数都有个原型对象，这个对象用来存储通过这个函数所创建的所有实例的共有属性和方法。在读取某个对象属性的时候，从实例开始，如果实例有就返回，如果没有就找构造函数的原型对象，找到了就返回。通过实例只能访问原型对象里的值，但是不能修改。这就实现了继承</strong>。</p>
<h5 id="组合继承-（原型链-用-call-借用构造函数）"><a href="#组合继承-（原型链-用-call-借用构造函数）" class="headerlink" title="组合继承 （原型链 + 用 call 借用构造函数）"></a>组合继承 （原型链 + 用 call 借用构造函数）</h5><p>组合继承是最常用的继承方式。<br><strong>单纯用原型链继承的问题是</strong>：包含引用类型的值的属性会被所有实例共享，某个实例改了这个属性则所有实例都会改。eg. <code>this.food = [&#39;apple&#39;, &#39;banana&#39;]</code><br><strong>单纯用借用构造函数继承的</strong></p>
<ul>
<li>优点：子类型构造函数可以传参：不会与父类引用类型的值的属性共享</li>
<li>缺点：在父类中定义的方法在子类中并不可见（因为这样的话方法就是引用类型属性）eg. <code>this.getName = function() &#123; xxx &#125;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">getAge</span>(); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child <span class="keyword">instanceof</span> <span class="title class_">Parent</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变<strong>子类的原型为 new Parent()<strong>来继承父类的函数。<br>这种继承方式</strong>优点在于子类型构造函数可以传参，不会与父类引用属性共享</strong>，可以复用父类的函数，但是也存在一个<strong>缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</strong>。</p>
<h5 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h5><p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Child</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">getValue</span>(); <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Parent</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
<h5 id="ES6-的-Class-继承"><a href="#ES6-的-Class-继承" class="headerlink" title="ES6 的 Class 继承"></a>ES6 的 Class 继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">getValue</span>(); <span class="comment">// 调用父类的getValue()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">1</span>);</span><br><span class="line">child.<span class="title function_">getValue</span>(); <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Parent</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>super 关键字指向当前对象的原型对象<br>class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。</p>
<h5 id="Class-中的箭头函数和普通函数有何区别"><a href="#Class-中的箭头函数和普通函数有何区别" class="headerlink" title="Class 中的箭头函数和普通函数有何区别"></a>Class 中的箭头函数和普通函数有何区别</h5><p>箭头函数相当于绑定上了 this，类似构造函数内的一个值。<br>箭头函数会绑定在实例对象上，普通函数最后会绑定在原型上。</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM 是针对 HTML 和 XML 文档的一个 API。将文档看作一个层次化的节点树，可以用 JS 来操作这个节点树。</p>
<h5 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h5><p>文档节点（Document）是每个文档的根节点，它有且仅有一个子节点：html 元素（节点与元素的关系类似于键与值的关系）。</p>
<h5 id="DOM-如何创建元素"><a href="#DOM-如何创建元素" class="headerlink" title="DOM 如何创建元素"></a>DOM 如何创建元素</h5><p>创建：createElement(‘div’);<br>添加：appendChild(element) ； insertBefore(insertdom.chosendom)</p>
<h5 id="DOM-获取元素的方式"><a href="#DOM-获取元素的方式" class="headerlink" title="DOM 获取元素的方式"></a>DOM 获取元素的方式</h5><ul>
<li>通过元素类型获取<ul>
<li>document.getElementById();&#x2F;&#x2F;id 名，在实际开发中较少使用，选择器中多用 class id 一般只用在顶级层存在 不能太过依赖 id</li>
<li>document.getElementsByTagName();&#x2F;&#x2F;标签名</li>
<li>document.getElementsByClassName();&#x2F;&#x2F;类名</li>
<li>document.getElementsByName();&#x2F;&#x2F;DOM 般不用</li>
<li>document.querySelector();&#x2F;&#x2F;css 选择符模式，返回与该模式匹配的第一个元素，结果为一个元素；如果没找到匹配的元素，则返回 null</li>
<li>document.querySelectorAll()&#x2F;&#x2F;css 选择符模式，返回与该模式匹配的所有元素，结果为一个类数组</li>
</ul>
</li>
<li>根据关系树来选择<ul>
<li>parentNode&#x2F;&#x2F;获取所选节点的父节点，最顶层的节点为#document</li>
<li>childNodes &#x2F;&#x2F;获取所选节点的子节点们</li>
<li>firstChild &#x2F;&#x2F;获取所选节点的第一个子节点</li>
<li>lastChild &#x2F;&#x2F;获取所选节点的最后一个子节点</li>
<li>nextSibling &#x2F;&#x2F;获取所选节点的后一个兄弟节点 列表中最后一个节点的 nextSibling 属性值为 null</li>
<li>previousSibling &#x2F;&#x2F;获取所选节点的前一兄弟节点 列表中第一个节点的 previousSibling 属性值为 null</li>
</ul>
</li>
<li>根据元素节点树来选择<ul>
<li>parentElement 　&#x2F;&#x2F;返回当前元素的父元素节点（IE9 以下不兼容）</li>
<li>children &#x2F;&#x2F; 返回当前元素的元素子节点</li>
<li>firstElementChild &#x2F;&#x2F;返回的是第一个元素子节点（IE9 以下不兼容）</li>
<li>lastElementChild &#x2F;&#x2F;返回的是最后一个元素子节点（IE9 以下不兼容）</li>
<li>nextElementSibling &#x2F;&#x2F;返回的是后一个兄弟元素节点（IE9 以下不兼容）</li>
<li>previousElementSibling &#x2F;&#x2F;返回的是前一个兄弟元素节点（IE9 以下不兼容）</li>
</ul>
</li>
</ul>
<h5 id="获取-DOM-节点-get-系列和-query-系列哪种性能好？"><a href="#获取-DOM-节点-get-系列和-query-系列哪种性能好？" class="headerlink" title="获取 DOM 节点 get 系列和 query 系列哪种性能好？"></a>获取 DOM 节点 get 系列和 query 系列哪种性能好？</h5><p>1.从性能上说 get 系列的性能都比 query 系列好，get 系列里面各有差异，这些差异可以结合算法如何遍历搜索去理解，都解释得通。<br>2.getElementsByTagName 比 querySelectorAll 快的原因在于：getElementsByTagName 创建的过程不需要做任何操作，只需要返回一个指针即可。而 querySelectorAll 会循环遍历所有的的结果，然后创建一个新的 NodeList。 3.实际在用的过程中取决于要获取的是什么，再进行选择。</p>
<h5 id="节点属性中-children-和-childNodes-有什么区别？"><a href="#节点属性中-children-和-childNodes-有什么区别？" class="headerlink" title="节点属性中 children 和 childNodes 有什么区别？"></a>节点属性中 children 和 childNodes 有什么区别？</h5><p>childNodes 返回的是节点的子节点集合（NodeLists),包括元素节点、文本节点还有属性节点。<br>children 返回的只是节点的元素节点集合（HTMLCollection)</p>
<h5 id="HTMLCollection-和-NodeList-的比较"><a href="#HTMLCollection-和-NodeList-的比较" class="headerlink" title="HTMLCollection 和 NodeList 的比较"></a>HTMLCollection 和 NodeList 的比较</h5><ul>
<li>共同点<ul>
<li>都是类数组对象，都有 length 属性</li>
<li>都有共同的方法：item,可以通过 item(index)获取返回结果的元素</li>
<li>都是实时变动的，document 上面的更改会反映到相关的对象上</li>
<li>注：querySeletorAll 返回的 NodeList 是个浅拷贝的类数组对象，在节点数目上是非实时的，不过对节点属性进行修改，还是实时反映的</li>
</ul>
</li>
<li>区别<ul>
<li>NodeList 可以包含任何节点类型，HTMLCollection 只包含元素节点。elementNode 就是 HTML 中的标签</li>
<li>HTMLCollection 比 NodeList 多一个方法：nameitem(),除了可以用 id，还可以用 name 来获取节点信息</li>
</ul>
</li>
</ul>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型（BOM）以 window 对象为依托，表示浏览器窗口以及页面的可见区域。</p>
<ul>
<li>window 对象：表示浏览器的一个实例。它既是 JS 访问浏览器窗口的一个接口，也是 ES 规定的 Global 对象</li>
<li>location 对象：提供了当前窗口中加载的文档有关的信息。它既是 window 对象的属性，也是 document 对象的属性。对象包含有关当前 URL 的信息</li>
<li>navigator 对象（提供与浏览器有关的信息）、screen 对象、history 对象包含用户（在浏览器窗口中）访问过的 URL</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h5 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h5><p>事件流描述的是从页面中接收事件的顺序。包括三个阶段：事件捕获阶段（从 window 往事件触发处传播（从外到内），遇到注册的捕获事件会触发），处于目标阶段（传播到事件触发处时触发注册的事件），事件冒泡阶段（从事件触发处往 window 传播，遇到注册的冒泡事件会触发）。</p>
<h5 id="如何给元素注册事件"><a href="#如何给元素注册事件" class="headerlink" title="如何给元素注册事件"></a>如何给元素注册事件</h5><ul>
<li>在 HTML 元素中绑定事件 onclick&#x3D;function()</li>
<li>获取 dom，dom.onclick</li>
<li>addEventListener(click,function,true&#x2F;false)。第三个参数默认为 false，表示在冒泡阶段调用事件处理程序；true 则是捕获阶段</li>
<li>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上（因为有冒泡）。</li>
</ul>
<h5 id="如何阻止事件冒泡？如何取消默认事件？如何阻止事件的默认行为？"><a href="#如何阻止事件冒泡？如何取消默认事件？如何阻止事件的默认行为？" class="headerlink" title="如何阻止事件冒泡？如何取消默认事件？如何阻止事件的默认行为？"></a>如何阻止事件冒泡？如何取消默认事件？如何阻止事件的默认行为？</h5><ul>
<li>阻止事件冒泡：<br>W3C: <strong>stopPropagation()</strong>;<br>IE: e.cancelBubble&#x3D;true;<br>写法 :<br>window.event ? window.event.cancelBubble&#x3D;true:e.stop(Propagation)</li>
<li>取消默认事件<br>W3C：<strong>preventDefault()</strong><br>IE: e.returnValue:false;</li>
<li>阻止默认行为：<br><strong>return false</strong><br>原生的 js 会阻止默认行为，但会继续冒泡；<br>jquery 会阻止默认行为，并停止冒泡。</li>
</ul>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>在JS文件顶部写<code>&#39;use strict&#39;</code>即可</p>
<ol>
<li>未声明变量赋值报错</li>
<li>指向window的this变为undifined；用 apply 、call、bind 改变 this 的值，this指向null的话就是null而不是window</li>
<li>函数名不能相同；在函数中修改了参数不能反映到arument；不能用caller和callee<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  n = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">100</span>) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li>
<li>删除了with()；0 开头的八进制字面量无效</li>
<li>保护保留关键字（static之类）</li>
</ol>
<h3 id="那些会让同事打你的简便写法"><a href="#那些会让同事打你的简便写法" class="headerlink" title="那些会让同事打你的简便写法"></a>那些会让同事打你的简便写法</h3><h4 id=""><a href="#" class="headerlink" title="~~"></a>~~</h4><p>对于 <code>~~</code> 运算符，它其实表示为： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var testData= 2.1; </span><br><span class="line">var testResult=(typeof testData===&quot;number&quot;&amp;&amp;!isNaN(testData)&amp;&amp;testData!==Infinity)?(testData&gt;0)?Math.floor(testData):Math.ceil(testData):0; </span><br></pre></td></tr></table></figure>

<p>参考资料<br><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/yiizgo">呓语</a><br><a target="_blank" rel="noopener" href="https://github.com/poetries/">poetries</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html">深入理解 javascript 原型和闭包（完结）</a><br>《Javascript 高级程序设计》<br><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="clmniym6x0010bb875wibek4l" data-title="JS基础知识点" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSS之页面布局详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/09/CSS%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2019-10-09T15:20:21.000Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/09/CSS%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/">CSS之页面布局详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="布局基础知识"><a href="#布局基础知识" class="headerlink" title="布局基础知识"></a>布局基础知识</h3><p>1、display 属性：block（块级元素），inline-block，none（会在页面看不到，并且不会在页面占据空间），flex（flex 布局），inline-block（应用场景：eg. 让很多个<strong>有宽高</strong>的 div 从左到右铺满页面；此时最好也设置 vertical-align：top）<br>2、div { max-width: 600px; margin: 0 auto; }<br>用 max-width 代替 width，防止浏览器页面表现出现水平滚动条；margin：0 auto 实现盒子的左右居中<br>3、盒模型的 box-sizing 属性：设成 border-box，元素的 padding 和 border 不会算进元素的 width 和 height 中;content-box 是常规盒模型；padding-box—高宽包括了内边距<br>4、positoin：static（默认值，元素不会被“positioned”，设成其他值元素都会被“positioned”）；relative；absolute（相对于最近的“positioned”祖先元素，也是一个<strong>破环属性</strong>，脱离文档流）；fixed（脱离文档流）。设置成后面三个属性之后，一般还需要写 top，right 等（relative 时不写的话会和 static 一样，没什么变化，但这时候其子元素可以写 position: absolute;）<br><strong>z-index 属性</strong>：只对被“positioned”的元素有效；对父子元素，子元素 z-index 的默认值是等于其父元素的；当子的 z-index 是大于等于 0 的时候，就算小于父 z-index，也会显示在父元素之上，只有设置成负值才会被父元素覆盖<br>5、float 属性<br>其设计初衷是为了实现文字环绕效果。有以下特性：</p>
<ul>
<li>破坏性：一个 div 中只有一个 img（或有少量文字），当设置 img {float:left}之后，父 div 会坍塌，img 会溢出。因为设置了 float 的 img 会<strong>脱离文档流</strong></li>
<li>包裹性：div 被设置 float 之后，会变得不会默认铺满页面宽度，而是紧包裹住 div 中的文字</li>
<li>清空格：当一个 div 中有多个 img 的时候，页码显示 img 从左到右且相互有<strong>间隔</strong>，但是 img 设置 float 之后，这种间隔会消失，img 紧紧挨着（有时候不希望有间隔，可用此法来清间隔）</li>
</ul>
<p>6、<strong>clear 属性</strong>，用来控制浮动。<br>基本功能：有两个盒子，第一个写了 float：left，第二个没有，则页面效果是两个盒子会重叠而不是上下分布。此时在<strong>第二个</strong>盒子(被影响的盒子，<strong>同级元素</strong>）中写 clear：left，即能实现上下分布（clear：both 也可以）。<br>7、清除浮动<strong>overflow 属性</strong>：也是写在被影响的盒子中（应用场景：over，即内外嵌套，内 div 超出的时候），大部分时候是写在外盒，写在同级盒子的情况是 BFC 的时候（见下面 BFC 部分）。有以下四种<strong>清除浮动的方法</strong>：</p>
<ul>
<li>父元素设置 overflow:hidden，这样父元素就有高度了，不会坍塌（<strong>常用</strong>）</li>
<li>浮动父元素</li>
<li>给父元素添加一个子 div，给其设置 clear：both</li>
<li><strong>clearfix</strong>：给父元素添加一个:after 伪元素，里面写{content: ‘’, display: table, clear: both}; 父元素身要写 *zoom: 1（缩放比例）; 以提高兼容性。其实本质和第三种方法是一样的。</li>
</ul>
<p>8、百分比宽度：width 和 max-width 都可用百分比，相对父级元素的 width<br>9、媒体查询<br>@media screen and (min-width&#x2F;max-width:600px) { }<br>使用 meta 标签中的 viewport 之后可以布局在移动浏览器上显示的更好<br>10、在一个 div 中实现里面文字&#x2F;元素呈现多列分布：用<strong>column</strong>属性。设置 column-count 和 column-gap 即可<br>11、布局模型<br>流动模型（Flow）是浏览器默认的布局模式。块状元素默认从上到下分布，行内元素默认从左到右分布<br>浮动模型（Float）。设置了 float 属性的时候<br>层模型（Layer）。设置了 position 属性的时候</p>
<h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><ul>
<li><p>水平居中</p>
<ul>
<li>行内元素的水平居中<br>是 img，span 等行内元素的时候，父级元素写 text-align: center 即可</li>
<li>块状元素的水平居中（定宽）<br>margin： 0 auto</li>
<li>块状元素的水平居中（不定宽）<br>把块状元素写 display: inline-block&#x2F;inline，再用行内元素的方法实现居中。定宽也能用此法</li>
</ul>
</li>
<li><p>垂直居中（假设父元素是盒子且高度已定）</p>
<ul>
<li>子元素是行内元素，高度是其内容撑开的。设定父元素的 line-height 即可</li>
<li>（差）子元素是块级元素且高度还没有设定。给父元素设定 display: table; vertical: middle 可解决.</li>
<li>（差）子元素是块级元素且高度已经设定。设子元素的 margin-top 为（父元素高度-子元素高度）&#x2F;2</li>
<li><strong>flex 布局法</strong>。对父元素写 display: flex; flex-direction: column; justify-content: center;（似乎 display: flex;align-items: center;也可以）</li>
<li><strong>相对+绝对定位法</strong></li>
</ul>
</li>
<li><p>垂直水平居中</p>
<ul>
<li>（差）在父元素写 text-align：center; vertical-align: middle; display: table-cell;并把子元素设置为 inline-block</li>
<li>若子元素是图像，父元素写 text-align：center; 用行高替代高度，且字体大小设为 0。子元素本身设置 vertical-align:middle</li>
<li><strong>相对+绝对定位法</strong>。父元素设置为相对，子元素设为绝对，在 top、left、right、bottm 都为确定值（可都写成 0）的情况下，写 margin: auto</li>
<li><strong>flex 布局</strong>。对父元素写 display: flex;justify-content: center;align-items: center;</li>
</ul>
</li>
</ul>
<h3 id="两列布局-左盒定宽，右盒自适应"><a href="#两列布局-左盒定宽，右盒自适应" class="headerlink" title="两列布局(左盒定宽，右盒自适应)"></a>两列布局(左盒定宽，右盒自适应)</h3><p>需要知道左侧盒子宽度的方案：</p>
<ul>
<li>双 float 并且右盒设 margin-left &#x3D; 左盒 width；或者双 float 并且右盒写 width: calc(100% - 左盒 width)，此时由于右盒的 width 是计算的，所以子盒子都得写 box-sizing: border-box 。父元素都要清除浮动。</li>
<li>双 inline-block 方案（inline-block + 设 vertical-align）并且 右盒写 width: calc(100% - 左盒 width)，box-sizeing。并且父元素要写 font-size: 0，这也和 width 的计算有关</li>
<li>（少用）父元素设置 position：relative，左元素设成 absolute，右盒子 margin-left: 左盒子宽度，并且（当左盒高度大于右盒时要）设定父容器的 min-height</li>
</ul>
<p><strong>不需要知道左侧盒子宽度的方案</strong>：</p>
<ul>
<li>float+BFC 方法。左盒子 float: left，右盒子通过 overflow: auto，形成了 BFC，因此右侧盒子不会与浮动的元素重叠。父元素清除浮动</li>
<li><strong>flex 布局（最好的）</strong>。父写 display: flex;align-items: flex-start（这一项能让两个子盒高度自动）。左写定宽，右写 flex: 1。</li>
<li>grid 布局。父元素写 display: grid;grid-template-columns: 120px 1fr;align-items: start。子元素都需要 box-sizing: border-box。左写 grid-column: 1，右写 grid-column: 2</li>
</ul>
<h3 id="三列布局-两侧定宽中间自适应"><a href="#三列布局-两侧定宽中间自适应" class="headerlink" title="三列布局(两侧定宽中间自适应)"></a>三列布局(两侧定宽中间自适应)</h3><ul>
<li><p>左右盒子 float + 中间盒子 margin</p>
</li>
<li><p>绝对定位法。父元素设置 position：relative; 左右盒子元素设成 absolute，再用 top、left、right 固定位置。中间盒子用左右 margin 撑开</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pink-chen/p/10582741.html">margin 负值法</a> 都是三个盒子都 float:left。两种方案都是把中间盒子写在 DOM 最前面，优先渲染</p>
<ul>
<li>圣杯布局(父盒子写左右 padding，左右盒子通过相对定位确定位置)</li>
<li>双飞翼布局（middle 的 div 里又插入一个 div，通过调整内部 div 的 margin 值，实现中间栏自适应，内容写到内部 div 中）</li>
</ul>
</li>
<li><p>flex 布局：两侧定好宽度,父元素写 display: flex; 中间的子元素写 flex: 1 (DOM 中必须是先写左再写中最后写右)</p>
</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/asheng2016/p/7281784.html">帮助理解</a><br>BFC 全称”Block Formatting Context”, 中文为“块级格式化上下文”。是布局过程中<strong>生成块级盒子的区域</strong>（同时保持流体特性，存在于文档流中），也是浮动元素与其他元素的交互限定区域<br>（BFC 一般是出现在浮动元素周围的元素）当元素有下面情况的时候<strong>变成 BFC 元素</strong>：</p>
<ul>
<li>float 的值不为 none</li>
<li>overflow 的值为 auto,scroll 或 hidden</li>
<li>display 的值为 table-cell, table-caption, inline-block 中的任何一个</li>
<li>position 的值不为 relative 和 static ……</li>
</ul>
<p>变成 BFC 元素后会有以下<strong>特性</strong>：</p>
<ul>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的布局与外面互不影响</li>
<li>BFC 的区域不会与其它 float 的元素区域重叠</li>
<li>计算 BFC 的高度时，浮动子元素也参与计算</li>
</ul>
<p>有用的其实是<strong>overflow:auto&#x2F;hidden</strong>，display:inline-block 和 display:table-cell。<strong>主要用途</strong>：清除浮动，防止 margin 重叠，阻止文字环绕。</p>
<h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">flex 布局</a></h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4896e6936ce3">告诉你一个将 footer 保持在底部的最好方法</a></p>
<p>1、flex 容器的属性：flex-direction 主轴方向，justify-content 项目在主轴上的对齐方式，align-items 定义项目在交叉轴上如何对齐……<br>2、flex item 的属性：flex 属性是 flex-grow（项目的放大比例（与其他项目相比），默认为 0）, flex-shrink（项目的缩小比例） 和 flex-basis 的简写，默认值为 0 1 auto。….<br><strong>注意</strong>：设置为 Flex 布局后，子元素的 float 、clear 和 vertical-align 属性将失效<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">flex 布局</a>：<br>1、可以实现骰子任意面的任意布局（一个点位一个盒子）<br>2、网格布局（在骰子布局的基础上实现 item 的缩放）<br>3、圣杯布局 …</p>
<h3 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">grid 布局</a></h3><p>1、Grid 布局（二维布局）远比 Flex （一维布局）布局强大。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。<br>2、概念：容器，项目，行，列，单元格（行与列的交叉部分），网格线。<br><strong>注意</strong>：设置为 Grid 布局后，子元素的 float、display: inline-block、display: table-cell、vertical-align 和 column-*属性将失效<br>3、容器属性：grid-template-columns 和 grid-template-rows 定义每一列列宽和每一行行高（多少行&#x2F;列就有多少个值，可以是 px、是百分比、fr；也可以直接写 repeat(3, 33.33%);），grid-gap: grid-row-gap grid-column-gap，单元格内容的水平和垂直位置 place-items: align-items justify-items ，整个内容区域在容器里面的水平和垂直位置 place-content: align-content justify-content ……</p>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/3aba8826a43c47f999875e07ca6b9eeb">响应式布局</a></h3><h3 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h3><ol>
<li>媒体查询，选取主流设备宽度尺寸作为断点进行样式编写（后面的样式会覆盖前面的样式）</li>
<li>加标签<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>
告诉浏览器，使用的设备的宽度作为视图宽度，并禁止初始的缩放</li>
<li>总结方案：（1）媒体查询+px ;（2）媒体查询+rem</li>
</ol>
<p>从 Vue 项目中总结的<br>初始化：<br>1、在 index.html 的 meta 标签中的 viewport 的 content 中加 minimum-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;no<br>2、引入 reset.css 重置页面的样式，设定不同手机浏览器的初始化样式<br>3、引入 border.css 解决移动端的 1px 边框的问题<br>4、300ms 点击延迟的问题：在某些浏览器用 click 事件的时候，会延迟 300ms。用 npm 安装 fastclick 模块解决之<br>设计：<br>1、把 html 的 font-size 设置为 50px（reset.css 中），然后项目中所有的宽高和 font-size 都用 rem 来做单位。这是因为移动端的设计稿一半是二倍图，这样设计稿中的 10px 其实是 5px，写 css 的时候就是 0.1rem，比较方便。<br>2、图片加载防抖四件套：overflow:hidden; width:0; height:0; padding-bottom: 100%<br>3、加 1px 边框的方法：直接在 div 上添加 class&#x3D;”border-top&#x2F;bottom”<br>4、长文本省略：overflow: hidden; white-space: nowrap; text-overflow: ellipsis</p>
<p><strong>参考资料</strong><br><a target="_blank" rel="noopener" href="http://zh.learnlayout.com/">学习 CSS 布局</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chaixiaozhi/p/8481778.html">CSS 布局(四) float 详解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chaixiaozhi/p/8490725.html">CSS 布局(六) 对齐方式</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010698609">七种实现左侧固定，右侧自适应两栏布局的方法</a><br><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2009/11/%E6%88%91%E7%86%9F%E7%9F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%89%E6%A0%8F%E7%BD%91%E9%A1%B5%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95/">我熟知的三种三栏网页宽度自适应布局方法</a><br><a target="_blank" rel="noopener" href="http://www.imooc.com/wenda/detail/254035">双飞翼布局</a><br><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/">CSS 深入理解流体特性和 BFC 特性下多栏自适应布局</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/09/CSS%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/" data-id="clmniym6d0007bb872ch71gco" data-title="CSS之页面布局详解" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CSS知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/08/CSS%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2019-10-08T15:20:21.000Z" itemprop="datePublished">2019-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/08/CSS%E7%9F%A5%E8%AF%86%E7%82%B9/">CSS知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h3><p>1、选择器<br>2、盒模型<br>3、伪类（处理 a 标签的那些和用来处理选择器的:first-child，:nth-child 等）和伪元素(eg. 处理 p 标签首行或首字母的:first-line 和:first-letter ；在元素的内容之前或之后插入内容的:before 和:after)<br>4、页面导入样式时，使用 link 和@import 的区别</p>
<ul>
<li>link 属于 XHTML 标签，除了加载 CSS 外，定义 rel 连接属性等作用；而@import 是 CSS 提供的，只能用于加载 CSS;</li>
<li>页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载;</li>
<li>@import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题;</li>
</ul>
<p>5、</p>
<ul>
<li>行内元素和块级元素的区别：行内元素会在一行水平方向排列，块级元素独占一行，自动填满父级元素；块级元素可以包含行内元素和块级元素，行内只能包含文本和其他行内元素；行内元素不能设置宽高</li>
<li>inline-block、inline 和 block 的区别：block 除了上述特性外，还有前后都有换行符；inline 设置宽高无效，margin 在竖直方向无效，padding 有效（但最好也不要设，不会挤开其他盒子的内容），前后无换行符；inline-block 可以设置宽高，margin&#x2F;padding 有效，前后无换行符</li>
</ul>
<p>6、为什么 img 是 inline 还可以设置宽高<br>img 是置换元素。置换元素是具有固有尺寸（intrinsic dimensions），浏览器根据其标签和属性决定显示内容的元素。<br>浏览器根据 img 的 src 属性渲染出对应路径的图片。图片具有固有尺寸，即你不做设置时，它就会照其固有尺寸渲染。<br>这类元素的展现效果不是由 CSS 来控制的。他们是一种外部对象，外观的渲染独立于 CSS。内容不受当前文档的样式影响，CSS 可以影响置换的位置，但是不会影响到置换自身的内容。（比如 iframe，可能有自己的样式表，不会继承父文档的样式）置换元素有内置宽高，性质同设置了 inline-block 一样。置换元素还有视觉元素 img、object, video；表单元素 input，select，textarea；audio 和 canvas</p>
<p>7、CSS 选择器的权重排序</p>
<ol>
<li>！important 权重无限大</li>
<li>内联样式 写在 html 标签里的，权值为 1000</li>
<li>id，权值为 100</li>
<li>类 伪类 和属性选择器，权值为 10</li>
<li>标签选择器和伪元素选择器 div p:after，权值为 1</li>
<li>通配符、子选择器、相邻选择器</li>
<li><strong>继承的样式没有权值</strong></li>
</ol>
<p>8、外边距重叠<br><strong>相邻</strong>的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距（所以有时候让其不发生可以加个空格或者空标签）。其折叠结果遵循下列规则：</p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和</li>
</ul>
<p>解决方法：两者间加个空格或空盒子；给其中一个盒子加 overflow: hidden 形成 BFC</p>
<p>9、层叠上下文<br>层叠上线文就是结界，其中的元素如果跟层叠上下文之外的元素发生层叠，就比较他们的层叠水平高低来显示。<br>创建的方法：postion 为 relative、absolute、fixed 的元素设置 z-index<br>顺序是：底层的 border、background，负值 z-index，块级盒子，浮动盒子，内联盒子，z-index：auto, 正 z-index<br>10、元素隐藏方法和区别</p>
<ul>
<li>display：none 元素不可见，不占据空间，资源会加载，DOM 可以访问</li>
<li>visibility:hidden 元素不可见，不能点击，但占据空间，资源会加载，可以使用。</li>
<li>opacity：0 元素不可见、可以点击，占据空间，可以使用。（不占据的话再加一个 position absolute)(不能点击不占据空间 postion absolute+z-index:-1)(不能点击、占据空间 postion relative z-index:-1)</li>
</ul>
<p><strong><code>display：none</code>和<code>visibility:hidden</code>的区别</strong></p>
<ul>
<li>display：none 元素不占据空间，visibility:hidden 空间保留</li>
<li>display：none 会影响 opacity 过渡效果</li>
<li>display 会产生重绘回流，visibility:hidden 只重绘</li>
<li>display：none 节点和子孙节点都不见，visibility:hidden 的子孙节点可以设置 visibility:visible 显示。</li>
<li>visibility:hidden 不会影响计数器计数（ol 标签）</li>
</ul>
<p>11、img 和 background-image 的区别</p>
<ul>
<li>解析机制：img 属于 html 标签，background-img 属于 css。img 先解析</li>
<li>SEO：img 标签有一个 alt 属性可以指定图像的替代文本，有利于 SEO，并且在图片加载失败时有利于阅读</li>
<li>语义化角度：img 语义更加明确</li>
</ul>
<p>12、rgba()和 opacity 的区别</p>
<ul>
<li>opacity 作用于元素及元素中所有的内容（包括文字、图片） 有继承性</li>
<li>rgba()只用于元素的颜色及背景色</li>
<li>当 opacity 属性的值应用于某个元素上时，把这个元素和它内容当作一个整体来看待，即使这个值没有被子元素继承。因此一个元素和它包含的元素都会有与元素背景相同的透明度，哪怕父子元素由不同的 opacity 的值。</li>
</ul>
<p>13、CSS 哪些属性可以被继承</p>
<ul>
<li>字体相关属性<ul>
<li>font-family 字体系列</li>
<li>font-weight 字体粗细程度</li>
<li>font-size 字体大小</li>
<li>font-style 字体风格</li>
</ul>
</li>
<li>文本相关属性<ul>
<li>text-indent 文本缩进</li>
<li>text-align 文本对齐方式</li>
<li>line-height 行高</li>
<li>color 文本颜色</li>
</ul>
</li>
<li>元素可见性<ul>
<li>visibility 控制元素的显示和隐藏</li>
</ul>
</li>
<li>列表布局属性<ul>
<li>list-style 列表风格 包括 list-style-type list-style-image 等</li>
</ul>
</li>
<li>光标属性<ul>
<li>cursor 光标显示的各种形态</li>
</ul>
</li>
</ul>
<p>14、transition、animation 的区别<br>二者都能实现动画，animation 和 transition 大部分属性相同，都是随时间改变元素的属性值，区别是 transition 需要触发一个事件（eg. :hover）才能改变属性；animation 不需要触发任何事件随时间改变属性。transition 为 2 帧，from……to ，animation 可以一帧一帧的。</p>
<p>15、重绘和回流（重排）是什么，如何避免？<br>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘<br>回流是布局或者几何属性需要改变就称为回流。<br>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。<br>导致回流发生的因素：</p>
<ol>
<li>调整窗口大小，浏览器窗口尺寸改变——resize 事件发生时</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度；改变字体大小</li>
<li>页面渲染初始化</li>
<li>元素位置改变</li>
<li>样式表变动</li>
<li>元素内容变化，尤其是输入控件</li>
<li>CSS 伪类激活</li>
<li>DOM 操作，添加或者删除可见的 DOM 元素</li>
<li>offsetWidth, width, clientWidth, scrollTop&#x2F;scrollHeight 的计算， 会使浏览器将渐进回流队列 Flush，立即执行回流。内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变</li>
</ol>
<p><strong>减少重绘和回流</strong></p>
<ul>
<li>使用 transform 替代 top</li>
<li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li>
<li>CSS 选择符从右往左匹配查找，避免节点层级过多</li>
<li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。通过以下几个常用属性可以生成新图层：<ul>
<li>position: fixed</li>
<li>video、iframe 标签</li>
<li>通过动画实现的 opacity 动画转换</li>
</ul>
</li>
</ul>
<p>16、CSS Sprites<br>是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中， 利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。<br><strong>优点</strong>：减少 HTTP 请求数，极大地提高页面加载速度；提高压缩比，减少图片大小，减少图片的字节；更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现<br><strong>缺点</strong>：图片合并麻烦；维护麻烦，修改一个图片可能需要从新布局整个图片，样式</p>
<p>17、padding颜色是背景色 </p>
<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><h5 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h5><ul>
<li>新增选择器：伪类选择器 E：nth-child(n) E:nth-last-child(n)</li>
<li>Transition、Transform 和 Animation</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">transition-property</span>:width;</span><br><span class="line">    <span class="attribute">transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>:linear;</span><br><span class="line">    <span class="attribute">transition-delay</span>:<span class="number">25</span>;</span><br><span class="line">    <span class="comment">/*简写形式*/</span></span><br><span class="line">    <span class="attribute">transition</span>:width <span class="number">1s</span> linear <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">transform</span>:</span><br><span class="line"><span class="built_in">scale</span>()大小, <span class="built_in">translate</span>()位置</span><br><span class="line">div&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">7deg</span>);</span><br><span class="line">    -ms-<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">7deg</span>);<span class="comment">/*IE9*/</span></span><br><span class="line">    -moz-<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">7deg</span>);<span class="comment">/*FireFox*/</span></span><br><span class="line">    -webkit-<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">7deg</span>);<span class="comment">/*Safari和Chrome*/</span></span><br><span class="line">    -o-<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">7deg</span>);<span class="comment">/*Opwea*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">animation</span>:</span><br><span class="line">@keyframes myAnimation&#123;</span><br><span class="line">    <span class="number">0%</span>&#123;<span class="attribute">background</span>:red;<span class="attribute">width</span>:<span class="number">100px</span>;&#125;</span><br><span class="line">    <span class="number">25%</span>&#123;<span class="attribute">background</span>:orange;<span class="attribute">width</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">    <span class="number">50%</span>&#123;<span class="attribute">background</span>:yellow;<span class="attribute">width</span>:<span class="number">100px</span>;&#125;</span><br><span class="line">    <span class="number">75%</span>&#123;<span class="attribute">background</span>:green;<span class="attribute">width</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">    <span class="number">100%</span>&#123;<span class="attribute">background</span>:blue:width:<span class="number">100px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>:myAnimation <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>边框：box-shadow, border-radius, border-image</li>
<li>背景：background-clip, 自定义背景图片的裁剪区域 background-size</li>
<li>文字：text-shadow, text-overflow 当文本溢出包含元素时发生的事情</li>
<li>字体：@font-face 可以引用 Web 服务器的字体</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: myFirstFont;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">sansation_light, woff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>17、Rem,em 和 px 的区别<br>px 是绝对长度单位；em 是相对长度单位，继承父级元素的字体大小，所有字体都是相对于父元素大小的；rem 是相对长度单位，根元素（html),不会像 em 造成混乱。<br>元素的 margin，padding 设置百分数，百分数是相对于最近的块级父元素的 width 计算<br>18、移动端 0.5px 边框（直接写 border 是 0.5px 在安卓下会显示不出来）<br>利用 伪元素 结合 transform: scale(0.5, 0.5)<br>思路:</p>
<ol>
<li>目标盒子设置为相对定位。给目标盒子加伪元素:before，并设置为绝对定位；</li>
<li>给伪元素添加 1px 的边框，box-sizing: border-box，宽和高设置为 200%，整个盒子模型缩小 transform: scale(0.5, 0.5)；</li>
<li>调整盒子模型的位置，以左上角为基准 transform-origin: 0 0;</li>
</ol>
<p>19、 calc 结合 vw 、vh、vmin 、vmax 的使用<br>eg. width：calc(100% - 10px) 。括号中可以加一些表达式</p>
<ul>
<li>vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）</li>
<li>vh：视窗高度的百分比</li>
<li>vmin：当前 vw 和 vh 中较小的一个值</li>
<li>vmax：当前 vw 和 vh 中较大的一个值</li>
</ul>
<h3 id="CSS-模块化"><a href="#CSS-模块化" class="headerlink" title="CSS 模块化"></a>CSS 模块化</h3><h5 id="vue-中-style-标签中设置-scoped-的原理"><a href="#vue-中-style-标签中设置-scoped-的原理" class="headerlink" title="vue 中 style 标签中设置 scoped 的原理"></a>vue 中 style 标签中设置 scoped 的原理</h5><p>这个局部样式是通过 PostCSS 给组件中所有的 DOM 添加了一个独一无二的动态属性，然后通过 CSS 属性选择器来选择组件中的 DOM</p>
<h5 id="CSS-预处理"><a href="#CSS-预处理" class="headerlink" title="CSS 预处理"></a>CSS 预处理</h5><p><strong>优点</strong><br>用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以便项目使用；CSS 更加简洁、适应性更强，更易于代码的维护<br>比如可以用 sass，stylus 和 less</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/08/CSS%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="clmniym6f0009bb87hui2gdui" data-title="CSS知识点" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HTML" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/08/HTML/" class="article-date">
  <time class="dt-published" datetime="2019-10-08T09:20:21.000Z" itemprop="datePublished">2019-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/08/HTML/">HTML</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h3><p>1、 Doctype作用？严格模式与混杂模式如何区分？它们有何意义?</p>
<ul>
<li>作用：声明文件类型定义（DTD），位于文档中最前面，作用是为了告知浏览器应该用哪种文档类型规范来解析文档</li>
<li>定义<ul>
<li>严格模式（标准模式)，浏览器按照W3C标准来解析</li>
<li>混杂模式，向后兼容的解析方法，浏览器用自己的方式解析代码</li>
</ul>
</li>
<li>如何区分？<br>用DTD来判断<ul>
<li>有严格格式DTD——严格模式；</li>
<li>有URL的过渡DTD——严格模式，没有URL的过渡DTD——混杂模式；</li>
<li>DTD不存在&#x2F;格式不对——混杂模式；</li>
<li>HTML5没有严格和混杂之分</li>
</ul>
</li>
<li>区分的意义<br>严格模式的排版和js运行模式以浏览器支持的最高标准运行。如果只存在严格模式，那么很多旧网站站点无法工作。</li>
</ul>
<p>2、 head中的meta：提供关于 HTML 文档的元数据(规定页面的描述、关键词、文档的作者、编码方式等)，属性有 http-equiv + content； name + content。<br>3、 无序列表ul，有序列表ol,表格table-tr-td<br>4、 表单form（action&#x3D;”定义在submit时候的动作” method&#x3D;”GET&#x2F;POST”）（一般在form正下方会接个fieldset标签和legend标签（定义标题））<br>表单元素：input（type&#x3D;”text&#x2F;radio&#x2F;submit…）,下拉列表select-option,大文本输入框textarea<br>HTML5新增表单元素：datalist，结合input、option使用，能实现输入框有下拉菜单效果。还有相对少用的keygen、output<br>5、 em来表示强调的文本，应该使用strong来表示重要文本(内容重要性)<br>6、 src和herf的区别<br>href指向网络资源位置，建立当前文档和资源的连接，一般用于超链接<br>src将所指向资源嵌入到当前文档标签中，在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕。这也是为什么将js脚本放在底部而不是头部。<br>7、 WEB标准以及W3C标准是什么?<br>标签闭合、标签小写、不乱嵌套、属性值用双引号、使用外链css和js、结构行为表现的分离<br>8、 语义化的理解</p>
<ul>
<li>用正确的标签做正确的事情！</li>
<li>HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li>
<li>在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。</li>
<li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li>
</ul>
<p>9、 XHTML和HTML有什么区别?<br>XHTML 是更严谨更纯净的HTML版本</p>
<ul>
<li>一个是功能上的差别：主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页</li>
<li>另外是书写习惯的差别：XHTML元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</li>
</ul>
<p>10、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</p>
<ul>
<li>行内元素有：a b span strong img input select </li>
<li>块级元素有：div ul ol li dl dt dd（都是列表类） h1 h2 h3 h4… p <strong>form</strong> <strong>hr</strong></li>
<li>空元素：br hr（水平线） img input link meta （不需要闭标签）</li>
<li>行内元素不可以设置宽高，不独占一行</li>
<li>块级元素可以设置宽高，独占一行</li>
</ul>
<p>11、渐进增强和优雅降级<br>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<blockquote>
<p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功&gt; 能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>
</blockquote>
<p>12、a标签href不跳转<br>当页面中a标签不需要任何跳转时，从原理上来讲，可分如下两种方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签属性href，使其指向空或不返回任何内容。如：</span></span><br><span class="line">&lt;a href=<span class="string">&quot;javascript:void(0);&quot;</span> &gt;点此无反应<span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="number">0</span>)&lt;/a&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> &gt;</span>点此无反应javascript:<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 标签事件onclick，阻止其默认行为。如：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span>return false;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span>return false;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 注意：只有一个href=&quot;#&quot;是不可以的。</span></span><br></pre></td></tr></table></figure>
<p>13、<code>ifame</code>标签：一个页面有多个window</p>
<ul>
<li>可以通过contentWindow和contentDocument两个API获取iframe的window对象和document对象</li>
<li>通过window.self，window.parent，window.top这三个属性分别获取自身window对象，父级window对象，顶级window对象</li>
</ul>
<p>14、如果一个元素拥有ID属性,那么会创建同名的全局变量</p>
<h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><p>1、html5有哪些新特性、移除了那些元素？</p>
<ul>
<li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加<ul>
<li>新增元素<ul>
<li>通过 JavaScript 来绘制2D图形的 canvas 画布标签</li>
<li>使用 XML 描述 2D 图形的语言：SVG （好比HTML相对于文本）</li>
<li>视频 video 和 音频 audio 元素</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section</li>
</ul>
</li>
<li>API及功能<ul>
<li>获取用户地理位置的 geolocationAPI</li>
<li>draggable 属性可拖动</li>
<li>Web存储。本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>应用程序缓存（Application Cache），通过创建 cache manifest 文件，可创建 web 应用的离线版本。</li>
<li>新的技术webworker（是运行在后台的 JavaScript，位于外部文件中，不会影响页面的性能）、 websocket、</li>
</ul>
</li>
</ul>
</li>
<li>移除的元素：<ul>
<li>纯表现的元素：basefont、big、center、font、 s、strike、tt、u</li>
<li>对可用性产生负面影响的元素：frame、frameset、noframes</li>
</ul>
</li>
<li>支持HTML5新标签：<ul>
<li>IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签</li>
<li>可以利用这一特性让这些浏览器支持HTML5新标签</li>
<li>浏览器支持新标签后，还需要添加标签默认的样式</li>
</ul>
</li>
<li>当然也可以直接使用成熟的框架、比如html5shim</li>
</ul>
<p>2、 HTML5 为什么只需要写 <code>!DOCTYPE HTML</code><br>HTML5 不基于SGML（不是SGML的子集），因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为<br>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</p>
<blockquote>
<p>SGML：标准通用标记语言,国际上定义电子文件结构和内容描述的标准，一个庞大的标准，应用范围很广<br>XML：可扩展标识语言（eXtensible Markup Language），一种精简的SGML版本，一个用来定义其他语言的元语言</p>
</blockquote>
<p>3、HTML5的离线储存怎么使用及其原理</p>
<ul>
<li>功能：在用户没有网络连接时，可以正常访问站点，在用户与有网络连接时，更新用户机器上的缓存文件</li>
<li>原理：基于一个新建的.appcache文件（缓存清单），浏览器打开的并有网络连接的时候，会通过这个清单进行资源缓存。之后离线就可以根据缓存显示页面</li>
<li>使用：在head标签加manifest，指向一个.appcache文件，对该文件编写即可。文件内容分为三部分：CACHE MANIFEST（需要缓存的资源）；NETWORK（不缓存的资源）；FALLBACK（若无法建立因特网连接，就用某文件替代某个文件）。离线状态时，操作window.applicationCache进行需求实现</li>
</ul>
<p>4、cookies，sessionStorage 和 localStorage 的区别</p>
<ul>
<li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>
<li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li>
<li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</li>
<li>存储大小：<ul>
<li>cookie数据大小不能超过4k</li>
<li>sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
</ul>
</li>
<li>有期时间：<ul>
<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/08/HTML/" data-id="clmniym6n000jbb872i1q4n92" data-title="HTML" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Basic-knowledge/">Basic knowledge</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Engineering/">Engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/">上线部署</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/" rel="tag">Browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer/" rel="tag">Computer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-structure/" rel="tag">Data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/" rel="tag">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-system/" rel="tag">Operating system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/" rel="tag">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" rel="tag">上线部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="tag">解决方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" rel="tag">项目小结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/CSS/" style="font-size: 14px;">CSS</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Data-structure/" style="font-size: 18px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Node/" style="font-size: 12px;">Node</a> <a href="/tags/Nodejs/" style="font-size: 12px;">Nodejs</a> <a href="/tags/Operating-system/" style="font-size: 10px;">Operating system</a> <a href="/tags/Performance/" style="font-size: 12px;">Performance</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/TypeScript/" style="font-size: 14px;">TypeScript</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 10px;">Web安全</a> <a href="/tags/webpack/" style="font-size: 20px;">webpack</a> <a href="/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">上线部署</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 16px;">框架</a> <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 10px;">解决方案</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/" style="font-size: 14px;">项目小结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/30/Python%20Basic/">Python Basic Knowledge</a>
          </li>
        
          <li>
            <a href="/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决hexo g生成index.html为空的问题</a>
          </li>
        
          <li>
            <a href="/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a>
          </li>
        
          <li>
            <a href="/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a>
          </li>
        
          <li>
            <a href="/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/">hope statistics puppeteer 工具小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Jacleklm<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>